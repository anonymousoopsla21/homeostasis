/* Generated By:JavaCC: Do not edit this line. CParser.java */
import java.util.*;
import syntaxtree.*;
import java.util.Vector;


public class CParser implements CParserConstants {
   public Hashtable types = new Hashtable();
   public boolean flag = true;
   public CParser()
   {
      types = new Hashtable();
      types.put("__builtin_va_list",Boolean.TRUE);
      types.put("_Bool",Boolean.TRUE);
      types.put("bool",Boolean.TRUE);
   }
   public Stack typedefParsingStack = new Stack();
   public boolean isType(String type)
   {
      if ( types.get(type) != null )
      {
         return true;
      }
      return false;
   }
   public void addType(String type)
   {
      types.put(type,Boolean.TRUE);
   }
   public void printTypes()
   {
      Enumeration enum1 = types.keys();
      while ( enum1.hasMoreElements() )
      {
         System.out.println(enum1.nextElement());
      }
   }

  final public TranslationUnit TranslationUnit() throws ParseException {
   NodeList n0 = new NodeList();
   ElementsOfTranslation n1;
    label_1:
    while (true) {
      n1 = ElementsOfTranslation();
        n0.addNode(n1);
      if (jj_2_1(1)) {
        ;
      } else {
        break label_1;
      }
    }
     n0.nodes.trimToSize();
     {if (true) return new TranslationUnit(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ElementsOfTranslation ElementsOfTranslation() throws ParseException {
   NodeChoice n0;
   ExternalDeclaration n1;
   UnknownCpp n2;
   UnknownPragma n3;
    if (jj_2_2(4)) {
      n1 = ExternalDeclaration();
        n0 = new NodeChoice(n1, 0);
    } else if (jj_2_3(3)) {
      n2 = UnknownCpp();
        n0 = new NodeChoice(n2, 1);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CROSSBAR:
        n3 = UnknownPragma();
        n0 = new NodeChoice(n3, 2);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new ElementsOfTranslation(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ExternalDeclaration ExternalDeclaration() throws ParseException {
   NodeChoice n0;
   Declaration n1;
   FunctionDefinition n2;
   OmpGlobalDirective n3;
    if (jj_2_4(2147483647)) {
      n1 = Declaration();
        n0 = new NodeChoice(n1, 0);
    } else if (jj_2_5(1)) {
      n2 = FunctionDefinition();
        n0 = new NodeChoice(n2, 1);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CROSSBAR:
        n3 = OmpGlobalDirective();
        n0 = new NodeChoice(n3, 2);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new ExternalDeclaration(n0);}
    throw new Error("Missing return statement in function");
  }

  final public FunctionDefinition FunctionDefinition() throws ParseException {
   NodeOptional n0 = new NodeOptional();
   DeclarationSpecifiers n1;
   Declarator n2;
   NodeOptional n3 = new NodeOptional();
   DeclarationList n4;
   CompoundStatement n5;
    if (jj_2_6(2147483647)) {
      n1 = DeclarationSpecifiers();
        n0.addNode(n1);
    } else {
      ;
    }
    n2 = Declarator();
    if (jj_2_7(1)) {
      n4 = DeclarationList();
        n3.addNode(n4);
    } else {
      ;
    }
    n5 = CompoundStatement();
     {if (true) return new FunctionDefinition(n0,n2,n3,n5);}
    throw new Error("Missing return statement in function");
  }

  final public Declaration Declaration() throws ParseException {
   NodeChoice n0;
   NodeSequence n1;
   DeclarationSpecifiers n2;
   NodeOptional n3 = new NodeOptional();
   InitDeclaratorList n4;
   NodeToken n5;
   Token n6;
   StaticAssertDeclaration n7;
    if (jj_2_8(1)) {
        n1 = new NodeSequence(3);
      n2 = DeclarationSpecifiers();
        n1.addNode(n2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OP_MUL:
      case OP_BITXOR:
      case LEFTPAREN:
      case IDENTIFIER:
        n4 = InitDeclaratorList();
           n3.addNode(n4);
        break;
      default:
        jj_la1[2] = jj_gen;
        ;
      }
        n1.addNode(n3);
      n6 = jj_consume_token(SEMICOLON);
               n5 = JTBToolkit.makeNodeToken(n6);
        n1.addNode(n5);
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STATIC_ASSERT:
        n7 = StaticAssertDeclaration();
        n0 = new NodeChoice(n7, 1);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new Declaration(n0);}
    throw new Error("Missing return statement in function");
  }

  final public StaticAssertDeclaration StaticAssertDeclaration() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   ConstantExpression n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
    n1 = jj_consume_token(STATIC_ASSERT);
                        n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = ConstantExpression();
    n6 = jj_consume_token(COMMA);
            n5 = JTBToolkit.makeNodeToken(n6);
    n8 = jj_consume_token(STRING_LITERAL);
                         n7 = JTBToolkit.makeNodeToken(n8);
    n10 = jj_consume_token(RIGHTPAREN);
             n9 = JTBToolkit.makeNodeToken(n10);
     {if (true) return new StaticAssertDeclaration(n0,n2,n4,n5,n7,n9);}
    throw new Error("Missing return statement in function");
  }

  final public DeclarationList DeclarationList() throws ParseException {
   NodeList n0 = new NodeList();
   Declaration n1;
    label_2:
    while (true) {
      n1 = Declaration();
        n0.addNode(n1);
      if (jj_2_9(2147483647)) {
        ;
      } else {
        break label_2;
      }
    }
     n0.nodes.trimToSize();
     {if (true) return new DeclarationList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public DeclarationSpecifiers DeclarationSpecifiers() throws ParseException {
   NodeList n0 = new NodeList();
   ADeclarationSpecifier n1;
    label_3:
    while (true) {
      n1 = ADeclarationSpecifier();
        n0.addNode(n1);
      if (jj_2_10(1)) {
        ;
      } else {
        break label_3;
      }
    }
     n0.nodes.trimToSize();
     {if (true) return new DeclarationSpecifiers(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ADeclarationSpecifier ADeclarationSpecifier() throws ParseException {
   NodeChoice n0;
   StorageClassSpecifier n1;
   TypeSpecifier n2;
   TypeQualifier n3;
   FunctionSpecifier n4;
   AlignmentSpecifier n5;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REGISTER:
    case TYPEDEF:
    case EXTERN:
    case STATIC:
    case AUTO:
      n1 = StorageClassSpecifier();
        n0 = new NodeChoice(n1, 0);
      break;
    default:
      jj_la1[4] = jj_gen;
      if (jj_2_11(1)) {
        n2 = TypeSpecifier();
        n0 = new NodeChoice(n2, 1);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESTRICT:
        case VOLATILE:
        case CCONST:
        case CSIGNED:
        case CSIGNED2:
        case CONST:
          n3 = TypeQualifier();
        n0 = new NodeChoice(n3, 2);
          break;
        case NORETURN:
        case INLINE:
          n4 = FunctionSpecifier();
        n0 = new NodeChoice(n4, 3);
          break;
        case ALIGNAS:
          n5 = AlignmentSpecifier();
        n0 = new NodeChoice(n5, 4);
          break;
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
     {if (true) return new ADeclarationSpecifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public FunctionSpecifier FunctionSpecifier() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INLINE:
      n2 = jj_consume_token(INLINE);
                    n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case NORETURN:
      n4 = jj_consume_token(NORETURN);
                      n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new FunctionSpecifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public AlignmentSpecifier AlignmentSpecifier() throws ParseException {
   NodeChoice n0;
   AlignAsTypeName n1;
   AlignAsConstantExpression n2;
    if (jj_2_12(2147483647)) {
      n1 = AlignAsTypeName();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIGNAS:
        n2 = AlignAsConstantExpression();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new AlignmentSpecifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public AlignAsTypeName AlignAsTypeName() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   TypeName n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(ALIGNAS);
                  n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = TypeName();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new AlignAsTypeName(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public AlignAsConstantExpression AlignAsConstantExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   ConstantExpression n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(ALIGNAS);
                  n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = ConstantExpression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new AlignAsConstantExpression(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public StorageClassSpecifier StorageClassSpecifier() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AUTO:
      n2 = jj_consume_token(AUTO);
                  n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case REGISTER:
      n4 = jj_consume_token(REGISTER);
                      n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case STATIC:
      n6 = jj_consume_token(STATIC);
                    n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case EXTERN:
      n8 = jj_consume_token(EXTERN);
                    n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
      break;
    case TYPEDEF:
      n10 = jj_consume_token(TYPEDEF);
                      n9 = JTBToolkit.makeNodeToken(n10);
         flag = true;
         typedefParsingStack.push(Boolean.TRUE);
        n0 = new NodeChoice(n9, 4);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new StorageClassSpecifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public TypeSpecifier TypeSpecifier() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   StructOrUnionSpecifier n19;
   EnumSpecifier n20;
   TypedefName n21;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VOID:
      n2 = jj_consume_token(VOID);
                     n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
      break;
    case CHAR:
      n4 = jj_consume_token(CHAR);
                     n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
      break;
    case SHORT:
      n6 = jj_consume_token(SHORT);
                      n5 = JTBToolkit.makeNodeToken(n6);
           n0 = new NodeChoice(n5, 2);
      break;
    case INT:
      n8 = jj_consume_token(INT);
                    n7 = JTBToolkit.makeNodeToken(n8);
           n0 = new NodeChoice(n7, 3);
      break;
    case LONG:
      n10 = jj_consume_token(LONG);
                      n9 = JTBToolkit.makeNodeToken(n10);
           n0 = new NodeChoice(n9, 4);
      break;
    case FLOAT:
      n12 = jj_consume_token(FLOAT);
                       n11 = JTBToolkit.makeNodeToken(n12);
           n0 = new NodeChoice(n11, 5);
      break;
    case DOUBLE:
      n14 = jj_consume_token(DOUBLE);
                        n13 = JTBToolkit.makeNodeToken(n14);
           n0 = new NodeChoice(n13, 6);
      break;
    case SIGNED:
      n16 = jj_consume_token(SIGNED);
                        n15 = JTBToolkit.makeNodeToken(n16);
           n0 = new NodeChoice(n15, 7);
      break;
    case UNSIGNED:
      n18 = jj_consume_token(UNSIGNED);
                          n17 = JTBToolkit.makeNodeToken(n18);
           n0 = new NodeChoice(n17, 8);
      break;
    case STRUCT:
    case UNION:
      n19 = StructOrUnionSpecifier();
           n0 = new NodeChoice(n19, 9);
      break;
    case ENUM:
      n20 = EnumSpecifier();
           n0 = new NodeChoice(n20, 10);
      break;
    default:
      jj_la1[9] = jj_gen;
      if ((!typedefParsingStack.empty() && ((Boolean)typedefParsingStack.peek()).booleanValue()&& flag == true) || ((typedefParsingStack.empty() || !((Boolean)typedefParsingStack.peek()).booleanValue()) && isType(getToken(1).image))) {
        n21 = TypedefName();
           n0 = new NodeChoice(n21, 11);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      if ( (!typedefParsingStack.empty()) && ((Boolean)typedefParsingStack.peek()).booleanValue() )
         flag = false;
     {if (true) return new TypeSpecifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public TypeQualifier TypeQualifier() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RESTRICT:
      n2 = jj_consume_token(RESTRICT);
                      n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case CONST:
      n4 = jj_consume_token(CONST);
                   n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case VOLATILE:
      n6 = jj_consume_token(VOLATILE);
                      n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case CCONST:
      n8 = jj_consume_token(CCONST);
                    n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
      break;
    case CSIGNED:
      n10 = jj_consume_token(CSIGNED);
                      n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4);
      break;
    case CSIGNED2:
      n12 = jj_consume_token(CSIGNED2);
                       n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new TypeQualifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public StructOrUnionSpecifier StructOrUnionSpecifier() throws ParseException {
   NodeChoice n0;
   StructOrUnionSpecifierWithList n1;
   StructOrUnionSpecifierWithId n2;
      typedefParsingStack.push(Boolean.FALSE);
    if (jj_2_13(4)) {
      n1 = StructOrUnionSpecifierWithList();
           n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRUCT:
      case UNION:
        n2 = StructOrUnionSpecifierWithId();
           n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      typedefParsingStack.pop();
     {if (true) return new StructOrUnionSpecifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public StructOrUnionSpecifierWithList StructOrUnionSpecifierWithList() throws ParseException {
   StructOrUnion n0;
   NodeOptional n1 = new NodeOptional();
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   StructDeclarationList n6;
   NodeToken n7;
   Token n8;
    n0 = StructOrUnion();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      n3 = jj_consume_token(IDENTIFIER);
                        n2 = JTBToolkit.makeNodeToken(n3);
        n1.addNode(n2);
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    n5 = jj_consume_token(LEFTBRACE);
            n4 = JTBToolkit.makeNodeToken(n5);
    n6 = StructDeclarationList();
    n8 = jj_consume_token(RIGHTBRACE);
            n7 = JTBToolkit.makeNodeToken(n8);
     {if (true) return new StructOrUnionSpecifierWithList(n0,n1,n4,n6,n7);}
    throw new Error("Missing return statement in function");
  }

  final public StructOrUnionSpecifierWithId StructOrUnionSpecifierWithId() throws ParseException {
   StructOrUnion n0;
   NodeToken n1;
   Token n2;
    n0 = StructOrUnion();
    n2 = jj_consume_token(IDENTIFIER);
                     n1 = JTBToolkit.makeNodeToken(n2);
     {if (true) return new StructOrUnionSpecifierWithId(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public StructOrUnion StructOrUnion() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRUCT:
      n2 = jj_consume_token(STRUCT);
                    n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case UNION:
      n4 = jj_consume_token(UNION);
                   n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new StructOrUnion(n0);}
    throw new Error("Missing return statement in function");
  }

  final public StructDeclarationList StructDeclarationList() throws ParseException {
   NodeList n0 = new NodeList();
   StructDeclaration n1;
    label_4:
    while (true) {
      n1 = StructDeclaration();
        n0.addNode(n1);
      if (jj_2_14(1)) {
        ;
      } else {
        break label_4;
      }
    }
     n0.nodes.trimToSize();
     {if (true) return new StructDeclarationList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public InitDeclaratorList InitDeclaratorList() throws ParseException {
   InitDeclarator n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   InitDeclarator n5;
    n0 = InitDeclarator();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_5;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = InitDeclarator();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
      if ( !(typedefParsingStack.empty()) && ((Boolean)typedefParsingStack.peek()).booleanValue() )
      {
         typedefParsingStack.pop();
      }
     {if (true) return new InitDeclaratorList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public InitDeclarator InitDeclarator() throws ParseException {
   Declarator n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   Initializer n5;
    n0 = Declarator();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_ASS:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(OP_ASS);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = Initializer();
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
     {if (true) return new InitDeclarator(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public StructDeclaration StructDeclaration() throws ParseException {
   SpecifierQualifierList n0;
   StructDeclaratorList n1;
   NodeToken n2;
   Token n3;
    n0 = SpecifierQualifierList();
    n1 = StructDeclaratorList();
    n3 = jj_consume_token(SEMICOLON);
            n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new StructDeclaration(n0,n1,n2);}
    throw new Error("Missing return statement in function");
  }

  final public SpecifierQualifierList SpecifierQualifierList() throws ParseException {
   NodeList n0 = new NodeList();
   ASpecifierQualifier n1;
    label_6:
    while (true) {
      n1 = ASpecifierQualifier();
        n0.addNode(n1);
      if (jj_2_15(1)) {
        ;
      } else {
        break label_6;
      }
    }
     n0.nodes.trimToSize();
     {if (true) return new SpecifierQualifierList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ASpecifierQualifier ASpecifierQualifier() throws ParseException {
   NodeChoice n0;
   TypeSpecifier n1;
   TypeQualifier n2;
    if (jj_2_16(1)) {
      n1 = TypeSpecifier();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RESTRICT:
      case VOLATILE:
      case CCONST:
      case CSIGNED:
      case CSIGNED2:
      case CONST:
        n2 = TypeQualifier();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new ASpecifierQualifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public StructDeclaratorList StructDeclaratorList() throws ParseException {
   StructDeclarator n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   StructDeclarator n5;
    n0 = StructDeclarator();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_7;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = StructDeclarator();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new StructDeclaratorList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public StructDeclarator StructDeclarator() throws ParseException {
   NodeChoice n0;
   StructDeclaratorWithDeclarator n1;
   StructDeclaratorWithBitField n2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_MUL:
    case OP_BITXOR:
    case LEFTPAREN:
    case IDENTIFIER:
      n1 = StructDeclaratorWithDeclarator();
        n0 = new NodeChoice(n1, 0);
      break;
    case COLON:
      n2 = StructDeclaratorWithBitField();
        n0 = new NodeChoice(n2, 1);
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new StructDeclarator(n0);}
    throw new Error("Missing return statement in function");
  }

  final public StructDeclaratorWithDeclarator StructDeclaratorWithDeclarator() throws ParseException {
   Declarator n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   ConstantExpression n5;
    n0 = Declarator();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COLON);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = ConstantExpression();
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
     {if (true) return new StructDeclaratorWithDeclarator(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public StructDeclaratorWithBitField StructDeclaratorWithBitField() throws ParseException {
   NodeToken n0;
   Token n1;
   ConstantExpression n2;
    n1 = jj_consume_token(COLON);
            n0 = JTBToolkit.makeNodeToken(n1);
    n2 = ConstantExpression();
     {if (true) return new StructDeclaratorWithBitField(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public EnumSpecifier EnumSpecifier() throws ParseException {
   NodeChoice n0;
   EnumSpecifierWithList n1;
   EnumSpecifierWithId n2;
    if (jj_2_17(3)) {
      n1 = EnumSpecifierWithList();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ENUM:
        n2 = EnumSpecifierWithId();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new EnumSpecifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public EnumSpecifierWithList EnumSpecifierWithList() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   EnumeratorList n7;
   NodeToken n8;
   Token n9;
    n1 = jj_consume_token(ENUM);
               n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      n4 = jj_consume_token(IDENTIFIER);
                        n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    n6 = jj_consume_token(LEFTBRACE);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = EnumeratorList();
    n9 = jj_consume_token(RIGHTBRACE);
            n8 = JTBToolkit.makeNodeToken(n9);
     {if (true) return new EnumSpecifierWithList(n0,n2,n5,n7,n8);}
    throw new Error("Missing return statement in function");
  }

  final public EnumSpecifierWithId EnumSpecifierWithId() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
    n1 = jj_consume_token(ENUM);
               n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(IDENTIFIER);
                     n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new EnumSpecifierWithId(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public EnumeratorList EnumeratorList() throws ParseException {
   Enumerator n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   Enumerator n5;
    n0 = Enumerator();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_8;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = Enumerator();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new EnumeratorList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public Enumerator Enumerator() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   NodeSequence n3;
   NodeToken n4;
   Token n5;
   ConstantExpression n6;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_ASS:
        n3 = new NodeSequence(2);
      n5 = jj_consume_token(OP_ASS);
               n4 = JTBToolkit.makeNodeToken(n5);
        n3.addNode(n4);
      n6 = ConstantExpression();
        n3.addNode(n6);
        n2.addNode(n3);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
     {if (true) return new Enumerator(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public Declarator Declarator() throws ParseException {
   NodeOptional n0 = new NodeOptional();
   Pointer n1;
   DirectDeclarator n2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_MUL:
    case OP_BITXOR:
      n1 = Pointer();
        n0.addNode(n1);
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    n2 = DirectDeclarator();
     {if (true) return new Declarator(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public DirectDeclarator DirectDeclarator() throws ParseException {
   IdentifierOrDeclarator n0;
   DeclaratorOpList n1;
    n0 = IdentifierOrDeclarator();
    n1 = DeclaratorOpList();
     {if (true) return new DirectDeclarator(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public DeclaratorOpList DeclaratorOpList() throws ParseException {
   NodeListOptional n0 = new NodeListOptional();
   ADeclaratorOp n1;
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTPAREN:
      case LEFTBRACKET:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_9;
      }
      n1 = ADeclaratorOp();
        n0.addNode(n1);
    }
     n0.nodes.trimToSize();
     {if (true) return new DeclaratorOpList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ADeclaratorOp ADeclaratorOp() throws ParseException {
   NodeChoice n0;
   DimensionSize n1;
   ParameterTypeListClosed n2;
   OldParameterListClosed n3;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFTBRACKET:
      n1 = DimensionSize();
        n0 = new NodeChoice(n1, 0);
      break;
    default:
      jj_la1[26] = jj_gen;
      if (jj_2_18(3)) {
        n2 = ParameterTypeListClosed();
        n0 = new NodeChoice(n2, 1);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LEFTPAREN:
          n3 = OldParameterListClosed();
        n0 = new NodeChoice(n3, 2);
          break;
        default:
          jj_la1[27] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
     {if (true) return new ADeclaratorOp(n0);}
    throw new Error("Missing return statement in function");
  }

  final public DimensionSize DimensionSize() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   ConstantExpression n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(LEFTBRACKET);
            n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case _GENERIC:
    case SIZEOF:
    case OP_INCR:
    case OP_DECR:
    case OP_ADD:
    case OP_SUB:
    case OP_MUL:
    case OP_BITAND:
    case OP_NOT:
    case OP_BITNOT:
    case LEFTPAREN:
    case IDENTIFIER:
      n3 = ConstantExpression();
        n2.addNode(n3);
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    n5 = jj_consume_token(RIGHTBRACKET);
            n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new DimensionSize(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public ParameterTypeListClosed ParameterTypeListClosed() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   ParameterTypeList n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(LEFTPAREN);
            n0 = JTBToolkit.makeNodeToken(n1);
    if (jj_2_19(1)) {
      n3 = ParameterTypeList();
        n2.addNode(n3);
    } else {
      ;
    }
    n5 = jj_consume_token(RIGHTPAREN);
            n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new ParameterTypeListClosed(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public OldParameterListClosed OldParameterListClosed() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   OldParameterList n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(LEFTPAREN);
            n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      n3 = OldParameterList();
        n2.addNode(n3);
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    n5 = jj_consume_token(RIGHTPAREN);
            n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new OldParameterListClosed(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public IdentifierOrDeclarator IdentifierOrDeclarator() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeSequence n3;
   NodeToken n4;
   Token n5;
   Declarator n6;
   NodeToken n7;
   Token n8;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      n2 = jj_consume_token(IDENTIFIER);
                        n1 = JTBToolkit.makeNodeToken(n2);
         if ( !(typedefParsingStack.empty()) && ((Boolean)typedefParsingStack.peek()).booleanValue() )
         {
            addType(n2.image);
         }
        n0 = new NodeChoice(n1, 0);
      break;
    case LEFTPAREN:
        n3 = new NodeSequence(3);
      n5 = jj_consume_token(LEFTPAREN);
               n4 = JTBToolkit.makeNodeToken(n5);
        n3.addNode(n4);
      n6 = Declarator();
        n3.addNode(n6);
      n8 = jj_consume_token(RIGHTPAREN);
               n7 = JTBToolkit.makeNodeToken(n8);
        n3.addNode(n7);
        n0 = new NodeChoice(n3, 1);
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new IdentifierOrDeclarator(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Pointer Pointer() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeOptional n5 = new NodeOptional();
   TypeQualifierList n6;
   NodeOptional n7 = new NodeOptional();
   Pointer n8;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_MUL:
      n2 = jj_consume_token(OP_MUL);
                  n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
      break;
    case OP_BITXOR:
      n4 = jj_consume_token(OP_BITXOR);
                  n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RESTRICT:
    case VOLATILE:
    case CCONST:
    case CSIGNED:
    case CSIGNED2:
    case CONST:
      n6 = TypeQualifierList();
        n5.addNode(n6);
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_MUL:
    case OP_BITXOR:
      n8 = Pointer();
        n7.addNode(n8);
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
     {if (true) return new Pointer(n0,n5,n7);}
    throw new Error("Missing return statement in function");
  }

  final public TypeQualifierList TypeQualifierList() throws ParseException {
   NodeList n0 = new NodeList();
   TypeQualifier n1;
    label_10:
    while (true) {
      n1 = TypeQualifier();
        n0.addNode(n1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RESTRICT:
      case VOLATILE:
      case CCONST:
      case CSIGNED:
      case CSIGNED2:
      case CONST:
        ;
        break;
      default:
        jj_la1[34] = jj_gen;
        break label_10;
      }
    }
     n0.nodes.trimToSize();
     {if (true) return new TypeQualifierList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ParameterTypeList ParameterTypeList() throws ParseException {
   ParameterList n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
    n0 = ParameterList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n6 = jj_consume_token(ELLIPSIS);
                 n5 = JTBToolkit.makeNodeToken(n6);
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
     {if (true) return new ParameterTypeList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public ParameterList ParameterList() throws ParseException {
   ParameterDeclaration n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   ParameterDeclaration n5;
    n0 = ParameterDeclaration();
    label_11:
    while (true) {
      if (jj_2_20(2)) {
        ;
      } else {
        break label_11;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = ParameterDeclaration();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new ParameterList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public ParameterDeclaration ParameterDeclaration() throws ParseException {
   DeclarationSpecifiers n0;
   ParameterAbstraction n1;
    n0 = DeclarationSpecifiers();
    n1 = ParameterAbstraction();
     {if (true) return new ParameterDeclaration(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public ParameterAbstraction ParameterAbstraction() throws ParseException {
   NodeChoice n0;
   Declarator n1;
   AbstractOptionalDeclarator n2;
    if (jj_2_21(2147483647)) {
      n1 = Declarator();
        n0 = new NodeChoice(n1, 0);
    } else {
      n2 = AbstractOptionalDeclarator();
        n0 = new NodeChoice(n2, 1);
    }
     {if (true) return new ParameterAbstraction(n0);}
    throw new Error("Missing return statement in function");
  }

  final public AbstractOptionalDeclarator AbstractOptionalDeclarator() throws ParseException {
   NodeOptional n0 = new NodeOptional();
   AbstractDeclarator n1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_MUL:
    case OP_BITXOR:
    case LEFTPAREN:
    case LEFTBRACKET:
      n1 = AbstractDeclarator();
        n0.addNode(n1);
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
     {if (true) return new AbstractOptionalDeclarator(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OldParameterList OldParameterList() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeListOptional n2 = new NodeListOptional();
   NodeSequence n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[37] = jj_gen;
        break label_12;
      }
        n3 = new NodeSequence(2);
      n5 = jj_consume_token(COMMA);
               n4 = JTBToolkit.makeNodeToken(n5);
        n3.addNode(n4);
      n7 = jj_consume_token(IDENTIFIER);
                        n6 = JTBToolkit.makeNodeToken(n7);
        n3.addNode(n6);
        n2.addNode(n3);
    }
     n2.nodes.trimToSize();
     {if (true) return new OldParameterList(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public Initializer Initializer() throws ParseException {
   NodeChoice n0;
   AssignmentExpression n1;
   ArrayInitializer n2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case _GENERIC:
    case SIZEOF:
    case OP_INCR:
    case OP_DECR:
    case OP_ADD:
    case OP_SUB:
    case OP_MUL:
    case OP_BITAND:
    case OP_NOT:
    case OP_BITNOT:
    case LEFTPAREN:
    case IDENTIFIER:
      n1 = AssignmentExpression();
        n0 = new NodeChoice(n1, 0);
      break;
    case LEFTBRACE:
      n2 = ArrayInitializer();
        n0 = new NodeChoice(n2, 1);
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new Initializer(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ArrayInitializer ArrayInitializer() throws ParseException {
   NodeToken n0;
   Token n1;
   InitializerList n2;
   NodeOptional n3 = new NodeOptional();
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
    n1 = jj_consume_token(LEFTBRACE);
            n0 = JTBToolkit.makeNodeToken(n1);
    n2 = InitializerList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      n5 = jj_consume_token(COMMA);
               n4 = JTBToolkit.makeNodeToken(n5);
        n3.addNode(n4);
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    n7 = jj_consume_token(RIGHTBRACE);
            n6 = JTBToolkit.makeNodeToken(n7);
     {if (true) return new ArrayInitializer(n0,n2,n3,n6);}
    throw new Error("Missing return statement in function");
  }

  final public InitializerList InitializerList() throws ParseException {
   Initializer n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   Initializer n5;
    n0 = Initializer();
    label_13:
    while (true) {
      if (jj_2_22(2)) {
        ;
      } else {
        break label_13;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = Initializer();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new InitializerList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public TypeName TypeName() throws ParseException {
   SpecifierQualifierList n0;
   NodeOptional n1 = new NodeOptional();
   AbstractDeclarator n2;
    n0 = SpecifierQualifierList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_MUL:
    case OP_BITXOR:
    case LEFTPAREN:
    case LEFTBRACKET:
      n2 = AbstractDeclarator();
        n1.addNode(n2);
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
     {if (true) return new TypeName(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public AbstractDeclarator AbstractDeclarator() throws ParseException {
   NodeChoice n0;
   AbstractDeclaratorWithPointer n1;
   DirectAbstractDeclarator n2;
    if (jj_2_23(3)) {
      n1 = AbstractDeclaratorWithPointer();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTPAREN:
      case LEFTBRACKET:
        n2 = DirectAbstractDeclarator();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new AbstractDeclarator(n0);}
    throw new Error("Missing return statement in function");
  }

  final public AbstractDeclaratorWithPointer AbstractDeclaratorWithPointer() throws ParseException {
   Pointer n0;
   NodeOptional n1 = new NodeOptional();
   DirectAbstractDeclarator n2;
    n0 = Pointer();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFTPAREN:
    case LEFTBRACKET:
      n2 = DirectAbstractDeclarator();
        n1.addNode(n2);
      break;
    default:
      jj_la1[42] = jj_gen;
      ;
    }
     {if (true) return new AbstractDeclaratorWithPointer(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public DirectAbstractDeclarator DirectAbstractDeclarator() throws ParseException {
   AbstractDimensionOrParameter n0;
   DimensionOrParameterList n1;
    n0 = AbstractDimensionOrParameter();
    n1 = DimensionOrParameterList();
     {if (true) return new DirectAbstractDeclarator(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public AbstractDimensionOrParameter AbstractDimensionOrParameter() throws ParseException {
   NodeChoice n0;
   AbstractDeclaratorClosed n1;
   DimensionSize n2;
   ParameterTypeListClosed n3;
    if (jj_2_24(3)) {
      n1 = AbstractDeclaratorClosed();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTBRACKET:
        n2 = DimensionSize();
        n0 = new NodeChoice(n2, 1);
        break;
      case LEFTPAREN:
        n3 = ParameterTypeListClosed();
        n0 = new NodeChoice(n3, 2);
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new AbstractDimensionOrParameter(n0);}
    throw new Error("Missing return statement in function");
  }

  final public AbstractDeclaratorClosed AbstractDeclaratorClosed() throws ParseException {
   NodeToken n0;
   Token n1;
   AbstractDeclarator n2;
   NodeToken n3;
   Token n4;
    n1 = jj_consume_token(LEFTPAREN);
            n0 = JTBToolkit.makeNodeToken(n1);
    n2 = AbstractDeclarator();
    n4 = jj_consume_token(RIGHTPAREN);
            n3 = JTBToolkit.makeNodeToken(n4);
     {if (true) return new AbstractDeclaratorClosed(n0,n2,n3);}
    throw new Error("Missing return statement in function");
  }

  final public DimensionOrParameterList DimensionOrParameterList() throws ParseException {
   NodeListOptional n0 = new NodeListOptional();
   ADimensionOrParameter n1;
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTPAREN:
      case LEFTBRACKET:
        ;
        break;
      default:
        jj_la1[44] = jj_gen;
        break label_14;
      }
      n1 = ADimensionOrParameter();
        n0.addNode(n1);
    }
     n0.nodes.trimToSize();
     {if (true) return new DimensionOrParameterList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ADimensionOrParameter ADimensionOrParameter() throws ParseException {
   NodeChoice n0;
   DimensionSize n1;
   ParameterTypeListClosed n2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFTBRACKET:
      n1 = DimensionSize();
        n0 = new NodeChoice(n1, 0);
      break;
    case LEFTPAREN:
      n2 = ParameterTypeListClosed();
        n0 = new NodeChoice(n2, 1);
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new ADimensionOrParameter(n0);}
    throw new Error("Missing return statement in function");
  }

  final public TypedefName TypedefName() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new TypedefName(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Statement Statement() throws ParseException {
   NodeChoice n0;
   LabeledStatement n1;
   ExpressionStatement n2;
   CompoundStatement n3;
   SelectionStatement n4;
   IterationStatement n5;
   JumpStatement n6;
   UnknownPragma n7;
   OmpConstruct n8;
   OmpDirective n9;
   UnknownCpp n10;
    if (jj_2_25(2)) {
      n1 = LabeledStatement();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case _GENERIC:
      case SIZEOF:
      case OP_INCR:
      case OP_DECR:
      case OP_ADD:
      case OP_SUB:
      case OP_MUL:
      case OP_BITAND:
      case OP_NOT:
      case OP_BITNOT:
      case SEMICOLON:
      case LEFTPAREN:
      case IDENTIFIER:
        n2 = ExpressionStatement();
        n0 = new NodeChoice(n2, 1);
        break;
      case LEFTBRACE:
        n3 = CompoundStatement();
        n0 = new NodeChoice(n3, 2);
        break;
      case SWITCH:
      case IF:
        n4 = SelectionStatement();
        n0 = new NodeChoice(n4, 3);
        break;
      case WHILE:
      case FOR:
      case DO:
        n5 = IterationStatement();
        n0 = new NodeChoice(n5, 4);
        break;
      case CONTINUE:
      case RETURN:
      case BREAK:
      case GOTO:
        n6 = JumpStatement();
        n0 = new NodeChoice(n6, 5);
        break;
      default:
        jj_la1[46] = jj_gen;
        if (jj_2_26(4)) {
          n7 = UnknownPragma();
        n0 = new NodeChoice(n7, 6);
        } else if (jj_2_27(2147483647)) {
          n8 = OmpConstruct();
        n0 = new NodeChoice(n8, 7);
        } else if (jj_2_28(2)) {
          n9 = OmpDirective();
        n0 = new NodeChoice(n9, 8);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CROSSBAR:
            n10 = UnknownCpp();
        n0 = new NodeChoice(n10, 9);
            break;
          default:
            jj_la1[47] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
     {if (true) return new Statement(n0);}
    throw new Error("Missing return statement in function");
  }

  final public LabeledStatement LabeledStatement() throws ParseException {
   NodeChoice n0;
   SimpleLabeledStatement n1;
   CaseLabeledStatement n2;
   DefaultLabeledStatement n3;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      n1 = SimpleLabeledStatement();
        n0 = new NodeChoice(n1, 0);
      break;
    case CASE:
      n2 = CaseLabeledStatement();
        n0 = new NodeChoice(n2, 1);
      break;
    case DFLT:
      n3 = DefaultLabeledStatement();
        n0 = new NodeChoice(n3, 2);
      break;
    default:
      jj_la1[48] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new LabeledStatement(n0);}
    throw new Error("Missing return statement in function");
  }

  final public SimpleLabeledStatement SimpleLabeledStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Statement n4;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(COLON);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Statement();
     {if (true) return new SimpleLabeledStatement(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public CaseLabeledStatement CaseLabeledStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   ConstantExpression n2;
   NodeToken n3;
   Token n4;
   Statement n5;
    n1 = jj_consume_token(CASE);
               n0 = JTBToolkit.makeNodeToken(n1);
    n2 = ConstantExpression();
    n4 = jj_consume_token(COLON);
            n3 = JTBToolkit.makeNodeToken(n4);
    n5 = Statement();
     {if (true) return new CaseLabeledStatement(n0,n2,n3,n5);}
    throw new Error("Missing return statement in function");
  }

  final public DefaultLabeledStatement DefaultLabeledStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Statement n4;
    n1 = jj_consume_token(DFLT);
               n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(COLON);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Statement();
     {if (true) return new DefaultLabeledStatement(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionStatement ExpressionStatement() throws ParseException {
   NodeOptional n0 = new NodeOptional();
   Expression n1;
   NodeToken n2;
   Token n3;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case _GENERIC:
    case SIZEOF:
    case OP_INCR:
    case OP_DECR:
    case OP_ADD:
    case OP_SUB:
    case OP_MUL:
    case OP_BITAND:
    case OP_NOT:
    case OP_BITNOT:
    case LEFTPAREN:
    case IDENTIFIER:
      n1 = Expression();
        n0.addNode(n1);
      break;
    default:
      jj_la1[49] = jj_gen;
      ;
    }
    n3 = jj_consume_token(SEMICOLON);
            n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new ExpressionStatement(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public CompoundStatement CompoundStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeListOptional n2 = new NodeListOptional();
   CompoundStatementElement n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(LEFTBRACE);
            n0 = JTBToolkit.makeNodeToken(n1);
    label_15:
    while (true) {
      if (jj_2_29(1)) {
        ;
      } else {
        break label_15;
      }
      n3 = CompoundStatementElement();
        n2.addNode(n3);
    }
     n2.nodes.trimToSize();
    n5 = jj_consume_token(RIGHTBRACE);
            n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new CompoundStatement(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public CompoundStatementElement CompoundStatementElement() throws ParseException {
   NodeChoice n0;
   Declaration n1;
   Statement n2;
    if (jj_2_30(2147483647)) {
      n1 = Declaration();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case _GENERIC:
      case CONTINUE:
      case DFLT:
      case SWITCH:
      case RETURN:
      case WHILE:
      case BREAK:
      case CASE:
      case GOTO:
      case FOR:
      case IF:
      case DO:
      case SIZEOF:
      case OP_INCR:
      case OP_DECR:
      case OP_ADD:
      case OP_SUB:
      case OP_MUL:
      case OP_BITAND:
      case OP_NOT:
      case OP_BITNOT:
      case SEMICOLON:
      case LEFTPAREN:
      case LEFTBRACE:
      case CROSSBAR:
      case IDENTIFIER:
        n2 = Statement();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new CompoundStatementElement(n0);}
    throw new Error("Missing return statement in function");
  }

  final public SelectionStatement SelectionStatement() throws ParseException {
   NodeChoice n0;
   IfStatement n1;
   SwitchStatement n2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      n1 = IfStatement();
        n0 = new NodeChoice(n1, 0);
      break;
    case SWITCH:
      n2 = SwitchStatement();
        n0 = new NodeChoice(n2, 1);
      break;
    default:
      jj_la1[51] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new SelectionStatement(n0);}
    throw new Error("Missing return statement in function");
  }

  final public IfStatement IfStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   Statement n7;
   NodeOptional n8 = new NodeOptional();
   NodeSequence n9;
   NodeToken n10;
   Token n11;
   Statement n12;
    n1 = jj_consume_token(IF);
             n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Statement();
    if (jj_2_31(2)) {
        n9 = new NodeSequence(2);
      n11 = jj_consume_token(ELSE);
                   n10 = JTBToolkit.makeNodeToken(n11);
        n9.addNode(n10);
      n12 = Statement();
        n9.addNode(n12);
        n8.addNode(n9);
    } else {
      ;
    }
     {if (true) return new IfStatement(n0,n2,n4,n5,n7,n8);}
    throw new Error("Missing return statement in function");
  }

  final public SwitchStatement SwitchStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   Statement n7;
    n1 = jj_consume_token(SWITCH);
                 n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Statement();
     {if (true) return new SwitchStatement(n0,n2,n4,n5,n7);}
    throw new Error("Missing return statement in function");
  }

  final public IterationStatement IterationStatement() throws ParseException {
   NodeChoice n0;
   WhileStatement n1;
   DoStatement n2;
   ForStatement n3;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHILE:
      n1 = WhileStatement();
        n0 = new NodeChoice(n1, 0);
      break;
    case DO:
      n2 = DoStatement();
        n0 = new NodeChoice(n2, 1);
      break;
    case FOR:
      n3 = ForStatement();
        n0 = new NodeChoice(n3, 2);
      break;
    default:
      jj_la1[52] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new IterationStatement(n0);}
    throw new Error("Missing return statement in function");
  }

  final public WhileStatement WhileStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   Statement n7;
    n1 = jj_consume_token(WHILE);
                n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Statement();
     {if (true) return new WhileStatement(n0,n2,n4,n5,n7);}
    throw new Error("Missing return statement in function");
  }

  final public DoStatement DoStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   Statement n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   Expression n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
    n1 = jj_consume_token(DO);
             n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Statement();
    n4 = jj_consume_token(WHILE);
                n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(LEFTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Expression();
    n9 = jj_consume_token(RIGHTPAREN);
            n8 = JTBToolkit.makeNodeToken(n9);
    n11 = jj_consume_token(SEMICOLON);
             n10 = JTBToolkit.makeNodeToken(n11);
     {if (true) return new DoStatement(n0,n2,n3,n5,n7,n8,n10);}
    throw new Error("Missing return statement in function");
  }

  final public ForStatement ForStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeOptional n4 = new NodeOptional();
   Expression n5;
   NodeToken n6;
   Token n7;
   NodeOptional n8 = new NodeOptional();
   Expression n9;
   NodeToken n10;
   Token n11;
   NodeOptional n12 = new NodeOptional();
   Expression n13;
   NodeToken n14;
   Token n15;
   Statement n16;
    n1 = jj_consume_token(FOR);
              n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case _GENERIC:
    case SIZEOF:
    case OP_INCR:
    case OP_DECR:
    case OP_ADD:
    case OP_SUB:
    case OP_MUL:
    case OP_BITAND:
    case OP_NOT:
    case OP_BITNOT:
    case LEFTPAREN:
    case IDENTIFIER:
      n5 = Expression();
        n4.addNode(n5);
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
    n7 = jj_consume_token(SEMICOLON);
            n6 = JTBToolkit.makeNodeToken(n7);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case _GENERIC:
    case SIZEOF:
    case OP_INCR:
    case OP_DECR:
    case OP_ADD:
    case OP_SUB:
    case OP_MUL:
    case OP_BITAND:
    case OP_NOT:
    case OP_BITNOT:
    case LEFTPAREN:
    case IDENTIFIER:
      n9 = Expression();
        n8.addNode(n9);
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
    n11 = jj_consume_token(SEMICOLON);
             n10 = JTBToolkit.makeNodeToken(n11);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case _GENERIC:
    case SIZEOF:
    case OP_INCR:
    case OP_DECR:
    case OP_ADD:
    case OP_SUB:
    case OP_MUL:
    case OP_BITAND:
    case OP_NOT:
    case OP_BITNOT:
    case LEFTPAREN:
    case IDENTIFIER:
      n13 = Expression();
        n12.addNode(n13);
      break;
    default:
      jj_la1[55] = jj_gen;
      ;
    }
    n15 = jj_consume_token(RIGHTPAREN);
             n14 = JTBToolkit.makeNodeToken(n15);
    n16 = Statement();
     {if (true) return new ForStatement(n0,n2,n4,n6,n8,n10,n12,n14,n16);}
    throw new Error("Missing return statement in function");
  }

  final public JumpStatement JumpStatement() throws ParseException {
   NodeChoice n0;
   GotoStatement n1;
   ContinueStatement n2;
   BreakStatement n3;
   ReturnStatement n4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GOTO:
      n1 = GotoStatement();
        n0 = new NodeChoice(n1, 0);
      break;
    case CONTINUE:
      n2 = ContinueStatement();
        n0 = new NodeChoice(n2, 1);
      break;
    case BREAK:
      n3 = BreakStatement();
        n0 = new NodeChoice(n3, 2);
      break;
    case RETURN:
      n4 = ReturnStatement();
        n0 = new NodeChoice(n4, 3);
      break;
    default:
      jj_la1[56] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new JumpStatement(n0);}
    throw new Error("Missing return statement in function");
  }

  final public GotoStatement GotoStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(GOTO);
               n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(IDENTIFIER);
                     n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(SEMICOLON);
            n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new GotoStatement(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public ContinueStatement ContinueStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
    n1 = jj_consume_token(CONTINUE);
                   n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(SEMICOLON);
            n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new ContinueStatement(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public BreakStatement BreakStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
    n1 = jj_consume_token(BREAK);
                n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(SEMICOLON);
            n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new BreakStatement(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public ReturnStatement ReturnStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   Expression n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(RETURN);
                 n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case _GENERIC:
    case SIZEOF:
    case OP_INCR:
    case OP_DECR:
    case OP_ADD:
    case OP_SUB:
    case OP_MUL:
    case OP_BITAND:
    case OP_NOT:
    case OP_BITNOT:
    case LEFTPAREN:
    case IDENTIFIER:
      n3 = Expression();
        n2.addNode(n3);
      break;
    default:
      jj_la1[57] = jj_gen;
      ;
    }
    n5 = jj_consume_token(SEMICOLON);
            n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new ReturnStatement(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public UnknownCpp UnknownCpp() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
    n1 = jj_consume_token(CROSSBAR);
            n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(UNKNOWN_CPP);
                      n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new UnknownCpp(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public OmpEol OmpEol() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OMP_CR:
      n2 = jj_consume_token(OMP_CR);
                    n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case OMP_NL:
      n4 = jj_consume_token(OMP_NL);
                    n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OmpEol(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpConstruct OmpConstruct() throws ParseException {
   NodeChoice n0;
   OmpParallelConstruct n1;
   OmpForConstruct n2;
   OmpSectionsConstruct n3;
   OmpSingleConstruct n4;
   OmpSimdConstruct n5;
   OmpForSimdConstruct n6;
   OmpTaskConstruct n7;
   OmpTaskLoopSimdConstruct n8;
   OmpTaskLoopConstruct n9;
   OmpTargetDataConstruct n10;
   OmpTargetParallelForSimdConstruct n11;
   OmpTargetParallelForConstruct n12;
   OmpTargetParallelConstruct n13;
   OmpTargetSimdConstruct n14;
   OmpTargetTeamsDistributeParallelForSimdConstruct n15;
   OmpTargetTeamsDistributeParallelForConstruct n16;
   OmpTargetTeamsDistributeSimdConstruct n17;
   OmpTargetTeamsDistributeConstruct n18;
   OmpTargetTeamsConstruct n19;
   OmpTargetConstruct n20;
   OmpTeamsDistributeParallelForSimdConstruct n21;
   OmpTeamsDistributeParallelForConstruct n22;
   OmpTeamsDistributeSimdConstruct n23;
   OmpTeamsDistributeConstruct n24;
   OmpTeamsConstruct n25;
   OmpDistributeSimdConstruct n26;
   OmpDistributeParallelForSimdConstruct n27;
   OmpDistributeParallelForConstruct n28;
   OmpDistributeConstruct n29;
   OmpParallelForSimdConstruct n30;
   OmpParallelForConstruct n31;
   OmpParallelSectionsConstruct n32;
   OmpMasterConstruct n33;
   OmpCriticalConstruct n34;
   OmpTaskGroupConstruct n35;
   OmpAtomicConstruct n36;
   OmpOrderedConstruct n37;
    if (jj_2_32(6)) {
      n1 = OmpParallelConstruct();
        n0 = new NodeChoice(n1, 0);
    } else if (jj_2_33(4)) {
      n2 = OmpForConstruct();
        n0 = new NodeChoice(n2, 1);
    } else if (jj_2_34(4)) {
      n3 = OmpSectionsConstruct();
        n0 = new NodeChoice(n3, 2);
    } else if (jj_2_35(4)) {
      n4 = OmpSingleConstruct();
        n0 = new NodeChoice(n4, 3);
    } else if (jj_2_36(4)) {
      n5 = OmpSimdConstruct();
        n0 = new NodeChoice(n5, 4);
    } else if (jj_2_37(5)) {
      n6 = OmpForSimdConstruct();
        n0 = new NodeChoice(n6, 5);
    } else if (jj_2_38(4)) {
      n7 = OmpTaskConstruct();
        n0 = new NodeChoice(n7, 6);
    } else if (jj_2_39(5)) {
      n8 = OmpTaskLoopSimdConstruct();
        n0 = new NodeChoice(n8, 7);
    } else if (jj_2_40(4)) {
      n9 = OmpTaskLoopConstruct();
        n0 = new NodeChoice(n9, 8);
    } else if (jj_2_41(5)) {
      n10 = OmpTargetDataConstruct();
        n0 = new NodeChoice(n10, 9);
    } else if (jj_2_42(7)) {
      n11 = OmpTargetParallelForSimdConstruct();
        n0 = new NodeChoice(n11, 10);
    } else if (jj_2_43(6)) {
      n12 = OmpTargetParallelForConstruct();
        n0 = new NodeChoice(n12, 11);
    } else if (jj_2_44(5)) {
      n13 = OmpTargetParallelConstruct();
        n0 = new NodeChoice(n13, 12);
    } else if (jj_2_45(5)) {
      n14 = OmpTargetSimdConstruct();
        n0 = new NodeChoice(n14, 13);
    } else if (jj_2_46(9)) {
      n15 = OmpTargetTeamsDistributeParallelForSimdConstruct();
        n0 = new NodeChoice(n15, 14);
    } else if (jj_2_47(8)) {
      n16 = OmpTargetTeamsDistributeParallelForConstruct();
        n0 = new NodeChoice(n16, 15);
    } else if (jj_2_48(7)) {
      n17 = OmpTargetTeamsDistributeSimdConstruct();
        n0 = new NodeChoice(n17, 16);
    } else if (jj_2_49(6)) {
      n18 = OmpTargetTeamsDistributeConstruct();
        n0 = new NodeChoice(n18, 17);
    } else if (jj_2_50(5)) {
      n19 = OmpTargetTeamsConstruct();
        n0 = new NodeChoice(n19, 18);
    } else if (jj_2_51(4)) {
      n20 = OmpTargetConstruct();
        n0 = new NodeChoice(n20, 19);
    } else if (jj_2_52(8)) {
      n21 = OmpTeamsDistributeParallelForSimdConstruct();
        n0 = new NodeChoice(n21, 20);
    } else if (jj_2_53(7)) {
      n22 = OmpTeamsDistributeParallelForConstruct();
        n0 = new NodeChoice(n22, 21);
    } else if (jj_2_54(6)) {
      n23 = OmpTeamsDistributeSimdConstruct();
        n0 = new NodeChoice(n23, 22);
    } else if (jj_2_55(5)) {
      n24 = OmpTeamsDistributeConstruct();
        n0 = new NodeChoice(n24, 23);
    } else if (jj_2_56(4)) {
      n25 = OmpTeamsConstruct();
        n0 = new NodeChoice(n25, 24);
    } else if (jj_2_57(5)) {
      n26 = OmpDistributeSimdConstruct();
        n0 = new NodeChoice(n26, 25);
    } else if (jj_2_58(7)) {
      n27 = OmpDistributeParallelForSimdConstruct();
        n0 = new NodeChoice(n27, 26);
    } else if (jj_2_59(5)) {
      n28 = OmpDistributeParallelForConstruct();
        n0 = new NodeChoice(n28, 27);
    } else if (jj_2_60(4)) {
      n29 = OmpDistributeConstruct();
        n0 = new NodeChoice(n29, 28);
    } else if (jj_2_61(6)) {
      n30 = OmpParallelForSimdConstruct();
        n0 = new NodeChoice(n30, 29);
    } else if (jj_2_62(6)) {
      n31 = OmpParallelForConstruct();
        n0 = new NodeChoice(n31, 30);
    } else if (jj_2_63(6)) {
      n32 = OmpParallelSectionsConstruct();
        n0 = new NodeChoice(n32, 31);
    } else if (jj_2_64(4)) {
      n33 = OmpMasterConstruct();
        n0 = new NodeChoice(n33, 32);
    } else if (jj_2_65(4)) {
      n34 = OmpCriticalConstruct();
        n0 = new NodeChoice(n34, 33);
    } else if (jj_2_66(4)) {
      n35 = OmpTaskGroupConstruct();
        n0 = new NodeChoice(n35, 34);
    } else if (jj_2_67(4)) {
      n36 = OmpAtomicConstruct();
        n0 = new NodeChoice(n36, 35);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CROSSBAR:
        n37 = OmpOrderedConstruct();
        n0 = new NodeChoice(n37, 36);
        break;
      default:
        jj_la1[59] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpConstruct(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDirective OmpDirective() throws ParseException {
   NodeChoice n0;
   OmpTaskyieldDirective n1;
   OmpTargetEnterDataDirective n2;
   OmpTargetExitDataDirective n3;
   OmpTargetUpdateDirective n4;
   OmpBarrierDirective n5;
   OmpTaskwaitDirective n6;
   OmpFlushDirective n7;
   OmpCancelDirective n8;
   OmpCancellationPointDirective n9;
    if (jj_2_68(4)) {
      n1 = OmpTaskyieldDirective();
        n0 = new NodeChoice(n1, 0);
    } else if (jj_2_69(6)) {
      n2 = OmpTargetEnterDataDirective();
        n0 = new NodeChoice(n2, 1);
    } else if (jj_2_70(6)) {
      n3 = OmpTargetExitDataDirective();
        n0 = new NodeChoice(n3, 2);
    } else if (jj_2_71(5)) {
      n4 = OmpTargetUpdateDirective();
        n0 = new NodeChoice(n4, 3);
    } else if (jj_2_72(4)) {
      n5 = OmpBarrierDirective();
        n0 = new NodeChoice(n5, 4);
    } else if (jj_2_73(4)) {
      n6 = OmpTaskwaitDirective();
        n0 = new NodeChoice(n6, 5);
    } else if (jj_2_74(4)) {
      n7 = OmpFlushDirective();
        n0 = new NodeChoice(n7, 6);
    } else if (jj_2_75(4)) {
      n8 = OmpCancelDirective();
        n0 = new NodeChoice(n8, 7);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CROSSBAR:
        n9 = OmpCancellationPointDirective();
        n0 = new NodeChoice(n9, 8);
        break;
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpDirective(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpPragma OmpPragma() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(CROSSBAR);
            n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PRAGMA);
                 n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(OMP);
              n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new OmpPragma(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public UnknownPragma UnknownPragma() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(CROSSBAR);
            n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PRAGMA);
                 n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(UNKNOWN_CPP);
                      n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new UnknownPragma(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public OmpParallelConstruct OmpParallelConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeOptional n3 = new NodeOptional();
   OmpParallelClauseList n4;
   OmpEol n5;
   Statement n6;
    n0 = OmpPragma();
    n2 = jj_consume_token(PARALLEL);
                   n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case SHARED:
    case COPYIN:
    case NUM_THREADS:
    case PROC_BIND:
      n4 = OmpParallelClauseList();
        n3.addNode(n4);
      break;
    default:
      jj_la1[61] = jj_gen;
      ;
    }
    n5 = OmpEol();
    n6 = Statement();
     {if (true) return new OmpParallelConstruct(n0,n1,n3,n5,n6);}
    throw new Error("Missing return statement in function");
  }

  final public OmpParallelClauseList OmpParallelClauseList() throws ParseException {
   OmpParallelClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpParallelClause n6;
    n0 = OmpParallelClause();
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case SHARED:
      case COPYIN:
      case NUM_THREADS:
      case PROC_BIND:
        ;
        break;
      default:
        jj_la1[62] = jj_gen;
        break label_16;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpParallelClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpParallelClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpParallelClause OmpParallelClause() throws ParseException {
   NodeChoice n0;
   OmpIfParallelClause n1;
   OmpNumThreadsClause n2;
   OmpDfltSharedClause n3;
   OmpDfltNoneClause n4;
   OmpPrivateClause n5;
   OmpFirstPrivateClause n6;
   OmpSharedClause n7;
   OmpCopyinClause n8;
   OmpReductionClause n9;
   OmpThreadAffinityMasterClause n10;
   OmpThreadAffinityCloseClause n11;
   OmpThreadAffinitySpreadClause n12;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      n1 = OmpIfParallelClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case NUM_THREADS:
      n2 = OmpNumThreadsClause();
        n0 = new NodeChoice(n2, 1);
      break;
    default:
      jj_la1[64] = jj_gen;
      if (jj_2_76(3)) {
        n3 = OmpDfltSharedClause();
        n0 = new NodeChoice(n3, 2);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DFLT:
          n4 = OmpDfltNoneClause();
        n0 = new NodeChoice(n4, 3);
          break;
        case PRIVATE:
          n5 = OmpPrivateClause();
        n0 = new NodeChoice(n5, 4);
          break;
        case FIRSTPRIVATE:
          n6 = OmpFirstPrivateClause();
        n0 = new NodeChoice(n6, 5);
          break;
        case SHARED:
          n7 = OmpSharedClause();
        n0 = new NodeChoice(n7, 6);
          break;
        case COPYIN:
          n8 = OmpCopyinClause();
        n0 = new NodeChoice(n8, 7);
          break;
        case REDUCTION:
          n9 = OmpReductionClause();
        n0 = new NodeChoice(n9, 8);
          break;
        default:
          jj_la1[65] = jj_gen;
          if (jj_2_77(3)) {
            n10 = OmpThreadAffinityMasterClause();
        n0 = new NodeChoice(n10, 9);
          } else if (jj_2_78(3)) {
            n11 = OmpThreadAffinityCloseClause();
        n0 = new NodeChoice(n11, 10);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case PROC_BIND:
              n12 = OmpThreadAffinitySpreadClause();
        n0 = new NodeChoice(n12, 11);
              break;
            default:
              jj_la1[66] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
    }
     {if (true) return new OmpParallelClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpIfParallelClause OmpIfParallelClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeOptional n4 = new NodeOptional();
   NodeSequence n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   Expression n10;
   NodeToken n11;
   Token n12;
    n1 = jj_consume_token(IF);
             n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARALLEL:
        n5 = new NodeSequence(2);
      n7 = jj_consume_token(PARALLEL);
                      n6 = JTBToolkit.makeNodeToken(n7);
        n5.addNode(n6);
      n9 = jj_consume_token(COLON);
                   n8 = JTBToolkit.makeNodeToken(n9);
        n5.addNode(n8);
        n4.addNode(n5);
      break;
    default:
      jj_la1[67] = jj_gen;
      ;
    }
    n10 = Expression();
    n12 = jj_consume_token(RIGHTPAREN);
             n11 = JTBToolkit.makeNodeToken(n12);
     {if (true) return new OmpIfParallelClause(n0,n2,n4,n10,n11);}
    throw new Error("Missing return statement in function");
  }

  final public OmpNumThreadsClause OmpNumThreadsClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(NUM_THREADS);
                      n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpNumThreadsClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDfltSharedClause OmpDfltSharedClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
    n1 = jj_consume_token(DFLT);
               n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(SHARED);
                 n4 = JTBToolkit.makeNodeToken(n5);
    n7 = jj_consume_token(RIGHTPAREN);
            n6 = JTBToolkit.makeNodeToken(n7);
     {if (true) return new OmpDfltSharedClause(n0,n2,n4,n6);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDfltNoneClause OmpDfltNoneClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
    n1 = jj_consume_token(DFLT);
               n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(NONE);
               n4 = JTBToolkit.makeNodeToken(n5);
    n7 = jj_consume_token(RIGHTPAREN);
            n6 = JTBToolkit.makeNodeToken(n7);
     {if (true) return new OmpDfltNoneClause(n0,n2,n4,n6);}
    throw new Error("Missing return statement in function");
  }

  final public OmpPrivateClause OmpPrivateClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   VariableList n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(PRIVATE);
                  n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = VariableList();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpPrivateClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpFirstPrivateClause OmpFirstPrivateClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   VariableList n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(FIRSTPRIVATE);
                       n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = VariableList();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpFirstPrivateClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpSharedClause OmpSharedClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   VariableList n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(SHARED);
                 n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = VariableList();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpSharedClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpCopyinClause OmpCopyinClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   VariableList n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(COPYIN);
                 n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = VariableList();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpCopyinClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpReductionClause OmpReductionClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   ReductionOp n4;
   NodeToken n5;
   Token n6;
   VariableList n7;
   NodeToken n8;
   Token n9;
    n1 = jj_consume_token(REDUCTION);
                    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = ReductionOp();
    n6 = jj_consume_token(COLON);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = VariableList();
    n9 = jj_consume_token(RIGHTPAREN);
            n8 = JTBToolkit.makeNodeToken(n9);
     {if (true) return new OmpReductionClause(n0,n2,n4,n5,n7,n8);}
    throw new Error("Missing return statement in function");
  }

  final public OmpThreadAffinityMasterClause OmpThreadAffinityMasterClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
    n1 = jj_consume_token(PROC_BIND);
                    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(MASTER);
                 n4 = JTBToolkit.makeNodeToken(n5);
    n7 = jj_consume_token(RIGHTPAREN);
            n6 = JTBToolkit.makeNodeToken(n7);
     {if (true) return new OmpThreadAffinityMasterClause(n0,n2,n4,n6);}
    throw new Error("Missing return statement in function");
  }

  final public OmpThreadAffinityCloseClause OmpThreadAffinityCloseClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
    n1 = jj_consume_token(PROC_BIND);
                    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(CLOSE);
                n4 = JTBToolkit.makeNodeToken(n5);
    n7 = jj_consume_token(RIGHTPAREN);
            n6 = JTBToolkit.makeNodeToken(n7);
     {if (true) return new OmpThreadAffinityCloseClause(n0,n2,n4,n6);}
    throw new Error("Missing return statement in function");
  }

  final public OmpThreadAffinitySpreadClause OmpThreadAffinitySpreadClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
    n1 = jj_consume_token(PROC_BIND);
                    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(SPREAD);
                 n4 = JTBToolkit.makeNodeToken(n5);
    n7 = jj_consume_token(RIGHTPAREN);
            n6 = JTBToolkit.makeNodeToken(n7);
     {if (true) return new OmpThreadAffinitySpreadClause(n0,n2,n4,n6);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForConstruct OmpForConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeOptional n3 = new NodeOptional();
   OmpForClauseList n4;
   OmpEol n5;
   OmpForHeader n6;
   Statement n7;
    n0 = OmpPragma();
    n2 = jj_consume_token(FOR);
              n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ORDERED:
    case NOWAIT:
    case SCHEDULE:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case COLLAPSE:
    case LINEAR:
      n4 = OmpForClauseList();
        n3.addNode(n4);
      break;
    default:
      jj_la1[68] = jj_gen;
      ;
    }
    n5 = OmpEol();
    n6 = OmpForHeader();
    n7 = Statement();
     {if (true) return new OmpForConstruct(n0,n1,n3,n5,n6,n7);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForClauseList OmpForClauseList() throws ParseException {
   OmpForClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpForClause n6;
    n0 = OmpForClause();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
      case ORDERED:
      case NOWAIT:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case COLLAPSE:
      case LINEAR:
        ;
        break;
      default:
        jj_la1[69] = jj_gen;
        break label_17;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[70] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpForClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpForClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForClause OmpForClause() throws ParseException {
   NodeChoice n0;
   OmpPrivateClause n1;
   OmpFirstPrivateClause n2;
   OmpLastPrivateClause n3;
   OmpLinearClause n4;
   OmpReductionClause n5;
   OmpScheduleClause n6;
   OmpCollapseClause n7;
   OmpOrderedClause n8;
   OmpNowaitClause n9;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIVATE:
      n1 = OmpPrivateClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case FIRSTPRIVATE:
      n2 = OmpFirstPrivateClause();
        n0 = new NodeChoice(n2, 1);
      break;
    case LASTPRIVATE:
      n3 = OmpLastPrivateClause();
        n0 = new NodeChoice(n3, 2);
      break;
    case LINEAR:
      n4 = OmpLinearClause();
        n0 = new NodeChoice(n4, 3);
      break;
    case REDUCTION:
      n5 = OmpReductionClause();
        n0 = new NodeChoice(n5, 4);
      break;
    case SCHEDULE:
      n6 = OmpScheduleClause();
        n0 = new NodeChoice(n6, 5);
      break;
    case COLLAPSE:
      n7 = OmpCollapseClause();
        n0 = new NodeChoice(n7, 6);
      break;
    case ORDERED:
      n8 = OmpOrderedClause();
        n0 = new NodeChoice(n8, 7);
      break;
    case NOWAIT:
      n9 = OmpNowaitClause();
        n0 = new NodeChoice(n9, 8);
      break;
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OmpForClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpLastPrivateClause OmpLastPrivateClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   VariableList n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(LASTPRIVATE);
                      n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = VariableList();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpLastPrivateClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpLinearClause OmpLinearClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   VariableList n4;
   NodeOptional n5 = new NodeOptional();
   NodeSequence n6;
   NodeToken n7;
   Token n8;
   Expression n9;
   NodeToken n10;
   Token n11;
    n1 = jj_consume_token(LINEAR);
                 n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = VariableList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
        n6 = new NodeSequence(2);
      n8 = jj_consume_token(COLON);
                   n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
      n9 = Expression();
        n6.addNode(n9);
        n5.addNode(n6);
      break;
    default:
      jj_la1[72] = jj_gen;
      ;
    }
    n11 = jj_consume_token(RIGHTPAREN);
             n10 = JTBToolkit.makeNodeToken(n11);
     {if (true) return new OmpLinearClause(n0,n2,n4,n5,n10);}
    throw new Error("Missing return statement in function");
  }

  final public OmpScheduleClause OmpScheduleClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeOptional n4 = new NodeOptional();
   NodeSequence n5;
   Modifier n6;
   NodeOptional n7;
   NodeSequence n8;
   NodeToken n9;
   Token n10;
   Modifier n11;
   NodeToken n12;
   Token n13;
   ScheduleKind n14;
   NodeOptional n15 = new NodeOptional();
   NodeSequence n16;
   NodeToken n17;
   Token n18;
   Expression n19;
   NodeToken n20;
   Token n21;
    n1 = jj_consume_token(SCHEDULE);
                   n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MONOTONIC:
    case NONMONOTONIC:
    case SIMD:
        n7 = new NodeOptional();
        n5 = new NodeSequence(3);
      n6 = Modifier();
        n5.addNode(n6);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
           n8 = new NodeSequence(2);
        n10 = jj_consume_token(COMMA);
                   n9 = JTBToolkit.makeNodeToken(n10);
           n8.addNode(n9);
        n11 = Modifier();
           n8.addNode(n11);
           n7.addNode(n8);
        break;
      default:
        jj_la1[73] = jj_gen;
        ;
      }
        n5.addNode(n7);
      n13 = jj_consume_token(COLON);
                    n12 = JTBToolkit.makeNodeToken(n13);
        n5.addNode(n12);
        n4.addNode(n5);
      break;
    default:
      jj_la1[74] = jj_gen;
      ;
    }
    n14 = ScheduleKind();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
        n16 = new NodeSequence(2);
      n18 = jj_consume_token(COMMA);
                n17 = JTBToolkit.makeNodeToken(n18);
        n16.addNode(n17);
      n19 = Expression();
        n16.addNode(n19);
        n15.addNode(n16);
      break;
    default:
      jj_la1[75] = jj_gen;
      ;
    }
    n21 = jj_consume_token(RIGHTPAREN);
             n20 = JTBToolkit.makeNodeToken(n21);
     {if (true) return new OmpScheduleClause(n0,n2,n4,n14,n15,n20);}
    throw new Error("Missing return statement in function");
  }

  final public Modifier Modifier() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MONOTONIC:
      n2 = jj_consume_token(MONOTONIC);
                       n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case NONMONOTONIC:
      n4 = jj_consume_token(NONMONOTONIC);
                          n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case SIMD:
      n6 = jj_consume_token(SIMD);
                  n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    default:
      jj_la1[76] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new Modifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ScheduleKind ScheduleKind() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATIC:
      n2 = jj_consume_token(STATIC);
                    n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case DYNAMIC:
      n4 = jj_consume_token(DYNAMIC);
                     n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case GUIDED:
      n6 = jj_consume_token(GUIDED);
                    n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case RUNTIME:
      n8 = jj_consume_token(RUNTIME);
                     n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
      break;
    case AUTO:
      n10 = jj_consume_token(AUTO);
                   n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4);
      break;
    default:
      jj_la1[77] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new ScheduleKind(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpCollapseClause OmpCollapseClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(COLLAPSE);
                   n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpCollapseClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpOrderedClause OmpOrderedClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   NodeSequence n3;
   NodeToken n4;
   Token n5;
   Expression n6;
   NodeToken n7;
   Token n8;
    n1 = jj_consume_token(ORDERED);
                  n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFTPAREN:
        n3 = new NodeSequence(3);
      n5 = jj_consume_token(LEFTPAREN);
               n4 = JTBToolkit.makeNodeToken(n5);
        n3.addNode(n4);
      n6 = Expression();
        n3.addNode(n6);
      n8 = jj_consume_token(RIGHTPAREN);
               n7 = JTBToolkit.makeNodeToken(n8);
        n3.addNode(n7);
        n2.addNode(n3);
      break;
    default:
      jj_la1[78] = jj_gen;
      ;
    }
     {if (true) return new OmpOrderedClause(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public OmpNowaitClause OmpNowaitClause() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(NOWAIT);
                 n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new OmpNowaitClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForHeader OmpForHeader() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   OmpForInitExpression n4;
   NodeToken n5;
   Token n6;
   OmpForCondition n7;
   NodeToken n8;
   Token n9;
   OmpForReinitExpression n10;
   NodeToken n11;
   Token n12;
    n1 = jj_consume_token(FOR);
              n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = OmpForInitExpression();
    n6 = jj_consume_token(SEMICOLON);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = OmpForCondition();
    n9 = jj_consume_token(SEMICOLON);
            n8 = JTBToolkit.makeNodeToken(n9);
    n10 = OmpForReinitExpression();
    n12 = jj_consume_token(RIGHTPAREN);
             n11 = JTBToolkit.makeNodeToken(n12);
     {if (true) return new OmpForHeader(n0,n2,n4,n5,n7,n8,n10,n11);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForInitExpression OmpForInitExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(OP_ASS);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
     {if (true) return new OmpForInitExpression(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForCondition OmpForCondition() throws ParseException {
   NodeChoice n0;
   OmpForLTCondition n1;
   OmpForLECondition n2;
   OmpForGTCondition n3;
   OmpForGECondition n4;
    if (jj_2_79(2)) {
      n1 = OmpForLTCondition();
        n0 = new NodeChoice(n1, 0);
    } else if (jj_2_80(2)) {
      n2 = OmpForLECondition();
        n0 = new NodeChoice(n2, 1);
    } else if (jj_2_81(2)) {
      n3 = OmpForGTCondition();
        n0 = new NodeChoice(n3, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        n4 = OmpForGECondition();
        n0 = new NodeChoice(n4, 3);
        break;
      default:
        jj_la1[79] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpForCondition(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForLTCondition OmpForLTCondition() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(OP_LT);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
     {if (true) return new OmpForLTCondition(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForLECondition OmpForLECondition() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(OP_LE);
             n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
     {if (true) return new OmpForLECondition(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForGTCondition OmpForGTCondition() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(OP_GT);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
     {if (true) return new OmpForGTCondition(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForGECondition OmpForGECondition() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(OP_GE);
             n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
     {if (true) return new OmpForGECondition(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForReinitExpression OmpForReinitExpression() throws ParseException {
   NodeChoice n0;
   PostIncrementId n1;
   PostDecrementId n2;
   PreIncrementId n3;
   PreDecrementId n4;
   ShortAssignPlus n5;
   ShortAssignMinus n6;
   OmpForAdditive n7;
   OmpForSubtractive n8;
   OmpForMultiplicative n9;
    if (jj_2_82(2147483647)) {
      n1 = PostIncrementId();
        n0 = new NodeChoice(n1, 0);
    } else if (jj_2_83(2147483647)) {
      n2 = PostDecrementId();
        n0 = new NodeChoice(n2, 1);
    } else if (jj_2_84(2147483647)) {
      n3 = PreIncrementId();
        n0 = new NodeChoice(n3, 2);
    } else if (jj_2_85(2147483647)) {
      n4 = PreDecrementId();
        n0 = new NodeChoice(n4, 3);
    } else if (jj_2_86(2)) {
      n5 = ShortAssignPlus();
        n0 = new NodeChoice(n5, 4);
    } else if (jj_2_87(2)) {
      n6 = ShortAssignMinus();
        n0 = new NodeChoice(n6, 5);
    } else if (jj_2_88(4)) {
      n7 = OmpForAdditive();
        n0 = new NodeChoice(n7, 6);
    } else if (jj_2_89(4)) {
      n8 = OmpForSubtractive();
        n0 = new NodeChoice(n8, 7);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        n9 = OmpForMultiplicative();
        n0 = new NodeChoice(n9, 8);
        break;
      default:
        jj_la1[80] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpForReinitExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public PostIncrementId PostIncrementId() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(OP_INCR);
             n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new PostIncrementId(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public PostDecrementId PostDecrementId() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(OP_DECR);
             n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new PostDecrementId(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public PreIncrementId PreIncrementId() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
    n1 = jj_consume_token(OP_INCR);
             n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(IDENTIFIER);
                     n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new PreIncrementId(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public PreDecrementId PreDecrementId() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
    n1 = jj_consume_token(OP_DECR);
             n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(IDENTIFIER);
                     n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new PreDecrementId(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public ShortAssignPlus ShortAssignPlus() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(OP_ADDASS);
             n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
     {if (true) return new ShortAssignPlus(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public ShortAssignMinus ShortAssignMinus() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(OP_SUBASS);
             n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
     {if (true) return new ShortAssignMinus(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForAdditive OmpForAdditive() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   AdditiveExpression n8;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(OP_ASS);
            n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(IDENTIFIER);
                     n4 = JTBToolkit.makeNodeToken(n5);
    n7 = jj_consume_token(OP_ADD);
            n6 = JTBToolkit.makeNodeToken(n7);
    n8 = AdditiveExpression();
     {if (true) return new OmpForAdditive(n0,n2,n4,n6,n8);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForSubtractive OmpForSubtractive() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   AdditiveExpression n8;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(OP_ASS);
            n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(IDENTIFIER);
                     n4 = JTBToolkit.makeNodeToken(n5);
    n7 = jj_consume_token(OP_SUB);
            n6 = JTBToolkit.makeNodeToken(n7);
    n8 = AdditiveExpression();
     {if (true) return new OmpForSubtractive(n0,n2,n4,n6,n8);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForMultiplicative OmpForMultiplicative() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   MultiplicativeExpression n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(OP_ASS);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = MultiplicativeExpression();
    n6 = jj_consume_token(OP_ADD);
            n5 = JTBToolkit.makeNodeToken(n6);
    n8 = jj_consume_token(IDENTIFIER);
                     n7 = JTBToolkit.makeNodeToken(n8);
     {if (true) return new OmpForMultiplicative(n0,n2,n4,n5,n7);}
    throw new Error("Missing return statement in function");
  }

  final public OmpSectionsConstruct OmpSectionsConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeOptional n3 = new NodeOptional();
   OmpSectionsClauseList n4;
   OmpEol n5;
   SectionsScope n6;
    n0 = OmpPragma();
    n2 = jj_consume_token(SECTIONS);
                   n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOWAIT:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
      n4 = OmpSectionsClauseList();
        n3.addNode(n4);
      break;
    default:
      jj_la1[81] = jj_gen;
      ;
    }
    n5 = OmpEol();
    n6 = SectionsScope();
     {if (true) return new OmpSectionsConstruct(n0,n1,n3,n5,n6);}
    throw new Error("Missing return statement in function");
  }

  final public OmpSectionsClauseList OmpSectionsClauseList() throws ParseException {
   OmpSectionsClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpSectionsClause n6;
    n0 = OmpSectionsClause();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
      case NOWAIT:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
        ;
        break;
      default:
        jj_la1[82] = jj_gen;
        break label_18;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[83] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpSectionsClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpSectionsClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpSectionsClause OmpSectionsClause() throws ParseException {
   NodeChoice n0;
   OmpPrivateClause n1;
   OmpFirstPrivateClause n2;
   OmpLastPrivateClause n3;
   OmpReductionClause n4;
   OmpNowaitClause n5;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIVATE:
      n1 = OmpPrivateClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case FIRSTPRIVATE:
      n2 = OmpFirstPrivateClause();
        n0 = new NodeChoice(n2, 1);
      break;
    case LASTPRIVATE:
      n3 = OmpLastPrivateClause();
        n0 = new NodeChoice(n3, 2);
      break;
    case REDUCTION:
      n4 = OmpReductionClause();
        n0 = new NodeChoice(n4, 3);
      break;
    case NOWAIT:
      n5 = OmpNowaitClause();
        n0 = new NodeChoice(n5, 4);
      break;
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OmpSectionsClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public SectionsScope SectionsScope() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   Statement n3;
   NodeListOptional n4 = new NodeListOptional();
   ASection n5;
   NodeToken n6;
   Token n7;
    n1 = jj_consume_token(LEFTBRACE);
            n0 = JTBToolkit.makeNodeToken(n1);
    if (jj_2_90(7)) {
      n3 = Statement();
        n2.addNode(n3);
    } else {
      ;
    }
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CROSSBAR:
        ;
        break;
      default:
        jj_la1[85] = jj_gen;
        break label_19;
      }
      n5 = ASection();
        n4.addNode(n5);
    }
     n4.nodes.trimToSize();
    n7 = jj_consume_token(RIGHTBRACE);
            n6 = JTBToolkit.makeNodeToken(n7);
     {if (true) return new SectionsScope(n0,n2,n4,n6);}
    throw new Error("Missing return statement in function");
  }

  final public ASection ASection() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   OmpEol n3;
   Statement n4;
    n0 = OmpPragma();
    n2 = jj_consume_token(SECTION);
                  n1 = JTBToolkit.makeNodeToken(n2);
    n3 = OmpEol();
    n4 = Statement();
     {if (true) return new ASection(n0,n1,n3,n4);}
    throw new Error("Missing return statement in function");
  }

  final public OmpSingleConstruct OmpSingleConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeOptional n3 = new NodeOptional();
   OmpSingleClauseList n4;
   OmpEol n5;
   Statement n6;
    n0 = OmpPragma();
    n2 = jj_consume_token(SINGLE);
                 n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOWAIT:
    case PRIVATE:
    case FIRSTPRIVATE:
    case COPYPRIVATE:
      n4 = OmpSingleClauseList();
        n3.addNode(n4);
      break;
    default:
      jj_la1[86] = jj_gen;
      ;
    }
    n5 = OmpEol();
    n6 = Statement();
     {if (true) return new OmpSingleConstruct(n0,n1,n3,n5,n6);}
    throw new Error("Missing return statement in function");
  }

  final public OmpSingleClauseList OmpSingleClauseList() throws ParseException {
   OmpSingleClause n0;
   NodeListOptional n1 = new NodeListOptional();
   OmpSingleClause n2;
    n0 = OmpSingleClause();
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOWAIT:
      case PRIVATE:
      case FIRSTPRIVATE:
      case COPYPRIVATE:
        ;
        break;
      default:
        jj_la1[87] = jj_gen;
        break label_20;
      }
      n2 = OmpSingleClause();
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpSingleClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpSingleClause OmpSingleClause() throws ParseException {
   NodeChoice n0;
   OmpPrivateClause n1;
   OmpFirstPrivateClause n2;
   OmpCopyPrivateClause n3;
   OmpNowaitClause n4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIVATE:
      n1 = OmpPrivateClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case FIRSTPRIVATE:
      n2 = OmpFirstPrivateClause();
        n0 = new NodeChoice(n2, 1);
      break;
    case COPYPRIVATE:
      n3 = OmpCopyPrivateClause();
        n0 = new NodeChoice(n3, 2);
      break;
    case NOWAIT:
      n4 = OmpNowaitClause();
        n0 = new NodeChoice(n4, 3);
      break;
    default:
      jj_la1[88] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OmpSingleClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpCopyPrivateClause OmpCopyPrivateClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   VariableList n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(COPYPRIVATE);
                      n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = VariableList();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpCopyPrivateClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpSimdConstruct OmpSimdConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeOptional n3 = new NodeOptional();
   OmpSimdClauseList n4;
   OmpEol n5;
   OmpForHeader n6;
   Statement n7;
    n0 = OmpPragma();
    n2 = jj_consume_token(SIMD);
               n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REDUCTION:
    case PRIVATE:
    case LASTPRIVATE:
    case COLLAPSE:
    case LINEAR:
    case SAFELEN:
    case SIMDLEN:
    case ALIGNED:
      n4 = OmpSimdClauseList();
        n3.addNode(n4);
      break;
    default:
      jj_la1[89] = jj_gen;
      ;
    }
    n5 = OmpEol();
    n6 = OmpForHeader();
    n7 = Statement();
     {if (true) return new OmpSimdConstruct(n0,n1,n3,n5,n6,n7);}
    throw new Error("Missing return statement in function");
  }

  final public OmpSimdClauseList OmpSimdClauseList() throws ParseException {
   OmpSimdClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpSimdClause n6;
    n0 = OmpSimdClause();
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
      case REDUCTION:
      case PRIVATE:
      case LASTPRIVATE:
      case COLLAPSE:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
        ;
        break;
      default:
        jj_la1[90] = jj_gen;
        break label_21;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[91] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpSimdClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpSimdClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpSimdClause OmpSimdClause() throws ParseException {
   NodeChoice n0;
   OmpSafeLenClause n1;
   OmpSimdLenClause n2;
   OmpLinearClause n3;
   OmpAlignedClause n4;
   OmpPrivateClause n5;
   OmpLastPrivateClause n6;
   OmpReductionClause n7;
   OmpCollapseClause n8;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SAFELEN:
      n1 = OmpSafeLenClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case SIMDLEN:
      n2 = OmpSimdLenClause();
        n0 = new NodeChoice(n2, 1);
      break;
    case LINEAR:
      n3 = OmpLinearClause();
        n0 = new NodeChoice(n3, 2);
      break;
    case ALIGNED:
      n4 = OmpAlignedClause();
        n0 = new NodeChoice(n4, 3);
      break;
    case PRIVATE:
      n5 = OmpPrivateClause();
        n0 = new NodeChoice(n5, 4);
      break;
    case LASTPRIVATE:
      n6 = OmpLastPrivateClause();
        n0 = new NodeChoice(n6, 5);
      break;
    case REDUCTION:
      n7 = OmpReductionClause();
        n0 = new NodeChoice(n7, 6);
      break;
    case COLLAPSE:
      n8 = OmpCollapseClause();
        n0 = new NodeChoice(n8, 7);
      break;
    default:
      jj_la1[92] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OmpSimdClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpSafeLenClause OmpSafeLenClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(SAFELEN);
                  n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpSafeLenClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpSimdLenClause OmpSimdLenClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(SIMDLEN);
                  n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpSimdLenClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpAlignedClause OmpAlignedClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   VariableList n4;
   NodeOptional n5 = new NodeOptional();
   NodeSequence n6;
   NodeToken n7;
   Token n8;
   Expression n9;
   NodeToken n10;
   Token n11;
    n1 = jj_consume_token(ALIGNED);
                  n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = VariableList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
        n6 = new NodeSequence(2);
      n8 = jj_consume_token(COLON);
                   n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
      n9 = Expression();
        n6.addNode(n9);
        n5.addNode(n6);
      break;
    default:
      jj_la1[93] = jj_gen;
      ;
    }
    n11 = jj_consume_token(RIGHTPAREN);
             n10 = JTBToolkit.makeNodeToken(n11);
     {if (true) return new OmpAlignedClause(n0,n2,n4,n5,n10);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForSimdConstruct OmpForSimdConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeOptional n5 = new NodeOptional();
   OmpForSimdClauseList n6;
   OmpEol n7;
   OmpForHeader n8;
   Statement n9;
    n0 = OmpPragma();
    n2 = jj_consume_token(FOR);
              n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(SIMD);
               n3 = JTBToolkit.makeNodeToken(n4);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ORDERED:
    case NOWAIT:
    case SCHEDULE:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case COLLAPSE:
    case LINEAR:
    case SAFELEN:
    case SIMDLEN:
    case ALIGNED:
      n6 = OmpForSimdClauseList();
        n5.addNode(n6);
      break;
    default:
      jj_la1[94] = jj_gen;
      ;
    }
    n7 = OmpEol();
    n8 = OmpForHeader();
    n9 = Statement();
     {if (true) return new OmpForSimdConstruct(n0,n1,n3,n5,n7,n8,n9);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForSimdClauseList OmpForSimdClauseList() throws ParseException {
   OmpForSimdClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpForSimdClause n6;
    n0 = OmpForSimdClause();
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
      case ORDERED:
      case NOWAIT:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case COLLAPSE:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
        ;
        break;
      default:
        jj_la1[95] = jj_gen;
        break label_22;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[96] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpForSimdClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpForSimdClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForSimdClause OmpForSimdClause() throws ParseException {
   NodeChoice n0;
   OmpSimdClause n1;
   OmpForClause n2;
    if (jj_2_91(2147483647)) {
      n1 = OmpSimdClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ORDERED:
      case NOWAIT:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case COLLAPSE:
      case LINEAR:
        n2 = OmpForClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[97] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpForSimdClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTaskConstruct OmpTaskConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeOptional n3 = new NodeOptional();
   TaskClauseList n4;
   OmpEol n5;
   Statement n6;
    n0 = OmpPragma();
    n2 = jj_consume_token(TASK);
               n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case PRIVATE:
    case FIRSTPRIVATE:
    case SHARED:
    case UNTIED:
    case MERGEABLE:
    case FINAL:
    case DEPEND:
    case PRIORITY:
      n4 = TaskClauseList();
        n3.addNode(n4);
      break;
    default:
      jj_la1[98] = jj_gen;
      ;
    }
    n5 = OmpEol();
    n6 = Statement();
     {if (true) return new OmpTaskConstruct(n0,n1,n3,n5,n6);}
    throw new Error("Missing return statement in function");
  }

  final public TaskClauseList TaskClauseList() throws ParseException {
   TaskClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   TaskClause n6;
    n0 = TaskClause();
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case PRIVATE:
      case FIRSTPRIVATE:
      case SHARED:
      case UNTIED:
      case MERGEABLE:
      case FINAL:
      case DEPEND:
      case PRIORITY:
        ;
        break;
      default:
        jj_la1[99] = jj_gen;
        break label_23;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[100] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = TaskClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new TaskClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public TaskClause TaskClause() throws ParseException {
   NodeChoice n0;
   OmpIfTaskClause n1;
   OmpFinalClause n2;
   OmpUntiedClause n3;
   OmpDfltSharedClause n4;
   OmpDfltNoneClause n5;
   OmpMergeableClause n6;
   OmpPrivateClause n7;
   OmpFirstPrivateClause n8;
   OmpSharedClause n9;
   OmpDependClause n10;
   OmpPriorityClause n11;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      n1 = OmpIfTaskClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case FINAL:
      n2 = OmpFinalClause();
        n0 = new NodeChoice(n2, 1);
      break;
    case UNTIED:
      n3 = OmpUntiedClause();
        n0 = new NodeChoice(n3, 2);
      break;
    default:
      jj_la1[101] = jj_gen;
      if (jj_2_92(3)) {
        n4 = OmpDfltSharedClause();
        n0 = new NodeChoice(n4, 3);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DFLT:
          n5 = OmpDfltNoneClause();
        n0 = new NodeChoice(n5, 4);
          break;
        case MERGEABLE:
          n6 = OmpMergeableClause();
        n0 = new NodeChoice(n6, 5);
          break;
        case PRIVATE:
          n7 = OmpPrivateClause();
        n0 = new NodeChoice(n7, 6);
          break;
        case FIRSTPRIVATE:
          n8 = OmpFirstPrivateClause();
        n0 = new NodeChoice(n8, 7);
          break;
        case SHARED:
          n9 = OmpSharedClause();
        n0 = new NodeChoice(n9, 8);
          break;
        case DEPEND:
          n10 = OmpDependClause();
        n0 = new NodeChoice(n10, 9);
          break;
        case PRIORITY:
          n11 = OmpPriorityClause();
        n0 = new NodeChoice(n11, 10);
          break;
        default:
          jj_la1[102] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
     {if (true) return new TaskClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpIfTaskClause OmpIfTaskClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeOptional n4 = new NodeOptional();
   NodeSequence n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   Expression n10;
   NodeToken n11;
   Token n12;
    n1 = jj_consume_token(IF);
             n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
        n5 = new NodeSequence(2);
      n7 = jj_consume_token(TASK);
                  n6 = JTBToolkit.makeNodeToken(n7);
        n5.addNode(n6);
      n9 = jj_consume_token(COLON);
                   n8 = JTBToolkit.makeNodeToken(n9);
        n5.addNode(n8);
        n4.addNode(n5);
      break;
    default:
      jj_la1[103] = jj_gen;
      ;
    }
    n10 = Expression();
    n12 = jj_consume_token(RIGHTPAREN);
             n11 = JTBToolkit.makeNodeToken(n12);
     {if (true) return new OmpIfTaskClause(n0,n2,n4,n10,n11);}
    throw new Error("Missing return statement in function");
  }

  final public OmpFinalClause OmpFinalClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(FINAL);
                n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpFinalClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpUntiedClause OmpUntiedClause() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(UNTIED);
                 n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new OmpUntiedClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpMergeableClause OmpMergeableClause() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(MERGEABLE);
                    n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new OmpMergeableClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDependClause OmpDependClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   DependencyType n4;
   NodeToken n5;
   Token n6;
   VariableList n7;
   NodeToken n8;
   Token n9;
    n1 = jj_consume_token(DEPEND);
                 n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = DependencyType();
    n6 = jj_consume_token(COLON);
                n5 = JTBToolkit.makeNodeToken(n6);
    n7 = VariableList();
    n9 = jj_consume_token(RIGHTPAREN);
            n8 = JTBToolkit.makeNodeToken(n9);
     {if (true) return new OmpDependClause(n0,n2,n4,n5,n7,n8);}
    throw new Error("Missing return statement in function");
  }

  final public DependencyType DependencyType() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IN:
      n2 = jj_consume_token(IN);
                n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case OUT:
      n4 = jj_consume_token(OUT);
                 n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case INOUT:
      n6 = jj_consume_token(INOUT);
                   n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    default:
      jj_la1[104] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new DependencyType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpPriorityClause OmpPriorityClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(PRIORITY);
                   n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpPriorityClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTaskLoopSimdConstruct OmpTaskLoopSimdConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeOptional n5 = new NodeOptional();
   OmpTaskLoopSimdClauseList n6;
   OmpEol n7;
   OmpForHeader n8;
   Statement n9;
    n0 = OmpPragma();
    n2 = jj_consume_token(TASKLOOP);
                   n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(SIMD);
               n3 = JTBToolkit.makeNodeToken(n4);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case COLLAPSE:
    case UNTIED:
    case MERGEABLE:
    case FINAL:
    case LINEAR:
    case SAFELEN:
    case SIMDLEN:
    case ALIGNED:
    case PRIORITY:
    case GRAINSIZE:
    case NUMTASKS:
    case NOGROUP:
      n6 = OmpTaskLoopSimdClauseList();
        n5.addNode(n6);
      break;
    default:
      jj_la1[105] = jj_gen;
      ;
    }
    n7 = OmpEol();
    n8 = OmpForHeader();
    n9 = Statement();
     {if (true) return new OmpTaskLoopSimdConstruct(n0,n1,n3,n5,n7,n8,n9);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTaskLoopSimdClauseList OmpTaskLoopSimdClauseList() throws ParseException {
   OmpTaskLoopSimdClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTaskLoopSimdClause n6;
    n0 = OmpTaskLoopSimdClause();
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COLLAPSE:
      case UNTIED:
      case MERGEABLE:
      case FINAL:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
      case PRIORITY:
      case GRAINSIZE:
      case NUMTASKS:
      case NOGROUP:
        ;
        break;
      default:
        jj_la1[106] = jj_gen;
        break label_24;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[107] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTaskLoopSimdClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTaskLoopSimdClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTaskLoopSimdClause OmpTaskLoopSimdClause() throws ParseException {
   NodeChoice n0;
   OmpSimdClause n1;
   OmpTaskLoopClause n2;
    if (jj_2_93(2147483647)) {
      n1 = OmpSimdClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COLLAPSE:
      case UNTIED:
      case MERGEABLE:
      case FINAL:
      case PRIORITY:
      case GRAINSIZE:
      case NUMTASKS:
      case NOGROUP:
        n2 = OmpTaskLoopClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[108] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpTaskLoopSimdClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTaskLoopConstruct OmpTaskLoopConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeOptional n3 = new NodeOptional();
   OmpTaskLoopClauseList n4;
   OmpEol n5;
   OmpForHeader n6;
   Statement n7;
    n0 = OmpPragma();
    n2 = jj_consume_token(TASKLOOP);
                   n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case COLLAPSE:
    case UNTIED:
    case MERGEABLE:
    case FINAL:
    case PRIORITY:
    case GRAINSIZE:
    case NUMTASKS:
    case NOGROUP:
      n4 = OmpTaskLoopClauseList();
        n3.addNode(n4);
      break;
    default:
      jj_la1[109] = jj_gen;
      ;
    }
    n5 = OmpEol();
    n6 = OmpForHeader();
    n7 = Statement();
     {if (true) return new OmpTaskLoopConstruct(n0,n1,n3,n5,n6,n7);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTaskLoopClauseList OmpTaskLoopClauseList() throws ParseException {
   OmpTaskLoopClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTaskLoopClause n6;
    n0 = OmpTaskLoopClause();
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COLLAPSE:
      case UNTIED:
      case MERGEABLE:
      case FINAL:
      case PRIORITY:
      case GRAINSIZE:
      case NUMTASKS:
      case NOGROUP:
        ;
        break;
      default:
        jj_la1[110] = jj_gen;
        break label_25;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[111] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTaskLoopClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTaskLoopClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTaskLoopClause OmpTaskLoopClause() throws ParseException {
   NodeChoice n0;
   OmpIfTaskLoopClause n1;
   OmpSharedClause n2;
   OmpPrivateClause n3;
   OmpFirstPrivateClause n4;
   OmpLastPrivateClause n5;
   OmpDfltSharedClause n6;
   OmpDfltNoneClause n7;
   OmpGrainSizeClause n8;
   OmpNumTasksClause n9;
   OmpCollapseClause n10;
   OmpFinalClause n11;
   OmpPriorityClause n12;
   OmpUntiedClause n13;
   OmpMergeableClause n14;
   OmpNoGroupClause n15;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      n1 = OmpIfTaskLoopClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case SHARED:
      n2 = OmpSharedClause();
        n0 = new NodeChoice(n2, 1);
      break;
    case PRIVATE:
      n3 = OmpPrivateClause();
        n0 = new NodeChoice(n3, 2);
      break;
    case FIRSTPRIVATE:
      n4 = OmpFirstPrivateClause();
        n0 = new NodeChoice(n4, 3);
      break;
    case LASTPRIVATE:
      n5 = OmpLastPrivateClause();
        n0 = new NodeChoice(n5, 4);
      break;
    default:
      jj_la1[112] = jj_gen;
      if (jj_2_94(3)) {
        n6 = OmpDfltSharedClause();
        n0 = new NodeChoice(n6, 5);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DFLT:
          n7 = OmpDfltNoneClause();
        n0 = new NodeChoice(n7, 6);
          break;
        case GRAINSIZE:
          n8 = OmpGrainSizeClause();
        n0 = new NodeChoice(n8, 7);
          break;
        case NUMTASKS:
          n9 = OmpNumTasksClause();
        n0 = new NodeChoice(n9, 8);
          break;
        case COLLAPSE:
          n10 = OmpCollapseClause();
        n0 = new NodeChoice(n10, 9);
          break;
        case FINAL:
          n11 = OmpFinalClause();
        n0 = new NodeChoice(n11, 10);
          break;
        case PRIORITY:
          n12 = OmpPriorityClause();
        n0 = new NodeChoice(n12, 11);
          break;
        case UNTIED:
          n13 = OmpUntiedClause();
        n0 = new NodeChoice(n13, 12);
          break;
        case MERGEABLE:
          n14 = OmpMergeableClause();
        n0 = new NodeChoice(n14, 13);
          break;
        case NOGROUP:
          n15 = OmpNoGroupClause();
        n0 = new NodeChoice(n15, 14);
          break;
        default:
          jj_la1[113] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
     {if (true) return new OmpTaskLoopClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpIfTaskLoopClause OmpIfTaskLoopClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeOptional n4 = new NodeOptional();
   NodeSequence n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   Expression n10;
   NodeToken n11;
   Token n12;
    n1 = jj_consume_token(IF);
             n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASKLOOP:
        n5 = new NodeSequence(2);
      n7 = jj_consume_token(TASKLOOP);
                      n6 = JTBToolkit.makeNodeToken(n7);
        n5.addNode(n6);
      n9 = jj_consume_token(COLON);
                   n8 = JTBToolkit.makeNodeToken(n9);
        n5.addNode(n8);
        n4.addNode(n5);
      break;
    default:
      jj_la1[114] = jj_gen;
      ;
    }
    n10 = Expression();
    n12 = jj_consume_token(RIGHTPAREN);
             n11 = JTBToolkit.makeNodeToken(n12);
     {if (true) return new OmpIfTaskLoopClause(n0,n2,n4,n10,n11);}
    throw new Error("Missing return statement in function");
  }

  final public OmpGrainSizeClause OmpGrainSizeClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(GRAINSIZE);
                    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpGrainSizeClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpNumTasksClause OmpNumTasksClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(NUMTASKS);
                   n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpNumTasksClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpNoGroupClause OmpNoGroupClause() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(NOGROUP);
                  n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new OmpNoGroupClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetDataConstruct OmpTargetDataConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeOptional n5 = new NodeOptional();
   OmpTargetDataClauseList n6;
   OmpEol n7;
   Statement n8;
    n0 = OmpPragma();
    n2 = jj_consume_token(TARGET);
                 n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(DATA);
               n3 = JTBToolkit.makeNodeToken(n4);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
    case DEVICE:
    case MAP:
    case USEDEVICEPTR:
      n6 = OmpTargetDataClauseList();
        n5.addNode(n6);
      break;
    default:
      jj_la1[115] = jj_gen;
      ;
    }
    n7 = OmpEol();
    n8 = Statement();
     {if (true) return new OmpTargetDataConstruct(n0,n1,n3,n5,n7,n8);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetDataClauseList OmpTargetDataClauseList() throws ParseException {
   OmpTargetDataClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTargetDataClause n6;
    n0 = OmpTargetDataClause();
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case COMMA:
      case DEVICE:
      case MAP:
      case USEDEVICEPTR:
        ;
        break;
      default:
        jj_la1[116] = jj_gen;
        break label_26;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[117] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTargetDataClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTargetDataClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetDataClause OmpTargetDataClause() throws ParseException {
   NodeChoice n0;
   OmpIfTargetDataClause n1;
   OmpDeviceClause n2;
   OmpMapClause n3;
   OmpUseDevicePtrClause n4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      n1 = OmpIfTargetDataClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case DEVICE:
      n2 = OmpDeviceClause();
        n0 = new NodeChoice(n2, 1);
      break;
    case MAP:
      n3 = OmpMapClause();
        n0 = new NodeChoice(n3, 2);
      break;
    case USEDEVICEPTR:
      n4 = OmpUseDevicePtrClause();
        n0 = new NodeChoice(n4, 3);
      break;
    default:
      jj_la1[118] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OmpTargetDataClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpIfTargetDataClause OmpIfTargetDataClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   Expression n8;
   NodeToken n9;
   Token n10;
    n1 = jj_consume_token(IF);
             n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(TARGET);
                 n4 = JTBToolkit.makeNodeToken(n5);
    n7 = jj_consume_token(DATA);
               n6 = JTBToolkit.makeNodeToken(n7);
    n8 = Expression();
    n10 = jj_consume_token(RIGHTPAREN);
             n9 = JTBToolkit.makeNodeToken(n10);
     {if (true) return new OmpIfTargetDataClause(n0,n2,n4,n6,n8,n9);}
    throw new Error("Missing return statement in function");
  }

  final public OmpUseDevicePtrClause OmpUseDevicePtrClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   VariableList n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(USEDEVICEPTR);
                       n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = VariableList();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpUseDevicePtrClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetParallelForSimdConstruct OmpTargetParallelForSimdConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeOptional n9 = new NodeOptional();
   OmpTargetParallelForSimdClauseList n10;
   OmpEol n11;
   OmpForHeader n12;
   Statement n13;
    n0 = OmpPragma();
    n2 = jj_consume_token(TARGET);
                 n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(PARALLEL);
                   n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(FOR);
              n5 = JTBToolkit.makeNodeToken(n6);
    n8 = jj_consume_token(SIMD);
               n7 = JTBToolkit.makeNodeToken(n8);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case ORDERED:
    case NOWAIT:
    case SCHEDULE:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case NUM_THREADS:
    case COLLAPSE:
    case PROC_BIND:
    case LINEAR:
    case SAFELEN:
    case SIMDLEN:
    case ALIGNED:
    case DEPEND:
    case DEVICE:
    case MAP:
    case ISDEVICEPTR:
    case DEFAULTMAP:
      n10 = OmpTargetParallelForSimdClauseList();
        n9.addNode(n10);
      break;
    default:
      jj_la1[119] = jj_gen;
      ;
    }
    n11 = OmpEol();
    n12 = OmpForHeader();
    n13 = Statement();
     {if (true) return new OmpTargetParallelForSimdConstruct(n0,n1,n3,n5,n7,n9,n11,n12,n13);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetParallelForSimdClauseList OmpTargetParallelForSimdClauseList() throws ParseException {
   OmpTargetParallelForSimdClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTargetParallelForSimdClause n6;
    n0 = OmpTargetParallelForSimdClause();
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case ORDERED:
      case NOWAIT:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
      case DEPEND:
      case DEVICE:
      case MAP:
      case ISDEVICEPTR:
      case DEFAULTMAP:
        ;
        break;
      default:
        jj_la1[120] = jj_gen;
        break label_27;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[121] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTargetParallelForSimdClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTargetParallelForSimdClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetParallelForSimdClause OmpTargetParallelForSimdClause() throws ParseException {
   NodeChoice n0;
   OmpTargetClause n1;
   OmpSimdClause n2;
   OmpIfParallelClause n3;
   OmpNumThreadsClause n4;
   OmpDfltSharedClause n5;
   OmpDfltNoneClause n6;
   OmpPrivateClause n7;
   OmpFirstPrivateClause n8;
   OmpSharedClause n9;
   OmpReductionClause n10;
   OmpThreadAffinityMasterClause n11;
   OmpThreadAffinityCloseClause n12;
   OmpThreadAffinitySpreadClause n13;
   OmpLastPrivateClause n14;
   OmpLinearClause n15;
   OmpScheduleClause n16;
   OmpCollapseClause n17;
   OmpOrderedClause n18;
    if (jj_2_95(2147483647)) {
      n1 = OmpTargetClause();
        n0 = new NodeChoice(n1, 0);
    } else if (jj_2_96(2147483647)) {
      n2 = OmpSimdClause();
        n0 = new NodeChoice(n2, 1);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
        n3 = OmpIfParallelClause();
        n0 = new NodeChoice(n3, 2);
        break;
      case NUM_THREADS:
        n4 = OmpNumThreadsClause();
        n0 = new NodeChoice(n4, 3);
        break;
      default:
        jj_la1[122] = jj_gen;
        if (jj_2_97(3)) {
          n5 = OmpDfltSharedClause();
        n0 = new NodeChoice(n5, 4);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DFLT:
            n6 = OmpDfltNoneClause();
        n0 = new NodeChoice(n6, 5);
            break;
          case PRIVATE:
            n7 = OmpPrivateClause();
        n0 = new NodeChoice(n7, 6);
            break;
          case FIRSTPRIVATE:
            n8 = OmpFirstPrivateClause();
        n0 = new NodeChoice(n8, 7);
            break;
          case SHARED:
            n9 = OmpSharedClause();
        n0 = new NodeChoice(n9, 8);
            break;
          case REDUCTION:
            n10 = OmpReductionClause();
        n0 = new NodeChoice(n10, 9);
            break;
          default:
            jj_la1[123] = jj_gen;
            if (jj_2_98(3)) {
              n11 = OmpThreadAffinityMasterClause();
        n0 = new NodeChoice(n11, 10);
            } else if (jj_2_99(3)) {
              n12 = OmpThreadAffinityCloseClause();
        n0 = new NodeChoice(n12, 11);
            } else {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case PROC_BIND:
                n13 = OmpThreadAffinitySpreadClause();
        n0 = new NodeChoice(n13, 12);
                break;
              case LASTPRIVATE:
                n14 = OmpLastPrivateClause();
        n0 = new NodeChoice(n14, 13);
                break;
              case LINEAR:
                n15 = OmpLinearClause();
        n0 = new NodeChoice(n15, 14);
                break;
              case SCHEDULE:
                n16 = OmpScheduleClause();
        n0 = new NodeChoice(n16, 15);
                break;
              case COLLAPSE:
                n17 = OmpCollapseClause();
        n0 = new NodeChoice(n17, 16);
                break;
              case ORDERED:
                n18 = OmpOrderedClause();
        n0 = new NodeChoice(n18, 17);
                break;
              default:
                jj_la1[124] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
          }
        }
      }
    }
     {if (true) return new OmpTargetParallelForSimdClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetParallelForConstruct OmpTargetParallelForConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeOptional n7 = new NodeOptional();
   OmpTargetParallelForClauseList n8;
   OmpEol n9;
   OmpForHeader n10;
   Statement n11;
    n0 = OmpPragma();
    n2 = jj_consume_token(TARGET);
                 n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(PARALLEL);
                   n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(FOR);
              n5 = JTBToolkit.makeNodeToken(n6);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case ORDERED:
    case NOWAIT:
    case SCHEDULE:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case NUM_THREADS:
    case COLLAPSE:
    case PROC_BIND:
    case LINEAR:
    case DEPEND:
    case DEVICE:
    case MAP:
    case ISDEVICEPTR:
    case DEFAULTMAP:
      n8 = OmpTargetParallelForClauseList();
        n7.addNode(n8);
      break;
    default:
      jj_la1[125] = jj_gen;
      ;
    }
    n9 = OmpEol();
    n10 = OmpForHeader();
    n11 = Statement();
     {if (true) return new OmpTargetParallelForConstruct(n0,n1,n3,n5,n7,n9,n10,n11);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetParallelForClauseList OmpTargetParallelForClauseList() throws ParseException {
   OmpTargetParallelForClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTargetParallelForClause n6;
    n0 = OmpTargetParallelForClause();
    label_28:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case ORDERED:
      case NOWAIT:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
      case DEPEND:
      case DEVICE:
      case MAP:
      case ISDEVICEPTR:
      case DEFAULTMAP:
        ;
        break;
      default:
        jj_la1[126] = jj_gen;
        break label_28;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[127] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTargetParallelForClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTargetParallelForClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetParallelForClause OmpTargetParallelForClause() throws ParseException {
   NodeChoice n0;
   OmpTargetClause n1;
   OmpIfParallelClause n2;
   OmpNumThreadsClause n3;
   OmpDfltSharedClause n4;
   OmpDfltNoneClause n5;
   OmpPrivateClause n6;
   OmpFirstPrivateClause n7;
   OmpSharedClause n8;
   OmpReductionClause n9;
   OmpThreadAffinityMasterClause n10;
   OmpThreadAffinityCloseClause n11;
   OmpThreadAffinitySpreadClause n12;
   OmpLastPrivateClause n13;
   OmpLinearClause n14;
   OmpScheduleClause n15;
   OmpCollapseClause n16;
   OmpOrderedClause n17;
    if (jj_2_100(2147483647)) {
      n1 = OmpTargetClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
        n2 = OmpIfParallelClause();
        n0 = new NodeChoice(n2, 1);
        break;
      case NUM_THREADS:
        n3 = OmpNumThreadsClause();
        n0 = new NodeChoice(n3, 2);
        break;
      default:
        jj_la1[128] = jj_gen;
        if (jj_2_101(3)) {
          n4 = OmpDfltSharedClause();
        n0 = new NodeChoice(n4, 3);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DFLT:
            n5 = OmpDfltNoneClause();
        n0 = new NodeChoice(n5, 4);
            break;
          case PRIVATE:
            n6 = OmpPrivateClause();
        n0 = new NodeChoice(n6, 5);
            break;
          case FIRSTPRIVATE:
            n7 = OmpFirstPrivateClause();
        n0 = new NodeChoice(n7, 6);
            break;
          case SHARED:
            n8 = OmpSharedClause();
        n0 = new NodeChoice(n8, 7);
            break;
          case REDUCTION:
            n9 = OmpReductionClause();
        n0 = new NodeChoice(n9, 8);
            break;
          default:
            jj_la1[129] = jj_gen;
            if (jj_2_102(3)) {
              n10 = OmpThreadAffinityMasterClause();
        n0 = new NodeChoice(n10, 9);
            } else if (jj_2_103(3)) {
              n11 = OmpThreadAffinityCloseClause();
        n0 = new NodeChoice(n11, 10);
            } else {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case PROC_BIND:
                n12 = OmpThreadAffinitySpreadClause();
        n0 = new NodeChoice(n12, 11);
                break;
              case LASTPRIVATE:
                n13 = OmpLastPrivateClause();
        n0 = new NodeChoice(n13, 12);
                break;
              case LINEAR:
                n14 = OmpLinearClause();
        n0 = new NodeChoice(n14, 13);
                break;
              case SCHEDULE:
                n15 = OmpScheduleClause();
        n0 = new NodeChoice(n15, 14);
                break;
              case COLLAPSE:
                n16 = OmpCollapseClause();
        n0 = new NodeChoice(n16, 15);
                break;
              case ORDERED:
                n17 = OmpOrderedClause();
        n0 = new NodeChoice(n17, 16);
                break;
              default:
                jj_la1[130] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
          }
        }
      }
    }
     {if (true) return new OmpTargetParallelForClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetParallelConstruct OmpTargetParallelConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeOptional n5 = new NodeOptional();
   OmpTargetParallelClauseList n6;
   OmpEol n7;
   Statement n8;
    n0 = OmpPragma();
    n2 = jj_consume_token(TARGET);
                 n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(PARALLEL);
                   n3 = JTBToolkit.makeNodeToken(n4);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case NOWAIT:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case SHARED:
    case NUM_THREADS:
    case PROC_BIND:
    case DEPEND:
    case DEVICE:
    case MAP:
    case ISDEVICEPTR:
    case DEFAULTMAP:
      n6 = OmpTargetParallelClauseList();
        n5.addNode(n6);
      break;
    default:
      jj_la1[131] = jj_gen;
      ;
    }
    n7 = OmpEol();
    n8 = Statement();
     {if (true) return new OmpTargetParallelConstruct(n0,n1,n3,n5,n7,n8);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetParallelClauseList OmpTargetParallelClauseList() throws ParseException {
   OmpTargetParallelClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTargetParallelClause n6;
    n0 = OmpTargetParallelClause();
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case NOWAIT:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case SHARED:
      case NUM_THREADS:
      case PROC_BIND:
      case DEPEND:
      case DEVICE:
      case MAP:
      case ISDEVICEPTR:
      case DEFAULTMAP:
        ;
        break;
      default:
        jj_la1[132] = jj_gen;
        break label_29;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[133] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTargetParallelClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTargetParallelClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetParallelClause OmpTargetParallelClause() throws ParseException {
   NodeChoice n0;
   OmpTargetClause n1;
   OmpIfParallelClause n2;
   OmpNumThreadsClause n3;
   OmpDfltSharedClause n4;
   OmpDfltNoneClause n5;
   OmpPrivateClause n6;
   OmpFirstPrivateClause n7;
   OmpSharedClause n8;
   OmpReductionClause n9;
   OmpThreadAffinityMasterClause n10;
   OmpThreadAffinityCloseClause n11;
   OmpThreadAffinitySpreadClause n12;
    if (jj_2_104(2147483647)) {
      n1 = OmpTargetClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
        n2 = OmpIfParallelClause();
        n0 = new NodeChoice(n2, 1);
        break;
      case NUM_THREADS:
        n3 = OmpNumThreadsClause();
        n0 = new NodeChoice(n3, 2);
        break;
      default:
        jj_la1[134] = jj_gen;
        if (jj_2_105(3)) {
          n4 = OmpDfltSharedClause();
        n0 = new NodeChoice(n4, 3);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DFLT:
            n5 = OmpDfltNoneClause();
        n0 = new NodeChoice(n5, 4);
            break;
          case PRIVATE:
            n6 = OmpPrivateClause();
        n0 = new NodeChoice(n6, 5);
            break;
          case FIRSTPRIVATE:
            n7 = OmpFirstPrivateClause();
        n0 = new NodeChoice(n7, 6);
            break;
          case SHARED:
            n8 = OmpSharedClause();
        n0 = new NodeChoice(n8, 7);
            break;
          case REDUCTION:
            n9 = OmpReductionClause();
        n0 = new NodeChoice(n9, 8);
            break;
          default:
            jj_la1[135] = jj_gen;
            if (jj_2_106(3)) {
              n10 = OmpThreadAffinityMasterClause();
        n0 = new NodeChoice(n10, 9);
            } else if (jj_2_107(3)) {
              n11 = OmpThreadAffinityCloseClause();
        n0 = new NodeChoice(n11, 10);
            } else {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case PROC_BIND:
                n12 = OmpThreadAffinitySpreadClause();
        n0 = new NodeChoice(n12, 11);
                break;
              default:
                jj_la1[136] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
          }
        }
      }
    }
     {if (true) return new OmpTargetParallelClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetSimdConstruct OmpTargetSimdConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeOptional n5 = new NodeOptional();
   OmpTargetSimdClauseList n6;
   OmpEol n7;
   OmpForHeader n8;
   Statement n9;
    n0 = OmpPragma();
    n2 = jj_consume_token(TARGET);
                 n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(SIMD);
               n3 = JTBToolkit.makeNodeToken(n4);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
    case NOWAIT:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case COLLAPSE:
    case LINEAR:
    case SAFELEN:
    case SIMDLEN:
    case ALIGNED:
    case DEPEND:
    case DEVICE:
    case MAP:
    case ISDEVICEPTR:
    case DEFAULTMAP:
      n6 = OmpTargetSimdClauseList();
        n5.addNode(n6);
      break;
    default:
      jj_la1[137] = jj_gen;
      ;
    }
    n7 = OmpEol();
    n8 = OmpForHeader();
    n9 = Statement();
     {if (true) return new OmpTargetSimdConstruct(n0,n1,n3,n5,n7,n8,n9);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetSimdClauseList OmpTargetSimdClauseList() throws ParseException {
   OmpTargetSimdClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTargetSimdClause n6;
    n0 = OmpTargetSimdClause();
    label_30:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case COMMA:
      case NOWAIT:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case COLLAPSE:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
      case DEPEND:
      case DEVICE:
      case MAP:
      case ISDEVICEPTR:
      case DEFAULTMAP:
        ;
        break;
      default:
        jj_la1[138] = jj_gen;
        break label_30;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[139] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTargetSimdClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTargetSimdClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetSimdClause OmpTargetSimdClause() throws ParseException {
   NodeChoice n0;
   OmpTargetClause n1;
   OmpSimdClause n2;
    if (jj_2_108(2147483647)) {
      n1 = OmpTargetClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REDUCTION:
      case PRIVATE:
      case LASTPRIVATE:
      case COLLAPSE:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
        n2 = OmpSimdClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[140] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpTargetSimdClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetTeamsDistributeParallelForSimdConstruct OmpTargetTeamsDistributeParallelForSimdConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeOptional n11 = new NodeOptional();
   OmpTargetTeamsDistributeParallelForSimdClauseList n12;
   OmpEol n13;
   OmpForHeader n14;
   Statement n15;
    n0 = OmpPragma();
    n2 = jj_consume_token(TEAMS);
                n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(DISTRIBUTE);
                     n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(PARALLEL);
                   n5 = JTBToolkit.makeNodeToken(n6);
    n8 = jj_consume_token(FOR);
              n7 = JTBToolkit.makeNodeToken(n8);
    n10 = jj_consume_token(SIMD);
                n9 = JTBToolkit.makeNodeToken(n10);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case ORDERED:
    case NOWAIT:
    case SCHEDULE:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case COPYIN:
    case NUM_THREADS:
    case COLLAPSE:
    case PROC_BIND:
    case LINEAR:
    case SAFELEN:
    case SIMDLEN:
    case ALIGNED:
    case DEPEND:
    case DEVICE:
    case MAP:
    case ISDEVICEPTR:
    case DEFAULTMAP:
    case NUMTEAMS:
    case THREADLIMIT:
    case DISTSCHEDULE:
      n12 = OmpTargetTeamsDistributeParallelForSimdClauseList();
        n11.addNode(n12);
      break;
    default:
      jj_la1[141] = jj_gen;
      ;
    }
    n13 = OmpEol();
    n14 = OmpForHeader();
    n15 = Statement();
     {if (true) return new OmpTargetTeamsDistributeParallelForSimdConstruct(n0,n1,n3,n5,n7,n9,n11,n13,n14,n15);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetTeamsDistributeParallelForSimdClauseList OmpTargetTeamsDistributeParallelForSimdClauseList() throws ParseException {
   OmpTargetTeamsDistributeParallelForSimdClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTargetTeamsDistributeParallelForSimdClause n6;
    n0 = OmpTargetTeamsDistributeParallelForSimdClause();
    label_31:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case ORDERED:
      case NOWAIT:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COPYIN:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
      case DEPEND:
      case DEVICE:
      case MAP:
      case ISDEVICEPTR:
      case DEFAULTMAP:
      case NUMTEAMS:
      case THREADLIMIT:
      case DISTSCHEDULE:
        ;
        break;
      default:
        jj_la1[142] = jj_gen;
        break label_31;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[143] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTargetTeamsDistributeParallelForSimdClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTargetTeamsDistributeParallelForSimdClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetTeamsDistributeParallelForSimdClause OmpTargetTeamsDistributeParallelForSimdClause() throws ParseException {
   NodeChoice n0;
   OmpTargetClause n1;
   OmpTeamsDistributeParallelForSimdClause n2;
    if (jj_2_109(2147483647)) {
      n1 = OmpTargetClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case ORDERED:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COPYIN:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
      case NUMTEAMS:
      case THREADLIMIT:
      case DISTSCHEDULE:
        n2 = OmpTeamsDistributeParallelForSimdClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[144] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpTargetTeamsDistributeParallelForSimdClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetTeamsDistributeParallelForConstruct OmpTargetTeamsDistributeParallelForConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeOptional n11 = new NodeOptional();
   OmpTargetTeamsDistributeParallelForClauseList n12;
   OmpEol n13;
   OmpForHeader n14;
   Statement n15;
    n0 = OmpPragma();
    n2 = jj_consume_token(TARGET);
                 n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(TEAMS);
                n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(DISTRIBUTE);
                     n5 = JTBToolkit.makeNodeToken(n6);
    n8 = jj_consume_token(PARALLEL);
                   n7 = JTBToolkit.makeNodeToken(n8);
    n10 = jj_consume_token(FOR);
               n9 = JTBToolkit.makeNodeToken(n10);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case ORDERED:
    case NOWAIT:
    case SCHEDULE:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case COPYIN:
    case NUM_THREADS:
    case COLLAPSE:
    case PROC_BIND:
    case LINEAR:
    case DEPEND:
    case DEVICE:
    case MAP:
    case ISDEVICEPTR:
    case DEFAULTMAP:
    case NUMTEAMS:
    case THREADLIMIT:
    case DISTSCHEDULE:
      n12 = OmpTargetTeamsDistributeParallelForClauseList();
        n11.addNode(n12);
      break;
    default:
      jj_la1[145] = jj_gen;
      ;
    }
    n13 = OmpEol();
    n14 = OmpForHeader();
    n15 = Statement();
     {if (true) return new OmpTargetTeamsDistributeParallelForConstruct(n0,n1,n3,n5,n7,n9,n11,n13,n14,n15);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetTeamsDistributeParallelForClauseList OmpTargetTeamsDistributeParallelForClauseList() throws ParseException {
   OmpTargetTeamsDistributeParallelForClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTargetTeamsDistributeParallelForClause n6;
    n0 = OmpTargetTeamsDistributeParallelForClause();
    label_32:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case ORDERED:
      case NOWAIT:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COPYIN:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
      case DEPEND:
      case DEVICE:
      case MAP:
      case ISDEVICEPTR:
      case DEFAULTMAP:
      case NUMTEAMS:
      case THREADLIMIT:
      case DISTSCHEDULE:
        ;
        break;
      default:
        jj_la1[146] = jj_gen;
        break label_32;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[147] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTargetTeamsDistributeParallelForClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTargetTeamsDistributeParallelForClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetTeamsDistributeParallelForClause OmpTargetTeamsDistributeParallelForClause() throws ParseException {
   NodeChoice n0;
   OmpTargetClause n1;
   OmpTeamsDistributeParallelForClause n2;
    if (jj_2_110(2147483647)) {
      n1 = OmpTargetClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case ORDERED:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COPYIN:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
      case NUMTEAMS:
      case THREADLIMIT:
      case DISTSCHEDULE:
        n2 = OmpTeamsDistributeParallelForClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[148] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpTargetTeamsDistributeParallelForClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetTeamsDistributeSimdConstruct OmpTargetTeamsDistributeSimdConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeOptional n9 = new NodeOptional();
   OmpTargetTeamsDistributeSimdClauseList n10;
   OmpEol n11;
   OmpForHeader n12;
   Statement n13;
    n0 = OmpPragma();
    n2 = jj_consume_token(TARGET);
                 n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(TEAMS);
                n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(DISTRIBUTE);
                     n5 = JTBToolkit.makeNodeToken(n6);
    n8 = jj_consume_token(SIMD);
               n7 = JTBToolkit.makeNodeToken(n8);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case NOWAIT:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case COLLAPSE:
    case LINEAR:
    case SAFELEN:
    case SIMDLEN:
    case ALIGNED:
    case DEPEND:
    case DEVICE:
    case MAP:
    case ISDEVICEPTR:
    case DEFAULTMAP:
    case NUMTEAMS:
    case THREADLIMIT:
    case DISTSCHEDULE:
      n10 = OmpTargetTeamsDistributeSimdClauseList();
        n9.addNode(n10);
      break;
    default:
      jj_la1[149] = jj_gen;
      ;
    }
    n11 = OmpEol();
    n12 = OmpForHeader();
    n13 = Statement();
     {if (true) return new OmpTargetTeamsDistributeSimdConstruct(n0,n1,n3,n5,n7,n9,n11,n12,n13);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetTeamsDistributeSimdClauseList OmpTargetTeamsDistributeSimdClauseList() throws ParseException {
   OmpTargetTeamsDistributeSimdClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTargetTeamsDistributeSimdClause n6;
    n0 = OmpTargetTeamsDistributeSimdClause();
    label_33:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case NOWAIT:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COLLAPSE:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
      case DEPEND:
      case DEVICE:
      case MAP:
      case ISDEVICEPTR:
      case DEFAULTMAP:
      case NUMTEAMS:
      case THREADLIMIT:
      case DISTSCHEDULE:
        ;
        break;
      default:
        jj_la1[150] = jj_gen;
        break label_33;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[151] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTargetTeamsDistributeSimdClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTargetTeamsDistributeSimdClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetTeamsDistributeSimdClause OmpTargetTeamsDistributeSimdClause() throws ParseException {
   NodeChoice n0;
   OmpTargetClause n1;
   OmpTeamsDistributeSimdClause n2;
    if (jj_2_111(2147483647)) {
      n1 = OmpTargetClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COLLAPSE:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
      case NUMTEAMS:
      case THREADLIMIT:
      case DISTSCHEDULE:
        n2 = OmpTeamsDistributeSimdClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[152] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpTargetTeamsDistributeSimdClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetTeamsDistributeConstruct OmpTargetTeamsDistributeConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeOptional n7 = new NodeOptional();
   OmpTargetTeamsDistributeClauseList n8;
   OmpEol n9;
   OmpForHeader n10;
   Statement n11;
    n0 = OmpPragma();
    n2 = jj_consume_token(TARGET);
                 n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(TEAMS);
                n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(DISTRIBUTE);
                     n5 = JTBToolkit.makeNodeToken(n6);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case NOWAIT:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case COLLAPSE:
    case DEPEND:
    case DEVICE:
    case MAP:
    case ISDEVICEPTR:
    case DEFAULTMAP:
    case NUMTEAMS:
    case THREADLIMIT:
    case DISTSCHEDULE:
      n8 = OmpTargetTeamsDistributeClauseList();
        n7.addNode(n8);
      break;
    default:
      jj_la1[153] = jj_gen;
      ;
    }
    n9 = OmpEol();
    n10 = OmpForHeader();
    n11 = Statement();
     {if (true) return new OmpTargetTeamsDistributeConstruct(n0,n1,n3,n5,n7,n9,n10,n11);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetTeamsDistributeClauseList OmpTargetTeamsDistributeClauseList() throws ParseException {
   OmpTargetTeamsDistributeClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTargetTeamsDistributeClause n6;
    n0 = OmpTargetTeamsDistributeClause();
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case NOWAIT:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COLLAPSE:
      case DEPEND:
      case DEVICE:
      case MAP:
      case ISDEVICEPTR:
      case DEFAULTMAP:
      case NUMTEAMS:
      case THREADLIMIT:
      case DISTSCHEDULE:
        ;
        break;
      default:
        jj_la1[154] = jj_gen;
        break label_34;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[155] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTargetTeamsDistributeClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTargetTeamsDistributeClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetTeamsDistributeClause OmpTargetTeamsDistributeClause() throws ParseException {
   NodeChoice n0;
   OmpTargetClause n1;
   OmpTeamsDistributeClause n2;
    if (jj_2_112(2147483647)) {
      n1 = OmpTargetClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COLLAPSE:
      case NUMTEAMS:
      case THREADLIMIT:
      case DISTSCHEDULE:
        n2 = OmpTeamsDistributeClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[156] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpTargetTeamsDistributeClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetTeamsConstruct OmpTargetTeamsConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeOptional n5 = new NodeOptional();
   OmpTargetTeamsClauseList n6;
   OmpEol n7;
   Statement n8;
    n0 = OmpPragma();
    n2 = jj_consume_token(TARGET);
                 n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(TEAMS);
                n3 = JTBToolkit.makeNodeToken(n4);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case NOWAIT:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case SHARED:
    case DEPEND:
    case DEVICE:
    case MAP:
    case ISDEVICEPTR:
    case DEFAULTMAP:
    case NUMTEAMS:
    case THREADLIMIT:
      n6 = OmpTargetTeamsClauseList();
        n5.addNode(n6);
      break;
    default:
      jj_la1[157] = jj_gen;
      ;
    }
    n7 = OmpEol();
    n8 = Statement();
     {if (true) return new OmpTargetTeamsConstruct(n0,n1,n3,n5,n7,n8);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetTeamsClauseList OmpTargetTeamsClauseList() throws ParseException {
   OmpTargetTeamsClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTargetTeamsClause n6;
    n0 = OmpTargetTeamsClause();
    label_35:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case NOWAIT:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case SHARED:
      case DEPEND:
      case DEVICE:
      case MAP:
      case ISDEVICEPTR:
      case DEFAULTMAP:
      case NUMTEAMS:
      case THREADLIMIT:
        ;
        break;
      default:
        jj_la1[158] = jj_gen;
        break label_35;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[159] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTargetTeamsClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTargetTeamsClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetTeamsClause OmpTargetTeamsClause() throws ParseException {
   NodeChoice n0;
   OmpTargetClause n1;
   OmpTeamsClause n2;
    if (jj_2_113(2147483647)) {
      n1 = OmpTargetClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case SHARED:
      case NUMTEAMS:
      case THREADLIMIT:
        n2 = OmpTeamsClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[160] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpTargetTeamsClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetConstruct OmpTargetConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeOptional n3 = new NodeOptional();
   OmpTargetClauseList n4;
   OmpEol n5;
   Statement n6;
    n0 = OmpPragma();
    n2 = jj_consume_token(TARGET);
                 n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
    case NOWAIT:
    case PRIVATE:
    case FIRSTPRIVATE:
    case DEPEND:
    case DEVICE:
    case MAP:
    case ISDEVICEPTR:
    case DEFAULTMAP:
      n4 = OmpTargetClauseList();
        n3.addNode(n4);
      break;
    default:
      jj_la1[161] = jj_gen;
      ;
    }
    n5 = OmpEol();
    n6 = Statement();
     {if (true) return new OmpTargetConstruct(n0,n1,n3,n5,n6);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetClauseList OmpTargetClauseList() throws ParseException {
   OmpTargetClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTargetClause n6;
    n0 = OmpTargetClause();
    label_36:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case COMMA:
      case NOWAIT:
      case PRIVATE:
      case FIRSTPRIVATE:
      case DEPEND:
      case DEVICE:
      case MAP:
      case ISDEVICEPTR:
      case DEFAULTMAP:
        ;
        break;
      default:
        jj_la1[162] = jj_gen;
        break label_36;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[163] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTargetClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTargetClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetClause OmpTargetClause() throws ParseException {
   NodeChoice n0;
   OmpIfTargetClause n1;
   OmpDeviceClause n2;
   OmpPrivateClause n3;
   OmpFirstPrivateClause n4;
   OmpMapClause n5;
   OmpIsDevicePtrListClause n6;
   OmpDefaultMapClause n7;
   OmpNowaitClause n8;
   OmpDependClause n9;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      n1 = OmpIfTargetClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case DEVICE:
      n2 = OmpDeviceClause();
        n0 = new NodeChoice(n2, 1);
      break;
    case PRIVATE:
      n3 = OmpPrivateClause();
        n0 = new NodeChoice(n3, 2);
      break;
    case FIRSTPRIVATE:
      n4 = OmpFirstPrivateClause();
        n0 = new NodeChoice(n4, 3);
      break;
    case MAP:
      n5 = OmpMapClause();
        n0 = new NodeChoice(n5, 4);
      break;
    case ISDEVICEPTR:
      n6 = OmpIsDevicePtrListClause();
        n0 = new NodeChoice(n6, 5);
      break;
    case DEFAULTMAP:
      n7 = OmpDefaultMapClause();
        n0 = new NodeChoice(n7, 6);
      break;
    case NOWAIT:
      n8 = OmpNowaitClause();
        n0 = new NodeChoice(n8, 7);
      break;
    case DEPEND:
      n9 = OmpDependClause();
        n0 = new NodeChoice(n9, 8);
      break;
    default:
      jj_la1[164] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OmpTargetClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpIfTargetClause OmpIfTargetClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeOptional n4 = new NodeOptional();
   NodeSequence n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   Expression n10;
   NodeToken n11;
   Token n12;
    n1 = jj_consume_token(IF);
             n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TARGET:
        n5 = new NodeSequence(2);
      n7 = jj_consume_token(TARGET);
                    n6 = JTBToolkit.makeNodeToken(n7);
        n5.addNode(n6);
      n9 = jj_consume_token(COLON);
                   n8 = JTBToolkit.makeNodeToken(n9);
        n5.addNode(n8);
        n4.addNode(n5);
      break;
    default:
      jj_la1[165] = jj_gen;
      ;
    }
    n10 = Expression();
    n12 = jj_consume_token(RIGHTPAREN);
             n11 = JTBToolkit.makeNodeToken(n12);
     {if (true) return new OmpIfTargetClause(n0,n2,n4,n10,n11);}
    throw new Error("Missing return statement in function");
  }

  final public OmpIsDevicePtrListClause OmpIsDevicePtrListClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   VariableList n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(ISDEVICEPTR);
                      n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = VariableList();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpIsDevicePtrListClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDefaultMapClause OmpDefaultMapClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
    n1 = jj_consume_token(DEFAULTMAP);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(TOFROM);
                 n4 = JTBToolkit.makeNodeToken(n5);
    n7 = jj_consume_token(COLON);
                n6 = JTBToolkit.makeNodeToken(n7);
    n9 = jj_consume_token(SCALAR);
                 n8 = JTBToolkit.makeNodeToken(n9);
    n11 = jj_consume_token(RIGHTPAREN);
             n10 = JTBToolkit.makeNodeToken(n11);
     {if (true) return new OmpDefaultMapClause(n0,n2,n4,n6,n8,n10);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTeamsDistributeParallelForSimdConstruct OmpTeamsDistributeParallelForSimdConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeOptional n11 = new NodeOptional();
   OmpTeamsDistributeParallelForSimdClauseList n12;
   OmpEol n13;
   OmpForHeader n14;
   Statement n15;
    n0 = OmpPragma();
    n2 = jj_consume_token(TEAMS);
                n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(DISTRIBUTE);
                     n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(PARALLEL);
                   n5 = JTBToolkit.makeNodeToken(n6);
    n8 = jj_consume_token(FOR);
              n7 = JTBToolkit.makeNodeToken(n8);
    n10 = jj_consume_token(SIMD);
                n9 = JTBToolkit.makeNodeToken(n10);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case ORDERED:
    case SCHEDULE:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case COPYIN:
    case NUM_THREADS:
    case COLLAPSE:
    case PROC_BIND:
    case LINEAR:
    case SAFELEN:
    case SIMDLEN:
    case ALIGNED:
    case NUMTEAMS:
    case THREADLIMIT:
    case DISTSCHEDULE:
      n12 = OmpTeamsDistributeParallelForSimdClauseList();
        n11.addNode(n12);
      break;
    default:
      jj_la1[166] = jj_gen;
      ;
    }
    n13 = OmpEol();
    n14 = OmpForHeader();
    n15 = Statement();
     {if (true) return new OmpTeamsDistributeParallelForSimdConstruct(n0,n1,n3,n5,n7,n9,n11,n13,n14,n15);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTeamsDistributeParallelForSimdClauseList OmpTeamsDistributeParallelForSimdClauseList() throws ParseException {
   OmpTeamsDistributeParallelForSimdClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTeamsDistributeParallelForSimdClause n6;
    n0 = OmpTeamsDistributeParallelForSimdClause();
    label_37:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case ORDERED:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COPYIN:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
      case NUMTEAMS:
      case THREADLIMIT:
      case DISTSCHEDULE:
        ;
        break;
      default:
        jj_la1[167] = jj_gen;
        break label_37;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[168] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTeamsDistributeParallelForSimdClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTeamsDistributeParallelForSimdClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTeamsDistributeParallelForSimdClause OmpTeamsDistributeParallelForSimdClause() throws ParseException {
   NodeChoice n0;
   OmpTeamsClause n1;
   OmpDistributeParallelForSimdClause n2;
    if (jj_2_114(2147483647)) {
      n1 = OmpTeamsClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case ORDERED:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COPYIN:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
      case DISTSCHEDULE:
        n2 = OmpDistributeParallelForSimdClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[169] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpTeamsDistributeParallelForSimdClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTeamsDistributeParallelForConstruct OmpTeamsDistributeParallelForConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeOptional n9 = new NodeOptional();
   OmpTeamsDistributeParallelForClauseList n10;
   OmpEol n11;
   OmpForHeader n12;
   Statement n13;
    n0 = OmpPragma();
    n2 = jj_consume_token(TEAMS);
                n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(DISTRIBUTE);
                     n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(PARALLEL);
                   n5 = JTBToolkit.makeNodeToken(n6);
    n8 = jj_consume_token(FOR);
              n7 = JTBToolkit.makeNodeToken(n8);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case ORDERED:
    case SCHEDULE:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case COPYIN:
    case NUM_THREADS:
    case COLLAPSE:
    case PROC_BIND:
    case LINEAR:
    case NUMTEAMS:
    case THREADLIMIT:
    case DISTSCHEDULE:
      n10 = OmpTeamsDistributeParallelForClauseList();
        n9.addNode(n10);
      break;
    default:
      jj_la1[170] = jj_gen;
      ;
    }
    n11 = OmpEol();
    n12 = OmpForHeader();
    n13 = Statement();
     {if (true) return new OmpTeamsDistributeParallelForConstruct(n0,n1,n3,n5,n7,n9,n11,n12,n13);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTeamsDistributeParallelForClauseList OmpTeamsDistributeParallelForClauseList() throws ParseException {
   OmpTeamsDistributeParallelForClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTeamsDistributeParallelForClause n6;
    n0 = OmpTeamsDistributeParallelForClause();
    label_38:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case ORDERED:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COPYIN:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
      case NUMTEAMS:
      case THREADLIMIT:
      case DISTSCHEDULE:
        ;
        break;
      default:
        jj_la1[171] = jj_gen;
        break label_38;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[172] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTeamsDistributeParallelForClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTeamsDistributeParallelForClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTeamsDistributeParallelForClause OmpTeamsDistributeParallelForClause() throws ParseException {
   NodeChoice n0;
   OmpTeamsClause n1;
   OmpDistributeParallelForClause n2;
    if (jj_2_115(2147483647)) {
      n1 = OmpTeamsClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case ORDERED:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COPYIN:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
      case DISTSCHEDULE:
        n2 = OmpDistributeParallelForClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[173] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpTeamsDistributeParallelForClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTeamsDistributeSimdConstruct OmpTeamsDistributeSimdConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeOptional n7 = new NodeOptional();
   OmpTeamsDistributeSimdClauseList n8;
   OmpEol n9;
   OmpForHeader n10;
   Statement n11;
    n0 = OmpPragma();
    n2 = jj_consume_token(TEAMS);
                n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(DISTRIBUTE);
                     n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(SIMD);
               n5 = JTBToolkit.makeNodeToken(n6);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case COLLAPSE:
    case LINEAR:
    case SAFELEN:
    case SIMDLEN:
    case ALIGNED:
    case NUMTEAMS:
    case THREADLIMIT:
    case DISTSCHEDULE:
      n8 = OmpTeamsDistributeSimdClauseList();
        n7.addNode(n8);
      break;
    default:
      jj_la1[174] = jj_gen;
      ;
    }
    n9 = OmpEol();
    n10 = OmpForHeader();
    n11 = Statement();
     {if (true) return new OmpTeamsDistributeSimdConstruct(n0,n1,n3,n5,n7,n9,n10,n11);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTeamsDistributeSimdClauseList OmpTeamsDistributeSimdClauseList() throws ParseException {
   OmpTeamsDistributeSimdClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTeamsDistributeSimdClause n6;
    n0 = OmpTeamsDistributeSimdClause();
    label_39:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case COMMA:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COLLAPSE:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
      case NUMTEAMS:
      case THREADLIMIT:
      case DISTSCHEDULE:
        ;
        break;
      default:
        jj_la1[175] = jj_gen;
        break label_39;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[176] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTeamsDistributeSimdClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTeamsDistributeSimdClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTeamsDistributeSimdClause OmpTeamsDistributeSimdClause() throws ParseException {
   NodeChoice n0;
   OmpTeamsClause n1;
   OmpDistributeSimdClause n2;
    if (jj_2_116(2147483647)) {
      n1 = OmpTeamsClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case COLLAPSE:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
      case DISTSCHEDULE:
        n2 = OmpDistributeSimdClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[177] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpTeamsDistributeSimdClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTeamsDistributeConstruct OmpTeamsDistributeConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeOptional n5 = new NodeOptional();
   OmpTeamsDistributeClauseList n6;
   OmpEol n7;
   OmpForHeader n8;
   Statement n9;
    n0 = OmpPragma();
    n2 = jj_consume_token(TEAMS);
                n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(DISTRIBUTE);
                     n3 = JTBToolkit.makeNodeToken(n4);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case COLLAPSE:
    case NUMTEAMS:
    case THREADLIMIT:
    case DISTSCHEDULE:
      n6 = OmpTeamsDistributeClauseList();
        n5.addNode(n6);
      break;
    default:
      jj_la1[178] = jj_gen;
      ;
    }
    n7 = OmpEol();
    n8 = OmpForHeader();
    n9 = Statement();
     {if (true) return new OmpTeamsDistributeConstruct(n0,n1,n3,n5,n7,n8,n9);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTeamsDistributeClauseList OmpTeamsDistributeClauseList() throws ParseException {
   OmpTeamsDistributeClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTeamsDistributeClause n6;
    n0 = OmpTeamsDistributeClause();
    label_40:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case COMMA:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COLLAPSE:
      case NUMTEAMS:
      case THREADLIMIT:
      case DISTSCHEDULE:
        ;
        break;
      default:
        jj_la1[179] = jj_gen;
        break label_40;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[180] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTeamsDistributeClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTeamsDistributeClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTeamsDistributeClause OmpTeamsDistributeClause() throws ParseException {
   NodeChoice n0;
   OmpTeamsClause n1;
   OmpDistributeClause n2;
    if (jj_2_117(2147483647)) {
      n1 = OmpTeamsClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case COLLAPSE:
      case DISTSCHEDULE:
        n2 = OmpDistributeClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[181] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpTeamsDistributeClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTeamsConstruct OmpTeamsConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeOptional n3 = new NodeOptional();
   OmpTeamsClauseList n4;
   OmpEol n5;
   Statement n6;
    n0 = OmpPragma();
    n2 = jj_consume_token(TEAMS);
                n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case SHARED:
    case NUMTEAMS:
    case THREADLIMIT:
      n4 = OmpTeamsClauseList();
        n3.addNode(n4);
      break;
    default:
      jj_la1[182] = jj_gen;
      ;
    }
    n5 = OmpEol();
    n6 = Statement();
     {if (true) return new OmpTeamsConstruct(n0,n1,n3,n5,n6);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTeamsClauseList OmpTeamsClauseList() throws ParseException {
   OmpTeamsClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTeamsClause n6;
    n0 = OmpTeamsClause();
    label_41:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case COMMA:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case SHARED:
      case NUMTEAMS:
      case THREADLIMIT:
        ;
        break;
      default:
        jj_la1[183] = jj_gen;
        break label_41;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[184] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTeamsClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTeamsClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTeamsClause OmpTeamsClause() throws ParseException {
   NodeChoice n0;
   OmpNumTeamsClause n1;
   OmpThreadLimitClause n2;
   OmpDfltSharedClause n3;
   OmpDfltNoneClause n4;
   OmpPrivateClause n5;
   OmpFirstPrivateClause n6;
   OmpSharedClause n7;
   OmpReductionClause n8;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMTEAMS:
      n1 = OmpNumTeamsClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case THREADLIMIT:
      n2 = OmpThreadLimitClause();
        n0 = new NodeChoice(n2, 1);
      break;
    default:
      jj_la1[185] = jj_gen;
      if (jj_2_118(3)) {
        n3 = OmpDfltSharedClause();
        n0 = new NodeChoice(n3, 2);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DFLT:
          n4 = OmpDfltNoneClause();
        n0 = new NodeChoice(n4, 3);
          break;
        case PRIVATE:
          n5 = OmpPrivateClause();
        n0 = new NodeChoice(n5, 4);
          break;
        case FIRSTPRIVATE:
          n6 = OmpFirstPrivateClause();
        n0 = new NodeChoice(n6, 5);
          break;
        case SHARED:
          n7 = OmpSharedClause();
        n0 = new NodeChoice(n7, 6);
          break;
        case REDUCTION:
          n8 = OmpReductionClause();
        n0 = new NodeChoice(n8, 7);
          break;
        default:
          jj_la1[186] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
     {if (true) return new OmpTeamsClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpNumTeamsClause OmpNumTeamsClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(NUMTEAMS);
                   n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpNumTeamsClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpThreadLimitClause OmpThreadLimitClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(THREADLIMIT);
                      n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpThreadLimitClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDistributeSimdConstruct OmpDistributeSimdConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeOptional n5 = new NodeOptional();
   OmpDistributeSimdClauseList n6;
   OmpEol n7;
   OmpForHeader n8;
   Statement n9;
    n0 = OmpPragma();
    n2 = jj_consume_token(DISTRIBUTE);
                     n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(SIMD);
               n3 = JTBToolkit.makeNodeToken(n4);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case COLLAPSE:
    case LINEAR:
    case SAFELEN:
    case SIMDLEN:
    case ALIGNED:
    case DISTSCHEDULE:
      n6 = OmpDistributeSimdClauseList();
        n5.addNode(n6);
      break;
    default:
      jj_la1[187] = jj_gen;
      ;
    }
    n7 = OmpEol();
    n8 = OmpForHeader();
    n9 = Statement();
     {if (true) return new OmpDistributeSimdConstruct(n0,n1,n3,n5,n7,n8,n9);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDistributeSimdClauseList OmpDistributeSimdClauseList() throws ParseException {
   OmpDistributeSimdClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpDistributeSimdClause n6;
    n0 = OmpDistributeSimdClause();
    label_42:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case COLLAPSE:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
      case DISTSCHEDULE:
        ;
        break;
      default:
        jj_la1[188] = jj_gen;
        break label_42;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[189] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpDistributeSimdClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpDistributeSimdClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDistributeSimdClause OmpDistributeSimdClause() throws ParseException {
   NodeChoice n0;
   OmpDistributeClause n1;
   OmpSimdClause n2;
    if (jj_2_119(2147483647)) {
      n1 = OmpDistributeClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REDUCTION:
      case PRIVATE:
      case LASTPRIVATE:
      case COLLAPSE:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
        n2 = OmpSimdClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[190] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpDistributeSimdClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDistributeParallelForSimdConstruct OmpDistributeParallelForSimdConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeOptional n9 = new NodeOptional();
   OmpDistributeParallelForSimdClauseList n10;
   OmpEol n11;
   OmpForHeader n12;
   Statement n13;
    n0 = OmpPragma();
    n2 = jj_consume_token(DISTRIBUTE);
                     n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(PARALLEL);
                   n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(FOR);
              n5 = JTBToolkit.makeNodeToken(n6);
    n8 = jj_consume_token(SIMD);
               n7 = JTBToolkit.makeNodeToken(n8);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case ORDERED:
    case SCHEDULE:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case COPYIN:
    case NUM_THREADS:
    case COLLAPSE:
    case PROC_BIND:
    case LINEAR:
    case SAFELEN:
    case SIMDLEN:
    case ALIGNED:
    case DISTSCHEDULE:
      n10 = OmpDistributeParallelForSimdClauseList();
        n9.addNode(n10);
      break;
    default:
      jj_la1[191] = jj_gen;
      ;
    }
    n11 = OmpEol();
    n12 = OmpForHeader();
    n13 = Statement();
     {if (true) return new OmpDistributeParallelForSimdConstruct(n0,n1,n3,n5,n7,n9,n11,n12,n13);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDistributeParallelForSimdClauseList OmpDistributeParallelForSimdClauseList() throws ParseException {
   OmpDistributeParallelForSimdClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpDistributeParallelForSimdClause n6;
    n0 = OmpDistributeParallelForSimdClause();
    label_43:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case ORDERED:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COPYIN:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
      case DISTSCHEDULE:
        ;
        break;
      default:
        jj_la1[192] = jj_gen;
        break label_43;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[193] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpDistributeParallelForSimdClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpDistributeParallelForSimdClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDistributeParallelForSimdClause OmpDistributeParallelForSimdClause() throws ParseException {
   NodeChoice n0;
   OmpDistributeClause n1;
   OmpParallelForSimdClause n2;
    if (jj_2_120(2147483647)) {
      n1 = OmpDistributeClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case ORDERED:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COPYIN:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
        n2 = OmpParallelForSimdClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[194] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpDistributeParallelForSimdClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDistributeParallelForConstruct OmpDistributeParallelForConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeOptional n7 = new NodeOptional();
   OmpDistributeParallelForClauseList n8;
   OmpEol n9;
   OmpForHeader n10;
   Statement n11;
    n0 = OmpPragma();
    n2 = jj_consume_token(DISTRIBUTE);
                     n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(PARALLEL);
                   n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(FOR);
              n5 = JTBToolkit.makeNodeToken(n6);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case ORDERED:
    case SCHEDULE:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case COPYIN:
    case NUM_THREADS:
    case COLLAPSE:
    case PROC_BIND:
    case LINEAR:
    case DISTSCHEDULE:
      n8 = OmpDistributeParallelForClauseList();
        n7.addNode(n8);
      break;
    default:
      jj_la1[195] = jj_gen;
      ;
    }
    n9 = OmpEol();
    n10 = OmpForHeader();
    n11 = Statement();
     {if (true) return new OmpDistributeParallelForConstruct(n0,n1,n3,n5,n7,n9,n10,n11);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDistributeParallelForClauseList OmpDistributeParallelForClauseList() throws ParseException {
   OmpDistributeParallelForClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpDistributeParallelForClause n6;
    n0 = OmpDistributeParallelForClause();
    label_44:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case ORDERED:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COPYIN:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
      case DISTSCHEDULE:
        ;
        break;
      default:
        jj_la1[196] = jj_gen;
        break label_44;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[197] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpDistributeParallelForClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpDistributeParallelForClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDistributeParallelForClause OmpDistributeParallelForClause() throws ParseException {
   NodeChoice n0;
   OmpDistributeClause n1;
   OmpParallelForClause n2;
    if (jj_2_121(2147483647)) {
      n1 = OmpDistributeClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case ORDERED:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COPYIN:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
        n2 = OmpParallelForClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[198] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpDistributeParallelForClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDistributeConstruct OmpDistributeConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeOptional n3 = new NodeOptional();
   OmpDistributeClauseList n4;
   OmpEol n5;
   OmpForHeader n6;
   Statement n7;
    n0 = OmpPragma();
    n2 = jj_consume_token(DISTRIBUTE);
                     n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case COLLAPSE:
    case DISTSCHEDULE:
      n4 = OmpDistributeClauseList();
        n3.addNode(n4);
      break;
    default:
      jj_la1[199] = jj_gen;
      ;
    }
    n5 = OmpEol();
    n6 = OmpForHeader();
    n7 = Statement();
     {if (true) return new OmpDistributeConstruct(n0,n1,n3,n5,n6,n7);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDistributeClauseList OmpDistributeClauseList() throws ParseException {
   OmpDistributeClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpDistributeClause n6;
    n0 = OmpDistributeClause();
    label_45:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case COLLAPSE:
      case DISTSCHEDULE:
        ;
        break;
      default:
        jj_la1[200] = jj_gen;
        break label_45;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[201] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpDistributeClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpDistributeClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDistributeClause OmpDistributeClause() throws ParseException {
   NodeChoice n0;
   OmpPrivateClause n1;
   OmpFirstPrivateClause n2;
   OmpLastPrivateClause n3;
   OmpCollapseClause n4;
   OmpDistScheduleClause n5;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIVATE:
      n1 = OmpPrivateClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case FIRSTPRIVATE:
      n2 = OmpFirstPrivateClause();
        n0 = new NodeChoice(n2, 1);
      break;
    case LASTPRIVATE:
      n3 = OmpLastPrivateClause();
        n0 = new NodeChoice(n3, 2);
      break;
    case COLLAPSE:
      n4 = OmpCollapseClause();
        n0 = new NodeChoice(n4, 3);
      break;
    case DISTSCHEDULE:
      n5 = OmpDistScheduleClause();
        n0 = new NodeChoice(n5, 4);
      break;
    default:
      jj_la1[202] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OmpDistributeClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDistScheduleClause OmpDistScheduleClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   ScheduleKind n4;
   NodeOptional n5 = new NodeOptional();
   NodeSequence n6;
   NodeToken n7;
   Token n8;
   Expression n9;
   NodeToken n10;
   Token n11;
    n1 = jj_consume_token(DISTSCHEDULE);
                       n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = ScheduleKind();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
        n6 = new NodeSequence(2);
      n8 = jj_consume_token(COMMA);
               n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
      n9 = Expression();
        n6.addNode(n9);
        n5.addNode(n6);
      break;
    default:
      jj_la1[203] = jj_gen;
      ;
    }
    n11 = jj_consume_token(RIGHTPAREN);
             n10 = JTBToolkit.makeNodeToken(n11);
     {if (true) return new OmpDistScheduleClause(n0,n2,n4,n5,n10);}
    throw new Error("Missing return statement in function");
  }

  final public OmpParallelForSimdConstruct OmpParallelForSimdConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeOptional n7 = new NodeOptional();
   OmpParallelForSimdClauseList n8;
   OmpEol n9;
   OmpForHeader n10;
   Statement n11;
    n0 = OmpPragma();
    n2 = jj_consume_token(PARALLEL);
                   n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(FOR);
              n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(SIMD);
               n5 = JTBToolkit.makeNodeToken(n6);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case ORDERED:
    case SCHEDULE:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case COPYIN:
    case NUM_THREADS:
    case COLLAPSE:
    case PROC_BIND:
    case LINEAR:
    case SAFELEN:
    case SIMDLEN:
    case ALIGNED:
      n8 = OmpParallelForSimdClauseList();
        n7.addNode(n8);
      break;
    default:
      jj_la1[204] = jj_gen;
      ;
    }
    n9 = OmpEol();
    n10 = OmpForHeader();
    n11 = Statement();
     {if (true) return new OmpParallelForSimdConstruct(n0,n1,n3,n5,n7,n9,n10,n11);}
    throw new Error("Missing return statement in function");
  }

  final public OmpParallelForSimdClauseList OmpParallelForSimdClauseList() throws ParseException {
   OmpParallelForSimdClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpParallelForSimdClause n6;
    n0 = OmpParallelForSimdClause();
    label_46:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case ORDERED:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COPYIN:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
      case SAFELEN:
      case SIMDLEN:
      case ALIGNED:
        ;
        break;
      default:
        jj_la1[205] = jj_gen;
        break label_46;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[206] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpParallelForSimdClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpParallelForSimdClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpParallelForSimdClause OmpParallelForSimdClause() throws ParseException {
   NodeChoice n0;
   OmpParallelClause n1;
   OmpSimdClause n2;
   OmpLastPrivateClause n3;
   OmpLinearClause n4;
   OmpScheduleClause n5;
   OmpCollapseClause n6;
   OmpOrderedClause n7;
    if (jj_2_122(2147483647)) {
      n1 = OmpParallelClause();
        n0 = new NodeChoice(n1, 0);
    } else if (jj_2_123(2147483647)) {
      n2 = OmpSimdClause();
        n0 = new NodeChoice(n2, 1);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LASTPRIVATE:
        n3 = OmpLastPrivateClause();
        n0 = new NodeChoice(n3, 2);
        break;
      case LINEAR:
        n4 = OmpLinearClause();
        n0 = new NodeChoice(n4, 3);
        break;
      case SCHEDULE:
        n5 = OmpScheduleClause();
        n0 = new NodeChoice(n5, 4);
        break;
      case COLLAPSE:
        n6 = OmpCollapseClause();
        n0 = new NodeChoice(n6, 5);
        break;
      case ORDERED:
        n7 = OmpOrderedClause();
        n0 = new NodeChoice(n7, 6);
        break;
      default:
        jj_la1[207] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpParallelForSimdClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpParallelForConstruct OmpParallelForConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeOptional n5 = new NodeOptional();
   OmpParallelForClauseList n6;
   OmpEol n7;
   OmpForHeader n8;
   Statement n9;
    n0 = OmpPragma();
    n2 = jj_consume_token(PARALLEL);
                   n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(FOR);
              n3 = JTBToolkit.makeNodeToken(n4);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case ORDERED:
    case SCHEDULE:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case COPYIN:
    case NUM_THREADS:
    case COLLAPSE:
    case PROC_BIND:
    case LINEAR:
      n6 = OmpParallelForClauseList();
        n5.addNode(n6);
      break;
    default:
      jj_la1[208] = jj_gen;
      ;
    }
    n7 = OmpEol();
    n8 = OmpForHeader();
    n9 = Statement();
     {if (true) return new OmpParallelForConstruct(n0,n1,n3,n5,n7,n8,n9);}
    throw new Error("Missing return statement in function");
  }

  final public OmpParallelForClauseList OmpParallelForClauseList() throws ParseException {
   OmpParallelForClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpParallelForClause n6;
    n0 = OmpParallelForClause();
    label_47:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
      case IF:
      case COMMA:
      case ORDERED:
      case SCHEDULE:
      case REDUCTION:
      case PRIVATE:
      case FIRSTPRIVATE:
      case LASTPRIVATE:
      case SHARED:
      case COPYIN:
      case NUM_THREADS:
      case COLLAPSE:
      case PROC_BIND:
      case LINEAR:
        ;
        break;
      default:
        jj_la1[209] = jj_gen;
        break label_47;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[210] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpParallelForClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpParallelForClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpParallelForClause OmpParallelForClause() throws ParseException {
   NodeChoice n0;
   OmpParallelClause n1;
   OmpLastPrivateClause n2;
   OmpLinearClause n3;
   OmpScheduleClause n4;
   OmpCollapseClause n5;
   OmpOrderedClause n6;
    if (jj_2_124(2147483647)) {
      n1 = OmpParallelClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LASTPRIVATE:
        n2 = OmpLastPrivateClause();
        n0 = new NodeChoice(n2, 1);
        break;
      case LINEAR:
        n3 = OmpLinearClause();
        n0 = new NodeChoice(n3, 2);
        break;
      case SCHEDULE:
        n4 = OmpScheduleClause();
        n0 = new NodeChoice(n4, 3);
        break;
      case COLLAPSE:
        n5 = OmpCollapseClause();
        n0 = new NodeChoice(n5, 4);
        break;
      case ORDERED:
        n6 = OmpOrderedClause();
        n0 = new NodeChoice(n6, 5);
        break;
      default:
        jj_la1[211] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpParallelForClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpParallelSectionsConstruct OmpParallelSectionsConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeOptional n5 = new NodeOptional();
   OmpParallelSectionsClauseList n6;
   OmpEol n7;
   SectionsScope n8;
    n0 = OmpPragma();
    n2 = jj_consume_token(PARALLEL);
                   n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(SECTIONS);
                   n3 = JTBToolkit.makeNodeToken(n4);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFLT:
    case IF:
    case REDUCTION:
    case PRIVATE:
    case FIRSTPRIVATE:
    case LASTPRIVATE:
    case SHARED:
    case COPYIN:
    case NUM_THREADS:
    case PROC_BIND:
      n6 = OmpParallelSectionsClauseList();
        n5.addNode(n6);
      break;
    default:
      jj_la1[212] = jj_gen;
      ;
    }
    n7 = OmpEol();
    n8 = SectionsScope();
     {if (true) return new OmpParallelSectionsConstruct(n0,n1,n3,n5,n7,n8);}
    throw new Error("Missing return statement in function");
  }

  final public OmpParallelSectionsClauseList OmpParallelSectionsClauseList() throws ParseException {
   NodeChoice n0;
   OmpParallelClause n1;
   OmpLastPrivateClause n2;
    if (jj_2_125(2147483647)) {
      n1 = OmpParallelClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LASTPRIVATE:
        n2 = OmpLastPrivateClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[213] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpParallelSectionsClauseList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpMasterConstruct OmpMasterConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   OmpEol n3;
   Statement n4;
    n0 = OmpPragma();
    n2 = jj_consume_token(MASTER);
                 n1 = JTBToolkit.makeNodeToken(n2);
    n3 = OmpEol();
    n4 = Statement();
     {if (true) return new OmpMasterConstruct(n0,n1,n3,n4);}
    throw new Error("Missing return statement in function");
  }

  final public OmpCriticalConstruct OmpCriticalConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeOptional n3 = new NodeOptional();
   NodeSequence n4;
   NodeToken n5;
   Token n6;
   OmpCriticalName n7;
   NodeToken n8;
   Token n9;
   NodeOptional n10;
   NodeSequence n11;
   NodeToken n12;
   Token n13;
   NodeToken n14;
   Token n15;
   Expression n16;
   NodeToken n17;
   Token n18;
   OmpEol n19;
   Statement n20;
    n0 = OmpPragma();
    n2 = jj_consume_token(CRITICAL);
                   n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFTPAREN:
        n10 = new NodeOptional();
        n4 = new NodeSequence(4);
      n6 = jj_consume_token(LEFTPAREN);
               n5 = JTBToolkit.makeNodeToken(n6);
        n4.addNode(n5);
      n7 = OmpCriticalName();
        n4.addNode(n7);
      n9 = jj_consume_token(RIGHTPAREN);
               n8 = JTBToolkit.makeNodeToken(n9);
        n4.addNode(n8);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case HINT:
           n11 = new NodeSequence(4);
        n13 = jj_consume_token(HINT);
                      n12 = JTBToolkit.makeNodeToken(n13);
           n11.addNode(n12);
        n15 = jj_consume_token(LEFTPAREN);
                   n14 = JTBToolkit.makeNodeToken(n15);
           n11.addNode(n14);
        n16 = Expression();
           n11.addNode(n16);
        n18 = jj_consume_token(RIGHTPAREN);
                   n17 = JTBToolkit.makeNodeToken(n18);
           n11.addNode(n17);
           n10.addNode(n11);
        break;
      default:
        jj_la1[214] = jj_gen;
        ;
      }
        n4.addNode(n10);
        n3.addNode(n4);
      break;
    default:
      jj_la1[215] = jj_gen;
      ;
    }
    n19 = OmpEol();
    n20 = Statement();
     {if (true) return new OmpCriticalConstruct(n0,n1,n3,n19,n20);}
    throw new Error("Missing return statement in function");
  }

  final public OmpCriticalName OmpCriticalName() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(LEFTPAREN);
            n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(IDENTIFIER);
                     n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(RIGHTPAREN);
            n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new OmpCriticalName(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTaskGroupConstruct OmpTaskGroupConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   OmpEol n3;
   Statement n4;
    n0 = OmpPragma();
    n2 = jj_consume_token(TASKGROUP);
                    n1 = JTBToolkit.makeNodeToken(n2);
    n3 = OmpEol();
    n4 = Statement();
     {if (true) return new OmpTaskGroupConstruct(n0,n1,n3,n4);}
    throw new Error("Missing return statement in function");
  }

  final public OmpAtomicConstruct OmpAtomicConstruct() throws ParseException {
   NodeChoice n0;
   OmpAtomicDefaultConstruct n1;
   OmpAtomicClauseConstruct n2;
    if (jj_2_126(2147483647)) {
      n1 = OmpAtomicDefaultConstruct();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CROSSBAR:
        n2 = OmpAtomicClauseConstruct();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[216] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpAtomicConstruct(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpAtomicDefaultConstruct OmpAtomicDefaultConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeOptional n3 = new NodeOptional();
   NodeSequence n4;
   NodeToken n5;
   Token n6;
   NodeOptional n7;
   NodeToken n8;
   Token n9;
   OmpEol n10;
   Statement n11;
    n0 = OmpPragma();
    n2 = jj_consume_token(ATOMIC);
                 n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEQCST:
        n7 = new NodeOptional();
        n4 = new NodeSequence(2);
      n6 = jj_consume_token(SEQCST);
                    n5 = JTBToolkit.makeNodeToken(n6);
        n4.addNode(n5);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n9 = jj_consume_token(COMMA);
                  n8 = JTBToolkit.makeNodeToken(n9);
           n7.addNode(n8);
        break;
      default:
        jj_la1[217] = jj_gen;
        ;
      }
        n4.addNode(n7);
        n3.addNode(n4);
      break;
    default:
      jj_la1[218] = jj_gen;
      ;
    }
    n10 = OmpEol();
    n11 = Statement();
     {if (true) return new OmpAtomicDefaultConstruct(n0,n1,n3,n10,n11);}
    throw new Error("Missing return statement in function");
  }

  final public OmpAtomicClauseConstruct OmpAtomicClauseConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeOptional n3 = new NodeOptional();
   NodeSequence n4;
   NodeToken n5;
   Token n6;
   NodeOptional n7;
   NodeToken n8;
   Token n9;
   AtomicClause n10;
   NodeOptional n11 = new NodeOptional();
   NodeSequence n12;
   NodeToken n13;
   Token n14;
   NodeOptional n15;
   NodeToken n16;
   Token n17;
   OmpEol n18;
   Statement n19;
    n0 = OmpPragma();
    n2 = jj_consume_token(ATOMIC);
                 n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEQCST:
        n7 = new NodeOptional();
        n4 = new NodeSequence(2);
      n6 = jj_consume_token(SEQCST);
                    n5 = JTBToolkit.makeNodeToken(n6);
        n4.addNode(n5);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n9 = jj_consume_token(COMMA);
                  n8 = JTBToolkit.makeNodeToken(n9);
           n7.addNode(n8);
        break;
      default:
        jj_la1[219] = jj_gen;
        ;
      }
        n4.addNode(n7);
        n3.addNode(n4);
      break;
    default:
      jj_la1[220] = jj_gen;
      ;
    }
    n10 = AtomicClause();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEQCST:
        n15 = new NodeOptional();
        n12 = new NodeSequence(2);
      n14 = jj_consume_token(SEQCST);
                     n13 = JTBToolkit.makeNodeToken(n14);
        n12.addNode(n13);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n17 = jj_consume_token(COMMA);
                   n16 = JTBToolkit.makeNodeToken(n17);
           n15.addNode(n16);
        break;
      default:
        jj_la1[221] = jj_gen;
        ;
      }
        n12.addNode(n15);
        n11.addNode(n12);
      break;
    default:
      jj_la1[222] = jj_gen;
      ;
    }
    n18 = OmpEol();
    n19 = Statement();
     {if (true) return new OmpAtomicClauseConstruct(n0,n1,n3,n10,n11,n18,n19);}
    throw new Error("Missing return statement in function");
  }

  final public AtomicClause AtomicClause() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case READ:
      n2 = jj_consume_token(READ);
                  n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case WRITE:
      n4 = jj_consume_token(WRITE);
                   n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case UPDATE:
      n6 = jj_consume_token(UPDATE);
                    n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case CAPTURE:
      n8 = jj_consume_token(CAPTURE);
                     n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
      break;
    default:
      jj_la1[223] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new AtomicClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpOrderedConstruct OmpOrderedConstruct() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeOptional n3 = new NodeOptional();
   OmpOrderedClauseList n4;
   OmpEol n5;
   Statement n6;
    n0 = OmpPragma();
    n2 = jj_consume_token(ORDERED);
                  n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SIMD:
    case DEPEND:
    case THREADS:
      n4 = OmpOrderedClauseList();
        n3.addNode(n4);
      break;
    default:
      jj_la1[224] = jj_gen;
      ;
    }
    n5 = OmpEol();
    n6 = Statement();
     {if (true) return new OmpOrderedConstruct(n0,n1,n3,n5,n6);}
    throw new Error("Missing return statement in function");
  }

  final public OmpOrderedClauseList OmpOrderedClauseList() throws ParseException {
   OmpOrderedConstructClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpOrderedConstructClause n6;
    n0 = OmpOrderedConstructClause();
    label_48:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
      case SIMD:
      case DEPEND:
      case THREADS:
        ;
        break;
      default:
        jj_la1[225] = jj_gen;
        break label_48;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[226] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpOrderedConstructClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpOrderedClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpOrderedConstructClause OmpOrderedConstructClause() throws ParseException {
   NodeChoice n0;
   OmpThreadsClause n1;
   OmpSimdOrderedClause n2;
   OmpDependOrderedSourceClause n3;
   OmpDependOrderedSinkClause n4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THREADS:
      n1 = OmpThreadsClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case SIMD:
      n2 = OmpSimdOrderedClause();
        n0 = new NodeChoice(n2, 1);
      break;
    default:
      jj_la1[227] = jj_gen;
      if (jj_2_127(3)) {
        n3 = OmpDependOrderedSourceClause();
        n0 = new NodeChoice(n3, 2);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DEPEND:
          n4 = OmpDependOrderedSinkClause();
        n0 = new NodeChoice(n4, 3);
          break;
        default:
          jj_la1[228] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
     {if (true) return new OmpOrderedConstructClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpThreadsClause OmpThreadsClause() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(THREADS);
                  n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new OmpThreadsClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpSimdOrderedClause OmpSimdOrderedClause() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(SIMD);
               n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new OmpSimdOrderedClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDependOrderedSourceClause OmpDependOrderedSourceClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
    n1 = jj_consume_token(DEPEND);
                 n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(SOURCE);
                 n4 = JTBToolkit.makeNodeToken(n5);
    n7 = jj_consume_token(RIGHTPAREN);
            n6 = JTBToolkit.makeNodeToken(n7);
     {if (true) return new OmpDependOrderedSourceClause(n0,n2,n4,n6);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDependOrderedSinkClause OmpDependOrderedSinkClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   OmpIterationVector n8;
   NodeToken n9;
   Token n10;
    n1 = jj_consume_token(DEPEND);
                 n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(SINK);
               n4 = JTBToolkit.makeNodeToken(n5);
    n7 = jj_consume_token(COLON);
                n6 = JTBToolkit.makeNodeToken(n7);
    n8 = OmpIterationVector();
    n10 = jj_consume_token(RIGHTPAREN);
             n9 = JTBToolkit.makeNodeToken(n10);
     {if (true) return new OmpDependOrderedSinkClause(n0,n2,n4,n6,n8,n9);}
    throw new Error("Missing return statement in function");
  }

  final public OmpIterationVector OmpIterationVector() throws ParseException {
   OmpIterationDimension n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   OmpIterationDimension n5;
    n0 = OmpIterationDimension();
    label_49:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[229] = jj_gen;
        break label_49;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = OmpIterationDimension();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpIterationVector(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpIterationDimension OmpIterationDimension() throws ParseException {
   NodeChoice n0;
   OmpForwardDependence n1;
   OmpBackwardDependence n2;
    if (jj_2_128(2)) {
      n1 = OmpForwardDependence();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        n2 = OmpBackwardDependence();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[230] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpIterationDimension(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpForwardDependence OmpForwardDependence() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   ConstantExpression n4;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(OP_ADD);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = ConstantExpression();
     {if (true) return new OmpForwardDependence(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public OmpBackwardDependence OmpBackwardDependence() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   ConstantExpression n4;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(OP_SUB);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = ConstantExpression();
     {if (true) return new OmpBackwardDependence(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTaskyieldDirective OmpTaskyieldDirective() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   OmpEol n3;
    n0 = OmpPragma();
    n2 = jj_consume_token(TASKYIELD);
                    n1 = JTBToolkit.makeNodeToken(n2);
    n3 = OmpEol();
     {if (true) return new OmpTaskyieldDirective(n0,n1,n3);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetEnterDataDirective OmpTargetEnterDataDirective() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeOptional n7 = new NodeOptional();
   OmpTargetEnterDataClauseList n8;
    n0 = OmpPragma();
    n2 = jj_consume_token(TARGET);
                 n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(ENTER);
                n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(DATA);
               n5 = JTBToolkit.makeNodeToken(n6);
    if (jj_2_129(2147483647)) {
      n8 = OmpTargetEnterDataClauseList();
        n7.addNode(n8);
    } else {
      ;
    }
     {if (true) return new OmpTargetEnterDataDirective(n0,n1,n3,n5,n7);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetEnterDataClauseList OmpTargetEnterDataClauseList() throws ParseException {
   OmpTargetEnterDataClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTargetEnterDataClause n6;
    n0 = OmpTargetEnterDataClause();
    label_50:
    while (true) {
      if (jj_2_130(2147483647)) {
        ;
      } else {
        break label_50;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[231] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTargetEnterDataClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTargetEnterDataClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetEnterDataClause OmpTargetEnterDataClause() throws ParseException {
   NodeChoice n0;
   OmpIfTargetEnterDataClause n1;
   OmpDeviceClause n2;
   OmpMapClause n3;
   OmpDependClause n4;
   OmpNowaitClause n5;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      n1 = OmpIfTargetEnterDataClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case DEVICE:
      n2 = OmpDeviceClause();
        n0 = new NodeChoice(n2, 1);
      break;
    case MAP:
      n3 = OmpMapClause();
        n0 = new NodeChoice(n3, 2);
      break;
    case DEPEND:
      n4 = OmpDependClause();
        n0 = new NodeChoice(n4, 3);
      break;
    case NOWAIT:
      n5 = OmpNowaitClause();
        n0 = new NodeChoice(n5, 4);
      break;
    default:
      jj_la1[232] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OmpTargetEnterDataClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpIfTargetEnterDataClause OmpIfTargetEnterDataClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeOptional n4 = new NodeOptional();
   NodeSequence n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
   NodeToken n12;
   Token n13;
   Expression n14;
   NodeToken n15;
   Token n16;
    n1 = jj_consume_token(IF);
             n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TARGET:
        n5 = new NodeSequence(4);
      n7 = jj_consume_token(TARGET);
                    n6 = JTBToolkit.makeNodeToken(n7);
        n5.addNode(n6);
      n9 = jj_consume_token(ENTER);
                   n8 = JTBToolkit.makeNodeToken(n9);
        n5.addNode(n8);
      n11 = jj_consume_token(DATA);
                   n10 = JTBToolkit.makeNodeToken(n11);
        n5.addNode(n10);
      n13 = jj_consume_token(COLON);
                    n12 = JTBToolkit.makeNodeToken(n13);
        n5.addNode(n12);
        n4.addNode(n5);
      break;
    default:
      jj_la1[233] = jj_gen;
      ;
    }
    n14 = Expression();
    n16 = jj_consume_token(RIGHTPAREN);
             n15 = JTBToolkit.makeNodeToken(n16);
     {if (true) return new OmpIfTargetEnterDataClause(n0,n2,n4,n14,n15);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDeviceClause OmpDeviceClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(DEVICE);
                 n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpDeviceClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpMapClause OmpMapClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeOptional n4 = new NodeOptional();
   NodeSequence n5;
   NodeOptional n6;
   NodeSequence n7;
   OmpMapTypeModifier n8;
   NodeOptional n9;
   NodeToken n10;
   Token n11;
   OmpMapType n12;
   NodeToken n13;
   Token n14;
   VariableList n15;
   NodeToken n16;
   Token n17;
    n1 = jj_consume_token(MAP);
              n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TO:
    case FROM:
    case TOFROM:
    case ALLOC:
    case RELEASE:
    case DELETE:
    case ALWAYS:
        n6 = new NodeOptional();
        n5 = new NodeSequence(3);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALWAYS:
           n9 = new NodeOptional();
           n7 = new NodeSequence(2);
        n8 = OmpMapTypeModifier();
           n7.addNode(n8);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          n11 = jj_consume_token(COMMA);
                      n10 = JTBToolkit.makeNodeToken(n11);
              n9.addNode(n10);
          break;
        default:
          jj_la1[234] = jj_gen;
          ;
        }
           n7.addNode(n9);
           n6.addNode(n7);
        break;
      default:
        jj_la1[235] = jj_gen;
        ;
      }
        n5.addNode(n6);
      n12 = OmpMapType();
        n5.addNode(n12);
      n14 = jj_consume_token(COLON);
                    n13 = JTBToolkit.makeNodeToken(n14);
        n5.addNode(n13);
        n4.addNode(n5);
      break;
    default:
      jj_la1[236] = jj_gen;
      ;
    }
    n15 = VariableList();
    n17 = jj_consume_token(RIGHTPAREN);
             n16 = JTBToolkit.makeNodeToken(n17);
     {if (true) return new OmpMapClause(n0,n2,n4,n15,n16);}
    throw new Error("Missing return statement in function");
  }

  final public OmpMapTypeModifier OmpMapTypeModifier() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(ALWAYS);
                 n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new OmpMapTypeModifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpMapType OmpMapType() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TO:
      n2 = jj_consume_token(TO);
                n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case FROM:
      n4 = jj_consume_token(FROM);
                  n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case TOFROM:
      n6 = jj_consume_token(TOFROM);
                    n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case ALLOC:
      n8 = jj_consume_token(ALLOC);
                   n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
      break;
    case RELEASE:
      n10 = jj_consume_token(RELEASE);
                      n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4);
      break;
    case DELETE:
      n12 = jj_consume_token(DELETE);
                     n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5);
      break;
    default:
      jj_la1[237] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OmpMapType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetExitDataDirective OmpTargetExitDataDirective() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeOptional n7 = new NodeOptional();
   OmpTargetExitDataClauseList n8;
    n0 = OmpPragma();
    n2 = jj_consume_token(TARGET);
                 n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(EXIT);
               n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(DATA);
               n5 = JTBToolkit.makeNodeToken(n6);
    if (jj_2_131(2147483647)) {
      n8 = OmpTargetExitDataClauseList();
        n7.addNode(n8);
    } else {
      ;
    }
     {if (true) return new OmpTargetExitDataDirective(n0,n1,n3,n5,n7);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetExitDataClauseList OmpTargetExitDataClauseList() throws ParseException {
   OmpTargetExitDataClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTargetExitDataClause n6;
    n0 = OmpTargetExitDataClause();
    label_51:
    while (true) {
      if (jj_2_132(2147483647)) {
        ;
      } else {
        break label_51;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[238] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTargetExitDataClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTargetExitDataClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetExitDataClause OmpTargetExitDataClause() throws ParseException {
   NodeChoice n0;
   OmpIfTargetExitDataClause n1;
   OmpDeviceClause n2;
   OmpMapClause n3;
   OmpDependClause n4;
   OmpNowaitClause n5;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      n1 = OmpIfTargetExitDataClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case DEVICE:
      n2 = OmpDeviceClause();
        n0 = new NodeChoice(n2, 1);
      break;
    case MAP:
      n3 = OmpMapClause();
        n0 = new NodeChoice(n3, 2);
      break;
    case DEPEND:
      n4 = OmpDependClause();
        n0 = new NodeChoice(n4, 3);
      break;
    case NOWAIT:
      n5 = OmpNowaitClause();
        n0 = new NodeChoice(n5, 4);
      break;
    default:
      jj_la1[239] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OmpTargetExitDataClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpIfTargetExitDataClause OmpIfTargetExitDataClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeOptional n4 = new NodeOptional();
   NodeSequence n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
   NodeToken n12;
   Token n13;
   Expression n14;
   NodeToken n15;
   Token n16;
    n1 = jj_consume_token(IF);
             n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TARGET:
        n5 = new NodeSequence(4);
      n7 = jj_consume_token(TARGET);
                    n6 = JTBToolkit.makeNodeToken(n7);
        n5.addNode(n6);
      n9 = jj_consume_token(EXIT);
                  n8 = JTBToolkit.makeNodeToken(n9);
        n5.addNode(n8);
      n11 = jj_consume_token(DATA);
                   n10 = JTBToolkit.makeNodeToken(n11);
        n5.addNode(n10);
      n13 = jj_consume_token(COLON);
                    n12 = JTBToolkit.makeNodeToken(n13);
        n5.addNode(n12);
        n4.addNode(n5);
      break;
    default:
      jj_la1[240] = jj_gen;
      ;
    }
    n14 = Expression();
    n16 = jj_consume_token(RIGHTPAREN);
             n15 = JTBToolkit.makeNodeToken(n16);
     {if (true) return new OmpIfTargetExitDataClause(n0,n2,n4,n14,n15);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetUpdateDirective OmpTargetUpdateDirective() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   OmpTargetUpdateClauseList n5;
    n0 = OmpPragma();
    n2 = jj_consume_token(TARGET);
                 n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(UPDATE);
                 n3 = JTBToolkit.makeNodeToken(n4);
    n5 = OmpTargetUpdateClauseList();
     {if (true) return new OmpTargetUpdateDirective(n0,n1,n3,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetUpdateClauseList OmpTargetUpdateClauseList() throws ParseException {
   OmpTargetUpdateClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpTargetUpdateClause n6;
    n0 = OmpTargetUpdateClause();
    label_52:
    while (true) {
      if (jj_2_133(2147483647)) {
        ;
      } else {
        break label_52;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[241] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpTargetUpdateClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpTargetUpdateClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTargetUpdateClause OmpTargetUpdateClause() throws ParseException {
   NodeChoice n0;
   OmpIfTargetUpdateClause n1;
   OmpDeviceClause n2;
   OmpNowaitClause n3;
   OmpDependClause n4;
   OmpToClause n5;
   OmpFromClause n6;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      n1 = OmpIfTargetUpdateClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case DEVICE:
      n2 = OmpDeviceClause();
        n0 = new NodeChoice(n2, 1);
      break;
    case NOWAIT:
      n3 = OmpNowaitClause();
        n0 = new NodeChoice(n3, 2);
      break;
    case DEPEND:
      n4 = OmpDependClause();
        n0 = new NodeChoice(n4, 3);
      break;
    case TO:
      n5 = OmpToClause();
        n0 = new NodeChoice(n5, 4);
      break;
    case FROM:
      n6 = OmpFromClause();
        n0 = new NodeChoice(n6, 5);
      break;
    default:
      jj_la1[242] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OmpTargetUpdateClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpIfTargetUpdateClause OmpIfTargetUpdateClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeOptional n4 = new NodeOptional();
   NodeSequence n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
   Expression n12;
   NodeToken n13;
   Token n14;
    n1 = jj_consume_token(IF);
             n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TARGET:
        n5 = new NodeSequence(3);
      n7 = jj_consume_token(TARGET);
                    n6 = JTBToolkit.makeNodeToken(n7);
        n5.addNode(n6);
      n9 = jj_consume_token(UPDATE);
                    n8 = JTBToolkit.makeNodeToken(n9);
        n5.addNode(n8);
      n11 = jj_consume_token(COLON);
                    n10 = JTBToolkit.makeNodeToken(n11);
        n5.addNode(n10);
        n4.addNode(n5);
      break;
    default:
      jj_la1[243] = jj_gen;
      ;
    }
    n12 = Expression();
    n14 = jj_consume_token(RIGHTPAREN);
             n13 = JTBToolkit.makeNodeToken(n14);
     {if (true) return new OmpIfTargetUpdateClause(n0,n2,n4,n12,n13);}
    throw new Error("Missing return statement in function");
  }

  final public OmpToClause OmpToClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   VariableList n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(TO);
             n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = VariableList();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpToClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpFromClause OmpFromClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   VariableList n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(FROM);
               n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = VariableList();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpFromClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpBarrierDirective OmpBarrierDirective() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   OmpEol n3;
    n0 = OmpPragma();
    n2 = jj_consume_token(BARRIER);
                  n1 = JTBToolkit.makeNodeToken(n2);
    n3 = OmpEol();
     {if (true) return new OmpBarrierDirective(n0,n1,n3);}
    throw new Error("Missing return statement in function");
  }

  final public OmpTaskwaitDirective OmpTaskwaitDirective() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   OmpEol n3;
    n0 = OmpPragma();
    n2 = jj_consume_token(TASKWAIT);
                   n1 = JTBToolkit.makeNodeToken(n2);
    n3 = OmpEol();
     {if (true) return new OmpTaskwaitDirective(n0,n1,n3);}
    throw new Error("Missing return statement in function");
  }

  final public OmpFlushDirective OmpFlushDirective() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeOptional n3 = new NodeOptional();
   NodeSequence n4;
   NodeToken n5;
   Token n6;
   VariableList n7;
   NodeToken n8;
   Token n9;
   OmpEol n10;
    n0 = OmpPragma();
    n2 = jj_consume_token(FLUSH);
                n1 = JTBToolkit.makeNodeToken(n2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFTPAREN:
        n4 = new NodeSequence(3);
      n6 = jj_consume_token(LEFTPAREN);
               n5 = JTBToolkit.makeNodeToken(n6);
        n4.addNode(n5);
      n7 = VariableList();
        n4.addNode(n7);
      n9 = jj_consume_token(RIGHTPAREN);
               n8 = JTBToolkit.makeNodeToken(n9);
        n4.addNode(n8);
        n3.addNode(n4);
      break;
    default:
      jj_la1[244] = jj_gen;
      ;
    }
    n10 = OmpEol();
     {if (true) return new OmpFlushDirective(n0,n1,n3,n10);}
    throw new Error("Missing return statement in function");
  }

  final public OmpCancelDirective OmpCancelDirective() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   OmpConstructTypeClause n3;
   NodeOptional n4 = new NodeOptional();
   NodeSequence n5;
   NodeOptional n6;
   NodeToken n7;
   Token n8;
   OmpIfClause n9;
   OmpEol n10;
    n0 = OmpPragma();
    n2 = jj_consume_token(CANCEL);
                 n1 = JTBToolkit.makeNodeToken(n2);
    n3 = OmpConstructTypeClause();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
    case COMMA:
        n6 = new NodeOptional();
        n5 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n8 = jj_consume_token(COMMA);
                  n7 = JTBToolkit.makeNodeToken(n8);
           n6.addNode(n7);
        break;
      default:
        jj_la1[245] = jj_gen;
        ;
      }
        n5.addNode(n6);
      n9 = OmpIfClause();
        n5.addNode(n9);
        n4.addNode(n5);
      break;
    default:
      jj_la1[246] = jj_gen;
      ;
    }
    n10 = OmpEol();
     {if (true) return new OmpCancelDirective(n0,n1,n3,n4,n10);}
    throw new Error("Missing return statement in function");
  }

  final public OmpConstructTypeClause OmpConstructTypeClause() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARALLEL:
      n2 = jj_consume_token(PARALLEL);
                      n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case SECTIONS:
      n4 = jj_consume_token(SECTIONS);
                      n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case FOR:
      n6 = jj_consume_token(FOR);
                 n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case TASKGROUP:
      n8 = jj_consume_token(TASKGROUP);
                       n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
      break;
    default:
      jj_la1[247] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OmpConstructTypeClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpIfClause OmpIfClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(IF);
             n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpIfClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpCancellationPointDirective OmpCancellationPointDirective() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   OmpConstructTypeClause n5;
   OmpEol n6;
    n0 = OmpPragma();
    n2 = jj_consume_token(CANCELLATION);
                       n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(POINT);
                n3 = JTBToolkit.makeNodeToken(n4);
    n5 = OmpConstructTypeClause();
    n6 = OmpEol();
     {if (true) return new OmpCancellationPointDirective(n0,n1,n3,n5,n6);}
    throw new Error("Missing return statement in function");
  }

  final public OmpGlobalDirective OmpGlobalDirective() throws ParseException {
   NodeChoice n0;
   OmpDeclareTargetExtendedListDirective n1;
   OmpDeclareTargetListDirective n2;
   OmpDeclareTargetDirective n3;
   OmpDeclareSimdDirective n4;
   OmpThreadPrivateDirective n5;
   OmpDeclareReductionDirective n6;
    if (jj_2_134(6)) {
      n1 = OmpDeclareTargetExtendedListDirective();
        n0 = new NodeChoice(n1, 0);
    } else if (jj_2_135(6)) {
      n2 = OmpDeclareTargetListDirective();
        n0 = new NodeChoice(n2, 1);
    } else if (jj_2_136(5)) {
      n3 = OmpDeclareTargetDirective();
        n0 = new NodeChoice(n3, 2);
    } else if (jj_2_137(5)) {
      n4 = OmpDeclareSimdDirective();
        n0 = new NodeChoice(n4, 3);
    } else if (jj_2_138(4)) {
      n5 = OmpThreadPrivateDirective();
        n0 = new NodeChoice(n5, 4);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CROSSBAR:
        n6 = OmpDeclareReductionDirective();
        n0 = new NodeChoice(n6, 5);
        break;
      default:
        jj_la1[248] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new OmpGlobalDirective(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDeclareTargetExtendedListDirective OmpDeclareTargetExtendedListDirective() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   VariableList n7;
   NodeToken n8;
   Token n9;
    n0 = OmpPragma();
    n2 = jj_consume_token(DECLARE);
                  n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(TARGET);
                 n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(LEFTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = VariableList();
    n9 = jj_consume_token(RIGHTPAREN);
            n8 = JTBToolkit.makeNodeToken(n9);
     {if (true) return new OmpDeclareTargetExtendedListDirective(n0,n1,n3,n5,n7,n8);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDeclareTargetListDirective OmpDeclareTargetListDirective() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   OmpDeclareTargetClauseList n5;
    n0 = OmpPragma();
    n2 = jj_consume_token(DECLARE);
                  n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(TARGET);
                 n3 = JTBToolkit.makeNodeToken(n4);
    n5 = OmpDeclareTargetClauseList();
     {if (true) return new OmpDeclareTargetListDirective(n0,n1,n3,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDeclareTargetClauseList OmpDeclareTargetClauseList() throws ParseException {
   OmpDeclareTargetClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpDeclareTargetClause n6;
    n0 = OmpDeclareTargetClause();
    label_53:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
      case TO:
      case LINK:
        ;
        break;
      default:
        jj_la1[249] = jj_gen;
        break label_53;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[250] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpDeclareTargetClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpDeclareTargetClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDeclareTargetClause OmpDeclareTargetClause() throws ParseException {
   NodeChoice n0;
   OmpToClause n1;
   OmpLinkClause n2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TO:
      n1 = OmpToClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case LINK:
      n2 = OmpLinkClause();
        n0 = new NodeChoice(n2, 1);
      break;
    default:
      jj_la1[251] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OmpDeclareTargetClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpLinkClause OmpLinkClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   VariableList n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(LINK);
               n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = VariableList();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpLinkClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDeclareTargetDirective OmpDeclareTargetDirective() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   OmpEol n5;
   NodeListOptional n6 = new NodeListOptional();
   FunctionDefinitionOrDeclaration n7;
   OmpPragma n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
    n0 = OmpPragma();
    n2 = jj_consume_token(DECLARE);
                  n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(TARGET);
                 n3 = JTBToolkit.makeNodeToken(n4);
    n5 = OmpEol();
    label_54:
    while (true) {
      if (jj_2_139(1)) {
        ;
      } else {
        break label_54;
      }
      n7 = FunctionDefinitionOrDeclaration();
        n6.addNode(n7);
    }
     n6.nodes.trimToSize();
    n8 = OmpPragma();
    n10 = jj_consume_token(END);
               n9 = JTBToolkit.makeNodeToken(n10);
    n12 = jj_consume_token(DECLARE);
                   n11 = JTBToolkit.makeNodeToken(n12);
    n14 = jj_consume_token(TARGET);
                  n13 = JTBToolkit.makeNodeToken(n14);
     {if (true) return new OmpDeclareTargetDirective(n0,n1,n3,n5,n6,n8,n9,n11,n13);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDeclareSimdDirective OmpDeclareSimdDirective() throws ParseException {
   OmpDeclareSimdPragmaList n0;
   FunctionDefinitionOrDeclaration n1;
    n0 = OmpDeclareSimdPragmaList();
    n1 = FunctionDefinitionOrDeclaration();
     {if (true) return new OmpDeclareSimdDirective(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDeclareSimdPragmaList OmpDeclareSimdPragmaList() throws ParseException {
   OmpDeclareSimdPragma n0;
   NodeListOptional n1 = new NodeListOptional();
   OmpDeclareSimdPragma n2;
    n0 = OmpDeclareSimdPragma();
    label_55:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CROSSBAR:
        ;
        break;
      default:
        jj_la1[252] = jj_gen;
        break label_55;
      }
      n2 = OmpDeclareSimdPragma();
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpDeclareSimdPragmaList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDeclareSimdPragma OmpDeclareSimdPragma() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeOptional n5 = new NodeOptional();
   OmpDeclareSimdClauseList n6;
    n0 = OmpPragma();
    n2 = jj_consume_token(DECLARE);
                  n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(SIMD);
               n3 = JTBToolkit.makeNodeToken(n4);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LINEAR:
    case SIMDLEN:
    case ALIGNED:
    case UNIFORM:
    case INBRANCH:
    case NOTINBRANCH:
      n6 = OmpDeclareSimdClauseList();
        n5.addNode(n6);
      break;
    default:
      jj_la1[253] = jj_gen;
      ;
    }
     {if (true) return new OmpDeclareSimdPragma(n0,n1,n3,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDeclareSimdClauseList OmpDeclareSimdClauseList() throws ParseException {
   OmpDeclareSimdClause n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeOptional n3;
   NodeToken n4;
   Token n5;
   OmpDeclareSimdClause n6;
    n0 = OmpDeclareSimdClause();
    label_56:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
      case LINEAR:
      case SIMDLEN:
      case ALIGNED:
      case UNIFORM:
      case INBRANCH:
      case NOTINBRANCH:
        ;
        break;
      default:
        jj_la1[254] = jj_gen;
        break label_56;
      }
        n3 = new NodeOptional();
        n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        n5 = jj_consume_token(COMMA);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        break;
      default:
        jj_la1[255] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = OmpDeclareSimdClause();
        n2.addNode(n6);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new OmpDeclareSimdClauseList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDeclareSimdClause OmpDeclareSimdClause() throws ParseException {
   NodeChoice n0;
   OmpSimdLenClause n1;
   OmpLinearClause n2;
   OmpAlignedClause n3;
   OmpUniformClause n4;
   OmpInbranchClause n5;
   OmpNotinbranchClause n6;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SIMDLEN:
      n1 = OmpSimdLenClause();
        n0 = new NodeChoice(n1, 0);
      break;
    case LINEAR:
      n2 = OmpLinearClause();
        n0 = new NodeChoice(n2, 1);
      break;
    case ALIGNED:
      n3 = OmpAlignedClause();
        n0 = new NodeChoice(n3, 2);
      break;
    case UNIFORM:
      n4 = OmpUniformClause();
        n0 = new NodeChoice(n4, 3);
      break;
    case INBRANCH:
      n5 = OmpInbranchClause();
        n0 = new NodeChoice(n5, 4);
      break;
    case NOTINBRANCH:
      n6 = OmpNotinbranchClause();
        n0 = new NodeChoice(n6, 5);
      break;
    default:
      jj_la1[256] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new OmpDeclareSimdClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpUniformClause OmpUniformClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   VariableList n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(UNIFORM);
                  n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = VariableList();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new OmpUniformClause(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public OmpInbranchClause OmpInbranchClause() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(INBRANCH);
                   n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new OmpInbranchClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpNotinbranchClause OmpNotinbranchClause() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(NOTINBRANCH);
                      n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new OmpNotinbranchClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public FunctionDefinitionOrDeclaration FunctionDefinitionOrDeclaration() throws ParseException {
   NodeChoice n0;
   Declaration n1;
   FunctionDefinition n2;
    if (jj_2_140(2147483647)) {
      n1 = Declaration();
        n0 = new NodeChoice(n1, 0);
    } else if (jj_2_141(1)) {
      n2 = FunctionDefinition();
        n0 = new NodeChoice(n2, 1);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new FunctionDefinitionOrDeclaration(n0);}
    throw new Error("Missing return statement in function");
  }

  final public OmpThreadPrivateDirective OmpThreadPrivateDirective() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   VariableList n5;
   NodeToken n6;
   Token n7;
   OmpEol n8;
    n0 = OmpPragma();
    n2 = jj_consume_token(THREADPRIVATE);
                        n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(LEFTPAREN);
            n3 = JTBToolkit.makeNodeToken(n4);
    n5 = VariableList();
    n7 = jj_consume_token(RIGHTPAREN);
            n6 = JTBToolkit.makeNodeToken(n7);
    n8 = OmpEol();
     {if (true) return new OmpThreadPrivateDirective(n0,n1,n3,n5,n6,n8);}
    throw new Error("Missing return statement in function");
  }

  final public OmpDeclareReductionDirective OmpDeclareReductionDirective() throws ParseException {
   OmpPragma n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   ReductionOp n7;
   NodeToken n8;
   Token n9;
   ReductionTypeList n10;
   NodeToken n11;
   Token n12;
   Expression n13;
   NodeToken n14;
   Token n15;
   NodeOptional n16 = new NodeOptional();
   InitializerClause n17;
   OmpEol n18;
    n0 = OmpPragma();
    n2 = jj_consume_token(DECLARE);
                  n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(REDUCTION);
                    n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(LEFTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = ReductionOp();
    n9 = jj_consume_token(COLON);
            n8 = JTBToolkit.makeNodeToken(n9);
    n10 = ReductionTypeList();
    n12 = jj_consume_token(COLON);
             n11 = JTBToolkit.makeNodeToken(n12);
    n13 = Expression();
    n15 = jj_consume_token(RIGHTPAREN);
             n14 = JTBToolkit.makeNodeToken(n15);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INITIALIZER:
      n17 = InitializerClause();
        n16.addNode(n17);
      break;
    default:
      jj_la1[257] = jj_gen;
      ;
    }
    n18 = OmpEol();
     {if (true) return new OmpDeclareReductionDirective(n0,n1,n3,n5,n7,n8,n10,n11,n13,n14,n16,n18);}
    throw new Error("Missing return statement in function");
  }

  final public ReductionTypeList ReductionTypeList() throws ParseException {
   NodeListOptional n0 = new NodeListOptional();
   TypeSpecifier n1;
    label_57:
    while (true) {
      if (jj_2_142(1)) {
        ;
      } else {
        break label_57;
      }
      n1 = TypeSpecifier();
        n0.addNode(n1);
    }
     n0.nodes.trimToSize();
     {if (true) return new ReductionTypeList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public InitializerClause InitializerClause() throws ParseException {
   NodeChoice n0;
   AssignInitializerClause n1;
   ArgumentInitializerClause n2;
    if (jj_2_143(5)) {
      n1 = AssignInitializerClause();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INITIALIZER:
        n2 = ArgumentInitializerClause();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[258] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new InitializerClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public AssignInitializerClause AssignInitializerClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   Initializer n8;
   NodeToken n9;
   Token n10;
    n1 = jj_consume_token(INITIALIZER);
                      n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(IDENTIFIER);
                     n4 = JTBToolkit.makeNodeToken(n5);
    n7 = jj_consume_token(OP_ASS);
            n6 = JTBToolkit.makeNodeToken(n7);
    n8 = Initializer();
    n10 = jj_consume_token(RIGHTPAREN);
             n9 = JTBToolkit.makeNodeToken(n10);
     {if (true) return new AssignInitializerClause(n0,n2,n4,n6,n8,n9);}
    throw new Error("Missing return statement in function");
  }

  final public ArgumentInitializerClause ArgumentInitializerClause() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   ExpressionList n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
    n1 = jj_consume_token(INITIALIZER);
                      n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(IDENTIFIER);
                     n4 = JTBToolkit.makeNodeToken(n5);
    n7 = jj_consume_token(LEFTPAREN);
            n6 = JTBToolkit.makeNodeToken(n7);
    n8 = ExpressionList();
    n10 = jj_consume_token(RIGHTPAREN);
             n9 = JTBToolkit.makeNodeToken(n10);
    n12 = jj_consume_token(RIGHTPAREN);
             n11 = JTBToolkit.makeNodeToken(n12);
     {if (true) return new ArgumentInitializerClause(n0,n2,n4,n6,n8,n9,n11);}
    throw new Error("Missing return statement in function");
  }

  final public ReductionOp ReductionOp() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      n2 = jj_consume_token(IDENTIFIER);
                        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case OP_ADD:
      n4 = jj_consume_token(OP_ADD);
               n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case OP_MUL:
      n6 = jj_consume_token(OP_MUL);
               n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case OP_SUB:
      n8 = jj_consume_token(OP_SUB);
               n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
      break;
    case OP_BITAND:
      n10 = jj_consume_token(OP_BITAND);
                n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4);
      break;
    case OP_BITXOR:
      n12 = jj_consume_token(OP_BITXOR);
                n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5);
      break;
    case OP_BITOR:
      n14 = jj_consume_token(OP_BITOR);
                n13 = JTBToolkit.makeNodeToken(n14);
        n0 = new NodeChoice(n13, 6);
      break;
    case OP_OR:
      n16 = jj_consume_token(OP_OR);
                 n15 = JTBToolkit.makeNodeToken(n16);
        n0 = new NodeChoice(n15, 7);
      break;
    case OP_AND:
      n18 = jj_consume_token(OP_AND);
                 n17 = JTBToolkit.makeNodeToken(n18);
        n0 = new NodeChoice(n17, 8);
      break;
    default:
      jj_la1[259] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new ReductionOp(n0);}
    throw new Error("Missing return statement in function");
  }

  final public VariableList VariableList() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeListOptional n2 = new NodeListOptional();
   NodeSequence n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    label_58:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[260] = jj_gen;
        break label_58;
      }
        n3 = new NodeSequence(2);
      n5 = jj_consume_token(COMMA);
               n4 = JTBToolkit.makeNodeToken(n5);
        n3.addNode(n4);
      n7 = jj_consume_token(IDENTIFIER);
                        n6 = JTBToolkit.makeNodeToken(n7);
        n3.addNode(n6);
        n2.addNode(n3);
    }
     n2.nodes.trimToSize();
     {if (true) return new VariableList(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public Expression Expression() throws ParseException {
   AssignmentExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   AssignmentExpression n5;
    n0 = AssignmentExpression();
    label_59:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[261] = jj_gen;
        break label_59;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = AssignmentExpression();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new Expression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public AssignmentExpression AssignmentExpression() throws ParseException {
   NodeChoice n0;
   NonConditionalExpression n1;
   ConditionalExpression n2;
    if (jj_2_144(2147483647)) {
      n1 = NonConditionalExpression();
        n0 = new NodeChoice(n1, 0);
    } else if (jj_2_145(3)) {
      n2 = ConditionalExpression();
        n0 = new NodeChoice(n2, 1);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new AssignmentExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public NonConditionalExpression NonConditionalExpression() throws ParseException {
   UnaryExpression n0;
   AssignmentOperator n1;
   AssignmentExpression n2;
    n0 = UnaryExpression();
    n1 = AssignmentOperator();
    n2 = AssignmentExpression();
     {if (true) return new NonConditionalExpression(n0,n1,n2);}
    throw new Error("Missing return statement in function");
  }

  final public AssignmentOperator AssignmentOperator() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   NodeToken n19;
   Token n20;
   NodeToken n21;
   Token n22;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_ASS:
      n2 = jj_consume_token(OP_ASS);
               n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case OP_MULASS:
      n4 = jj_consume_token(OP_MULASS);
                n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case OP_DIVASS:
      n6 = jj_consume_token(OP_DIVASS);
                n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case OP_MODASS:
      n8 = jj_consume_token(OP_MODASS);
                n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
      break;
    case OP_ADDASS:
      n10 = jj_consume_token(OP_ADDASS);
                 n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4);
      break;
    case OP_SUBASS:
      n12 = jj_consume_token(OP_SUBASS);
                 n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5);
      break;
    case OP_SLASS:
      n14 = jj_consume_token(OP_SLASS);
                  n13 = JTBToolkit.makeNodeToken(n14);
        n0 = new NodeChoice(n13, 6);
      break;
    case OP_SRASS:
      n16 = jj_consume_token(OP_SRASS);
                  n15 = JTBToolkit.makeNodeToken(n16);
        n0 = new NodeChoice(n15, 7);
      break;
    case OP_ANDASS:
      n18 = jj_consume_token(OP_ANDASS);
                 n17 = JTBToolkit.makeNodeToken(n18);
        n0 = new NodeChoice(n17, 8);
      break;
    case OP_XORASS:
      n20 = jj_consume_token(OP_XORASS);
                 n19 = JTBToolkit.makeNodeToken(n20);
        n0 = new NodeChoice(n19, 9);
      break;
    case OP_ORASS:
      n22 = jj_consume_token(OP_ORASS);
                 n21 = JTBToolkit.makeNodeToken(n22);
        n0 = new NodeChoice(n21, 10);
      break;
    default:
      jj_la1[262] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new AssignmentOperator(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ConditionalExpression ConditionalExpression() throws ParseException {
   LogicalORExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   Expression n5;
   NodeToken n6;
   Token n7;
   ConditionalExpression n8;
    n0 = LogicalORExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUESTION:
        n2 = new NodeSequence(4);
      n4 = jj_consume_token(QUESTION);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = Expression();
        n2.addNode(n5);
      n7 = jj_consume_token(COLON);
               n6 = JTBToolkit.makeNodeToken(n7);
        n2.addNode(n6);
      n8 = ConditionalExpression();
        n2.addNode(n8);
        n1.addNode(n2);
      break;
    default:
      jj_la1[263] = jj_gen;
      ;
    }
     {if (true) return new ConditionalExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public ConstantExpression ConstantExpression() throws ParseException {
   ConditionalExpression n0;
    n0 = ConditionalExpression();
     {if (true) return new ConstantExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public LogicalORExpression LogicalORExpression() throws ParseException {
   LogicalANDExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   LogicalORExpression n5;
    n0 = LogicalANDExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_OR:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(OP_OR);
                n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = LogicalORExpression();
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      jj_la1[264] = jj_gen;
      ;
    }
     {if (true) return new LogicalORExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public LogicalANDExpression LogicalANDExpression() throws ParseException {
   InclusiveORExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   LogicalANDExpression n5;
    n0 = InclusiveORExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_AND:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(OP_AND);
                n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = LogicalANDExpression();
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      jj_la1[265] = jj_gen;
      ;
    }
     {if (true) return new LogicalANDExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public InclusiveORExpression InclusiveORExpression() throws ParseException {
   ExclusiveORExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   InclusiveORExpression n5;
    n0 = ExclusiveORExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_BITOR:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(OP_BITOR);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = InclusiveORExpression();
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      jj_la1[266] = jj_gen;
      ;
    }
     {if (true) return new InclusiveORExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public ExclusiveORExpression ExclusiveORExpression() throws ParseException {
   ANDExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   ExclusiveORExpression n5;
    n0 = ANDExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_BITXOR:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(OP_BITXOR);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = ExclusiveORExpression();
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      jj_la1[267] = jj_gen;
      ;
    }
     {if (true) return new ExclusiveORExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public ANDExpression ANDExpression() throws ParseException {
   EqualityExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   ANDExpression n5;
    n0 = EqualityExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_BITAND:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(OP_BITAND);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = ANDExpression();
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      jj_la1[268] = jj_gen;
      ;
    }
     {if (true) return new ANDExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public EqualityExpression EqualityExpression() throws ParseException {
   RelationalExpression n0;
   NodeOptional n1 = new NodeOptional();
   EqualOptionalExpression n2;
    n0 = RelationalExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_EQ:
    case OP_NEQ:
      n2 = EqualOptionalExpression();
        n1.addNode(n2);
      break;
    default:
      jj_la1[269] = jj_gen;
      ;
    }
     {if (true) return new EqualityExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public EqualOptionalExpression EqualOptionalExpression() throws ParseException {
   NodeChoice n0;
   EqualExpression n1;
   NonEqualExpression n2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_EQ:
      n1 = EqualExpression();
        n0 = new NodeChoice(n1, 0);
      break;
    case OP_NEQ:
      n2 = NonEqualExpression();
        n0 = new NodeChoice(n2, 1);
      break;
    default:
      jj_la1[270] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new EqualOptionalExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public EqualExpression EqualExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   EqualityExpression n2;
    n1 = jj_consume_token(OP_EQ);
             n0 = JTBToolkit.makeNodeToken(n1);
    n2 = EqualityExpression();
     {if (true) return new EqualExpression(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public NonEqualExpression NonEqualExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   EqualityExpression n2;
    n1 = jj_consume_token(OP_NEQ);
             n0 = JTBToolkit.makeNodeToken(n1);
    n2 = EqualityExpression();
     {if (true) return new NonEqualExpression(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public RelationalExpression RelationalExpression() throws ParseException {
   ShiftExpression n0;
   NodeOptional n1 = new NodeOptional();
   RelationalOptionalExpression n2;
    n0 = ShiftExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_GE:
    case OP_LE:
    case OP_GT:
    case OP_LT:
      n2 = RelationalOptionalExpression();
        n1.addNode(n2);
      break;
    default:
      jj_la1[271] = jj_gen;
      ;
    }
     {if (true) return new RelationalExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public RelationalOptionalExpression RelationalOptionalExpression() throws ParseException {
   NodeChoice n0;
   RelationalLTExpression n1;
   RelationalGTExpression n2;
   RelationalLEExpression n3;
   RelationalGEExpression n4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_LT:
      n1 = RelationalLTExpression();
        n0 = new NodeChoice(n1, 0);
      break;
    case OP_GT:
      n2 = RelationalGTExpression();
        n0 = new NodeChoice(n2, 1);
      break;
    case OP_LE:
      n3 = RelationalLEExpression();
        n0 = new NodeChoice(n3, 2);
      break;
    case OP_GE:
      n4 = RelationalGEExpression();
        n0 = new NodeChoice(n4, 3);
      break;
    default:
      jj_la1[272] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new RelationalOptionalExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public RelationalLTExpression RelationalLTExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   RelationalExpression n2;
    n1 = jj_consume_token(OP_LT);
            n0 = JTBToolkit.makeNodeToken(n1);
    n2 = RelationalExpression();
     {if (true) return new RelationalLTExpression(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public RelationalGTExpression RelationalGTExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   RelationalExpression n2;
    n1 = jj_consume_token(OP_GT);
            n0 = JTBToolkit.makeNodeToken(n1);
    n2 = RelationalExpression();
     {if (true) return new RelationalGTExpression(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public RelationalLEExpression RelationalLEExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   RelationalExpression n2;
    n1 = jj_consume_token(OP_LE);
             n0 = JTBToolkit.makeNodeToken(n1);
    n2 = RelationalExpression();
     {if (true) return new RelationalLEExpression(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public RelationalGEExpression RelationalGEExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   RelationalExpression n2;
    n1 = jj_consume_token(OP_GE);
             n0 = JTBToolkit.makeNodeToken(n1);
    n2 = RelationalExpression();
     {if (true) return new RelationalGEExpression(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public ShiftExpression ShiftExpression() throws ParseException {
   AdditiveExpression n0;
   NodeOptional n1 = new NodeOptional();
   ShiftOptionalExpression n2;
    n0 = AdditiveExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_SL:
    case OP_SR:
      n2 = ShiftOptionalExpression();
        n1.addNode(n2);
      break;
    default:
      jj_la1[273] = jj_gen;
      ;
    }
     {if (true) return new ShiftExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public ShiftOptionalExpression ShiftOptionalExpression() throws ParseException {
   NodeChoice n0;
   ShiftLeftExpression n1;
   ShiftRightExpression n2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_SR:
      n1 = ShiftLeftExpression();
        n0 = new NodeChoice(n1, 0);
      break;
    case OP_SL:
      n2 = ShiftRightExpression();
        n0 = new NodeChoice(n2, 1);
      break;
    default:
      jj_la1[274] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new ShiftOptionalExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ShiftLeftExpression ShiftLeftExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   ShiftExpression n2;
    n1 = jj_consume_token(OP_SR);
             n0 = JTBToolkit.makeNodeToken(n1);
    n2 = ShiftExpression();
     {if (true) return new ShiftLeftExpression(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public ShiftRightExpression ShiftRightExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   ShiftExpression n2;
    n1 = jj_consume_token(OP_SL);
             n0 = JTBToolkit.makeNodeToken(n1);
    n2 = ShiftExpression();
     {if (true) return new ShiftRightExpression(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public AdditiveExpression AdditiveExpression() throws ParseException {
   MultiplicativeExpression n0;
   NodeOptional n1 = new NodeOptional();
   AdditiveOptionalExpression n2;
    n0 = MultiplicativeExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_ADD:
    case OP_SUB:
      n2 = AdditiveOptionalExpression();
        n1.addNode(n2);
      break;
    default:
      jj_la1[275] = jj_gen;
      ;
    }
     {if (true) return new AdditiveExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public AdditiveOptionalExpression AdditiveOptionalExpression() throws ParseException {
   NodeChoice n0;
   AdditivePlusExpression n1;
   AdditiveMinusExpression n2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_ADD:
      n1 = AdditivePlusExpression();
        n0 = new NodeChoice(n1, 0);
      break;
    case OP_SUB:
      n2 = AdditiveMinusExpression();
        n0 = new NodeChoice(n2, 1);
      break;
    default:
      jj_la1[276] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new AdditiveOptionalExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public AdditivePlusExpression AdditivePlusExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   AdditiveExpression n2;
    n1 = jj_consume_token(OP_ADD);
            n0 = JTBToolkit.makeNodeToken(n1);
    n2 = AdditiveExpression();
     {if (true) return new AdditivePlusExpression(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public AdditiveMinusExpression AdditiveMinusExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   AdditiveExpression n2;
    n1 = jj_consume_token(OP_SUB);
            n0 = JTBToolkit.makeNodeToken(n1);
    n2 = AdditiveExpression();
     {if (true) return new AdditiveMinusExpression(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public MultiplicativeExpression MultiplicativeExpression() throws ParseException {
   CastExpression n0;
   NodeOptional n1 = new NodeOptional();
   MultiplicativeOptionalExpression n2;
    n0 = CastExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_MUL:
    case OP_DIV:
    case OP_MOD:
      n2 = MultiplicativeOptionalExpression();
        n1.addNode(n2);
      break;
    default:
      jj_la1[277] = jj_gen;
      ;
    }
     {if (true) return new MultiplicativeExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public MultiplicativeOptionalExpression MultiplicativeOptionalExpression() throws ParseException {
   NodeChoice n0;
   MultiplicativeMultiExpression n1;
   MultiplicativeDivExpression n2;
   MultiplicativeModExpression n3;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_MUL:
      n1 = MultiplicativeMultiExpression();
        n0 = new NodeChoice(n1, 0);
      break;
    case OP_DIV:
      n2 = MultiplicativeDivExpression();
        n0 = new NodeChoice(n2, 1);
      break;
    case OP_MOD:
      n3 = MultiplicativeModExpression();
        n0 = new NodeChoice(n3, 2);
      break;
    default:
      jj_la1[278] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new MultiplicativeOptionalExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public MultiplicativeMultiExpression MultiplicativeMultiExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   MultiplicativeExpression n2;
    n1 = jj_consume_token(OP_MUL);
            n0 = JTBToolkit.makeNodeToken(n1);
    n2 = MultiplicativeExpression();
     {if (true) return new MultiplicativeMultiExpression(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public MultiplicativeDivExpression MultiplicativeDivExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   MultiplicativeExpression n2;
    n1 = jj_consume_token(OP_DIV);
            n0 = JTBToolkit.makeNodeToken(n1);
    n2 = MultiplicativeExpression();
     {if (true) return new MultiplicativeDivExpression(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public MultiplicativeModExpression MultiplicativeModExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   MultiplicativeExpression n2;
    n1 = jj_consume_token(OP_MOD);
            n0 = JTBToolkit.makeNodeToken(n1);
    n2 = MultiplicativeExpression();
     {if (true) return new MultiplicativeModExpression(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public CastExpression CastExpression() throws ParseException {
   NodeChoice n0;
   CastExpressionTyped n1;
   UnaryExpression n2;
    if (jj_2_146(2147483647)) {
      n1 = CastExpressionTyped();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case _GENERIC:
      case SIZEOF:
      case OP_INCR:
      case OP_DECR:
      case OP_ADD:
      case OP_SUB:
      case OP_MUL:
      case OP_BITAND:
      case OP_NOT:
      case OP_BITNOT:
      case LEFTPAREN:
      case IDENTIFIER:
        n2 = UnaryExpression();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[279] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new CastExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public CastExpressionTyped CastExpressionTyped() throws ParseException {
   NodeToken n0;
   Token n1;
   TypeName n2;
   NodeToken n3;
   Token n4;
   CastExpression n5;
    n1 = jj_consume_token(LEFTPAREN);
            n0 = JTBToolkit.makeNodeToken(n1);
    n2 = TypeName();
    n4 = jj_consume_token(RIGHTPAREN);
            n3 = JTBToolkit.makeNodeToken(n4);
    n5 = CastExpression();
     {if (true) return new CastExpressionTyped(n0,n2,n3,n5);}
    throw new Error("Missing return statement in function");
  }

  final public UnaryExpression UnaryExpression() throws ParseException {
   NodeChoice n0;
   UnaryExpressionPreIncrement n1;
   UnaryExpressionPreDecrement n2;
   UnarySizeofExpression n3;
   UnaryCastExpression n4;
   PostfixExpression n5;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_INCR:
      n1 = UnaryExpressionPreIncrement();
        n0 = new NodeChoice(n1, 0);
      break;
    case OP_DECR:
      n2 = UnaryExpressionPreDecrement();
        n0 = new NodeChoice(n2, 1);
      break;
    case SIZEOF:
      n3 = UnarySizeofExpression();
        n0 = new NodeChoice(n3, 2);
      break;
    case OP_ADD:
    case OP_SUB:
    case OP_MUL:
    case OP_BITAND:
    case OP_NOT:
    case OP_BITNOT:
      n4 = UnaryCastExpression();
        n0 = new NodeChoice(n4, 3);
      break;
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case _GENERIC:
    case LEFTPAREN:
    case IDENTIFIER:
      n5 = PostfixExpression();
        n0 = new NodeChoice(n5, 4);
      break;
    default:
      jj_la1[280] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new UnaryExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public UnaryExpressionPreIncrement UnaryExpressionPreIncrement() throws ParseException {
   NodeToken n0;
   Token n1;
   UnaryExpression n2;
    n1 = jj_consume_token(OP_INCR);
             n0 = JTBToolkit.makeNodeToken(n1);
    n2 = UnaryExpression();
     {if (true) return new UnaryExpressionPreIncrement(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public UnaryExpressionPreDecrement UnaryExpressionPreDecrement() throws ParseException {
   NodeToken n0;
   Token n1;
   UnaryExpression n2;
    n1 = jj_consume_token(OP_DECR);
             n0 = JTBToolkit.makeNodeToken(n1);
    n2 = UnaryExpression();
     {if (true) return new UnaryExpressionPreDecrement(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public UnaryCastExpression UnaryCastExpression() throws ParseException {
   UnaryOperator n0;
   CastExpression n1;
    n0 = UnaryOperator();
    n1 = CastExpression();
     {if (true) return new UnaryCastExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public UnarySizeofExpression UnarySizeofExpression() throws ParseException {
   NodeChoice n0;
   SizeofTypeName n1;
   SizeofUnaryExpression n2;
    if (jj_2_147(2147483647)) {
      n1 = SizeofTypeName();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
        n2 = SizeofUnaryExpression();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[281] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new UnarySizeofExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public SizeofUnaryExpression SizeofUnaryExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   UnaryExpression n2;
    n1 = jj_consume_token(SIZEOF);
                 n0 = JTBToolkit.makeNodeToken(n1);
    n2 = UnaryExpression();
     {if (true) return new SizeofUnaryExpression(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public SizeofTypeName SizeofTypeName() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   TypeName n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(SIZEOF);
                 n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = TypeName();
    n6 = jj_consume_token(RIGHTPAREN);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new SizeofTypeName(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public UnaryOperator UnaryOperator() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_BITAND:
      n2 = jj_consume_token(OP_BITAND);
               n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case OP_MUL:
      n4 = jj_consume_token(OP_MUL);
               n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case OP_ADD:
      n6 = jj_consume_token(OP_ADD);
               n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case OP_SUB:
      n8 = jj_consume_token(OP_SUB);
               n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
      break;
    case OP_BITNOT:
      n10 = jj_consume_token(OP_BITNOT);
                n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4);
      break;
    case OP_NOT:
      n12 = jj_consume_token(OP_NOT);
                n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5);
      break;
    default:
      jj_la1[282] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new UnaryOperator(n0);}
    throw new Error("Missing return statement in function");
  }

  final public PostfixExpression PostfixExpression() throws ParseException {
   PrimaryExpression n0;
   PostfixOperationsList n1;
    n0 = PrimaryExpression();
    n1 = PostfixOperationsList();
     {if (true) return new PostfixExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public PostfixOperationsList PostfixOperationsList() throws ParseException {
   NodeListOptional n0 = new NodeListOptional();
   APostfixOperation n1;
    label_60:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OP_DEREF:
      case OP_INCR:
      case OP_DECR:
      case DOT:
      case LEFTPAREN:
      case LEFTBRACKET:
        ;
        break;
      default:
        jj_la1[283] = jj_gen;
        break label_60;
      }
      n1 = APostfixOperation();
        n0.addNode(n1);
    }
     n0.nodes.trimToSize();
     {if (true) return new PostfixOperationsList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public APostfixOperation APostfixOperation() throws ParseException {
   NodeChoice n0;
   BracketExpression n1;
   ArgumentList n2;
   DotId n3;
   ArrowId n4;
   PlusPlus n5;
   MinusMinus n6;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFTBRACKET:
      n1 = BracketExpression();
        n0 = new NodeChoice(n1, 0);
      break;
    case LEFTPAREN:
      n2 = ArgumentList();
        n0 = new NodeChoice(n2, 1);
      break;
    case DOT:
      n3 = DotId();
        n0 = new NodeChoice(n3, 2);
      break;
    case OP_DEREF:
      n4 = ArrowId();
        n0 = new NodeChoice(n4, 3);
      break;
    case OP_INCR:
      n5 = PlusPlus();
        n0 = new NodeChoice(n5, 4);
      break;
    case OP_DECR:
      n6 = MinusMinus();
        n0 = new NodeChoice(n6, 5);
      break;
    default:
      jj_la1[284] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new APostfixOperation(n0);}
    throw new Error("Missing return statement in function");
  }

  final public PlusPlus PlusPlus() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(OP_INCR);
             n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new PlusPlus(n0);}
    throw new Error("Missing return statement in function");
  }

  final public MinusMinus MinusMinus() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(OP_DECR);
             n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new MinusMinus(n0);}
    throw new Error("Missing return statement in function");
  }

  final public BracketExpression BracketExpression() throws ParseException {
   NodeToken n0;
   Token n1;
   Expression n2;
   NodeToken n3;
   Token n4;
    n1 = jj_consume_token(LEFTBRACKET);
            n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Expression();
    n4 = jj_consume_token(RIGHTBRACKET);
            n3 = JTBToolkit.makeNodeToken(n4);
     {if (true) return new BracketExpression(n0,n2,n3);}
    throw new Error("Missing return statement in function");
  }

  final public ArgumentList ArgumentList() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   ExpressionList n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(LEFTPAREN);
            n0 = JTBToolkit.makeNodeToken(n1);
    if (jj_2_148(2147483647)) {
      n3 = ExpressionList();
        n2.addNode(n3);
    } else {
      ;
    }
    n5 = jj_consume_token(RIGHTPAREN);
            n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new ArgumentList(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public DotId DotId() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
    n1 = jj_consume_token(DOT);
            n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(IDENTIFIER);
                     n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new DotId(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public ArrowId ArrowId() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
    n1 = jj_consume_token(OP_DEREF);
             n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(IDENTIFIER);
                     n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new ArrowId(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public PrimaryExpression PrimaryExpression() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   Constant n3;
   ExpressionClosed n4;
   GenericSelection n5;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      n2 = jj_consume_token(IDENTIFIER);
                        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
      n3 = Constant();
        n0 = new NodeChoice(n3, 1);
      break;
    case LEFTPAREN:
      n4 = ExpressionClosed();
        n0 = new NodeChoice(n4, 2);
      break;
    case _GENERIC:
      n5 = GenericSelection();
        n0 = new NodeChoice(n5, 3);
      break;
    default:
      jj_la1[285] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new PrimaryExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionClosed ExpressionClosed() throws ParseException {
   NodeToken n0;
   Token n1;
   Expression n2;
   NodeToken n3;
   Token n4;
    n1 = jj_consume_token(LEFTPAREN);
            n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Expression();
    n4 = jj_consume_token(RIGHTPAREN);
            n3 = JTBToolkit.makeNodeToken(n4);
     {if (true) return new ExpressionClosed(n0,n2,n3);}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionList ExpressionList() throws ParseException {
   AssignmentExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   AssignmentExpression n5;
    n0 = AssignmentExpression();
    label_61:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[286] = jj_gen;
        break label_61;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = AssignmentExpression();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new ExpressionList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public Constant Constant() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeList n7 = new NodeList();
   NodeToken n8;
   Token n9;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      n2 = jj_consume_token(INTEGER_LITERAL);
                             n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case FLOATING_POINT_LITERAL:
      n4 = jj_consume_token(FLOATING_POINT_LITERAL);
                                    n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case CHARACTER_LITERAL:
      n6 = jj_consume_token(CHARACTER_LITERAL);
                               n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case STRING_LITERAL:
      label_62:
      while (true) {
        n9 = jj_consume_token(STRING_LITERAL);
                               n8 = JTBToolkit.makeNodeToken(n9);
           n7.addNode(n8);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
          ;
          break;
        default:
          jj_la1[287] = jj_gen;
          break label_62;
        }
      }
        n7.nodes.trimToSize();
        n0 = new NodeChoice(n7, 3);
      break;
    default:
      jj_la1[288] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new Constant(n0);}
    throw new Error("Missing return statement in function");
  }

  final public GenericSelection GenericSelection() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   AssignmentExpression n4;
   NodeToken n5;
   Token n6;
   GenericAssocList n7;
   NodeToken n8;
   Token n9;
    n1 = jj_consume_token(_GENERIC);
                   n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LEFTPAREN);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = AssignmentExpression();
    n6 = jj_consume_token(COMMA);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = GenericAssocList();
    n9 = jj_consume_token(RIGHTPAREN);
            n8 = JTBToolkit.makeNodeToken(n9);
     {if (true) return new GenericSelection(n0,n2,n4,n5,n7,n8);}
    throw new Error("Missing return statement in function");
  }

  final public GenericAssocList GenericAssocList() throws ParseException {
   GenericAssociation n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   GenericAssociation n5;
    n0 = GenericAssociation();
    label_63:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[289] = jj_gen;
        break label_63;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = GenericAssociation();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new GenericAssocList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public GenericAssociation GenericAssociation() throws ParseException {
   NodeChoice n0;
   NodeSequence n1;
   TypeName n2;
   NodeToken n3;
   Token n4;
   AssignmentExpression n5;
   NodeSequence n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   AssignmentExpression n11;
    if (jj_2_149(1)) {
        n1 = new NodeSequence(3);
      n2 = TypeName();
        n1.addNode(n2);
      n4 = jj_consume_token(COLON);
               n3 = JTBToolkit.makeNodeToken(n4);
        n1.addNode(n3);
      n5 = AssignmentExpression();
        n1.addNode(n5);
        n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
        n6 = new NodeSequence(3);
        n8 = jj_consume_token(DFLT);
                  n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
        n10 = jj_consume_token(COLON);
                n9 = JTBToolkit.makeNodeToken(n10);
        n6.addNode(n9);
        n11 = AssignmentExpression();
        n6.addNode(n11);
        n0 = new NodeChoice(n6, 1);
        break;
      default:
        jj_la1[290] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new GenericAssociation(n0);}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  private boolean jj_2_46(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_46(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(45, xla); }
  }

  private boolean jj_2_47(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_47(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(46, xla); }
  }

  private boolean jj_2_48(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_48(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(47, xla); }
  }

  private boolean jj_2_49(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_49(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(48, xla); }
  }

  private boolean jj_2_50(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_50(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(49, xla); }
  }

  private boolean jj_2_51(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_51(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(50, xla); }
  }

  private boolean jj_2_52(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_52(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(51, xla); }
  }

  private boolean jj_2_53(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_53(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(52, xla); }
  }

  private boolean jj_2_54(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_54(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(53, xla); }
  }

  private boolean jj_2_55(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_55(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(54, xla); }
  }

  private boolean jj_2_56(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_56(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(55, xla); }
  }

  private boolean jj_2_57(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_57(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(56, xla); }
  }

  private boolean jj_2_58(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_58(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(57, xla); }
  }

  private boolean jj_2_59(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_59(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(58, xla); }
  }

  private boolean jj_2_60(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_60(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(59, xla); }
  }

  private boolean jj_2_61(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_61(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(60, xla); }
  }

  private boolean jj_2_62(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_62(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(61, xla); }
  }

  private boolean jj_2_63(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_63(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(62, xla); }
  }

  private boolean jj_2_64(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_64(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(63, xla); }
  }

  private boolean jj_2_65(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_65(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(64, xla); }
  }

  private boolean jj_2_66(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_66(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(65, xla); }
  }

  private boolean jj_2_67(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_67(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(66, xla); }
  }

  private boolean jj_2_68(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_68(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(67, xla); }
  }

  private boolean jj_2_69(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_69(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(68, xla); }
  }

  private boolean jj_2_70(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_70(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(69, xla); }
  }

  private boolean jj_2_71(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_71(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(70, xla); }
  }

  private boolean jj_2_72(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_72(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(71, xla); }
  }

  private boolean jj_2_73(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_73(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(72, xla); }
  }

  private boolean jj_2_74(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_74(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(73, xla); }
  }

  private boolean jj_2_75(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_75(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(74, xla); }
  }

  private boolean jj_2_76(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_76(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(75, xla); }
  }

  private boolean jj_2_77(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_77(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(76, xla); }
  }

  private boolean jj_2_78(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_78(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(77, xla); }
  }

  private boolean jj_2_79(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_79(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(78, xla); }
  }

  private boolean jj_2_80(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_80(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(79, xla); }
  }

  private boolean jj_2_81(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_81(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(80, xla); }
  }

  private boolean jj_2_82(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_82(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(81, xla); }
  }

  private boolean jj_2_83(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_83(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(82, xla); }
  }

  private boolean jj_2_84(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_84(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(83, xla); }
  }

  private boolean jj_2_85(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_85(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(84, xla); }
  }

  private boolean jj_2_86(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_86(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(85, xla); }
  }

  private boolean jj_2_87(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_87(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(86, xla); }
  }

  private boolean jj_2_88(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_88(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(87, xla); }
  }

  private boolean jj_2_89(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_89(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(88, xla); }
  }

  private boolean jj_2_90(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_90(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(89, xla); }
  }

  private boolean jj_2_91(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_91(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(90, xla); }
  }

  private boolean jj_2_92(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_92(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(91, xla); }
  }

  private boolean jj_2_93(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_93(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(92, xla); }
  }

  private boolean jj_2_94(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_94(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(93, xla); }
  }

  private boolean jj_2_95(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_95(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(94, xla); }
  }

  private boolean jj_2_96(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_96(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(95, xla); }
  }

  private boolean jj_2_97(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_97(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(96, xla); }
  }

  private boolean jj_2_98(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_98(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(97, xla); }
  }

  private boolean jj_2_99(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_99(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(98, xla); }
  }

  private boolean jj_2_100(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_100(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(99, xla); }
  }

  private boolean jj_2_101(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_101(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(100, xla); }
  }

  private boolean jj_2_102(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_102(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(101, xla); }
  }

  private boolean jj_2_103(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_103(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(102, xla); }
  }

  private boolean jj_2_104(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_104(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(103, xla); }
  }

  private boolean jj_2_105(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_105(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(104, xla); }
  }

  private boolean jj_2_106(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_106(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(105, xla); }
  }

  private boolean jj_2_107(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_107(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(106, xla); }
  }

  private boolean jj_2_108(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_108(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(107, xla); }
  }

  private boolean jj_2_109(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_109(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(108, xla); }
  }

  private boolean jj_2_110(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_110(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(109, xla); }
  }

  private boolean jj_2_111(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_111(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(110, xla); }
  }

  private boolean jj_2_112(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_112(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(111, xla); }
  }

  private boolean jj_2_113(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_113(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(112, xla); }
  }

  private boolean jj_2_114(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_114(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(113, xla); }
  }

  private boolean jj_2_115(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_115(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(114, xla); }
  }

  private boolean jj_2_116(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_116(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(115, xla); }
  }

  private boolean jj_2_117(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_117(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(116, xla); }
  }

  private boolean jj_2_118(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_118(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(117, xla); }
  }

  private boolean jj_2_119(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_119(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(118, xla); }
  }

  private boolean jj_2_120(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_120(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(119, xla); }
  }

  private boolean jj_2_121(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_121(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(120, xla); }
  }

  private boolean jj_2_122(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_122(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(121, xla); }
  }

  private boolean jj_2_123(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_123(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(122, xla); }
  }

  private boolean jj_2_124(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_124(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(123, xla); }
  }

  private boolean jj_2_125(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_125(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(124, xla); }
  }

  private boolean jj_2_126(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_126(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(125, xla); }
  }

  private boolean jj_2_127(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_127(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(126, xla); }
  }

  private boolean jj_2_128(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_128(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(127, xla); }
  }

  private boolean jj_2_129(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_129(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(128, xla); }
  }

  private boolean jj_2_130(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_130(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(129, xla); }
  }

  private boolean jj_2_131(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_131(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(130, xla); }
  }

  private boolean jj_2_132(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_132(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(131, xla); }
  }

  private boolean jj_2_133(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_133(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(132, xla); }
  }

  private boolean jj_2_134(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_134(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(133, xla); }
  }

  private boolean jj_2_135(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_135(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(134, xla); }
  }

  private boolean jj_2_136(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_136(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(135, xla); }
  }

  private boolean jj_2_137(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_137(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(136, xla); }
  }

  private boolean jj_2_138(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_138(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(137, xla); }
  }

  private boolean jj_2_139(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_139(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(138, xla); }
  }

  private boolean jj_2_140(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_140(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(139, xla); }
  }

  private boolean jj_2_141(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_141(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(140, xla); }
  }

  private boolean jj_2_142(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_142(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(141, xla); }
  }

  private boolean jj_2_143(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_143(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(142, xla); }
  }

  private boolean jj_2_144(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_144(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(143, xla); }
  }

  private boolean jj_2_145(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_145(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(144, xla); }
  }

  private boolean jj_2_146(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_146(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(145, xla); }
  }

  private boolean jj_2_147(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_147(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(146, xla); }
  }

  private boolean jj_2_148(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_148(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(147, xla); }
  }

  private boolean jj_2_149(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_149(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(148, xla); }
  }

  private boolean jj_3R_898() {
    if (jj_scan_token(THREADS)) return true;
    return false;
  }

  private boolean jj_3R_418() {
    Token xsp;
    if (jj_3R_497()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_497()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_470() {
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_567() {
    if (jj_scan_token(INOUT)) return true;
    return false;
  }

  private boolean jj_3R_566() {
    if (jj_scan_token(OUT)) return true;
    return false;
  }

  private boolean jj_3R_361() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_470()) jj_scanpos = xsp;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_565() {
    if (jj_scan_token(IN)) return true;
    return false;
  }

  private boolean jj_3R_359() {
    if (jj_scan_token(REDUCTION)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_469()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_466()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_855() {
    if (jj_3R_900()) return true;
    return false;
  }

  private boolean jj_3R_562() {
    if (jj_scan_token(OP_AND)) return true;
    return false;
  }

  private boolean jj_3R_334() {
    if (jj_3R_210()) return true;
    return false;
  }

  private boolean jj_3R_472() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_565()) {
    jj_scanpos = xsp;
    if (jj_3R_566()) {
    jj_scanpos = xsp;
    if (jj_3R_567()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_561() {
    if (jj_scan_token(OP_OR)) return true;
    return false;
  }

  private boolean jj_3_127() {
    if (jj_3R_157()) return true;
    return false;
  }

  private boolean jj_3R_333() {
    if (jj_3R_418()) return true;
    return false;
  }

  private boolean jj_3R_854() {
    if (jj_3R_899()) return true;
    return false;
  }

  private boolean jj_3R_560() {
    if (jj_scan_token(OP_BITOR)) return true;
    return false;
  }

  private boolean jj_3R_332() {
    if (jj_scan_token(OP_BITXOR)) return true;
    return false;
  }

  private boolean jj_3R_853() {
    if (jj_3R_898()) return true;
    return false;
  }

  private boolean jj_3R_559() {
    if (jj_scan_token(OP_BITXOR)) return true;
    return false;
  }

  private boolean jj_3R_331() {
    if (jj_scan_token(OP_MUL)) return true;
    return false;
  }

  private boolean jj_3R_558() {
    if (jj_scan_token(OP_BITAND)) return true;
    return false;
  }

  private boolean jj_3R_660() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_853()) {
    jj_scanpos = xsp;
    if (jj_3R_854()) {
    jj_scanpos = xsp;
    if (jj_3_127()) {
    jj_scanpos = xsp;
    if (jj_3R_855()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_557() {
    if (jj_scan_token(OP_SUB)) return true;
    return false;
  }

  private boolean jj_3R_556() {
    if (jj_scan_token(OP_MUL)) return true;
    return false;
  }

  private boolean jj_3R_210() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_331()) {
    jj_scanpos = xsp;
    if (jj_3R_332()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_333()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_334()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_249() {
    if (jj_3R_368()) return true;
    return false;
  }

  private boolean jj_3R_555() {
    if (jj_scan_token(OP_ADD)) return true;
    return false;
  }

  private boolean jj_3R_376() {
    if (jj_scan_token(COPYIN)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_466()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_248() {
    if (jj_3R_367()) return true;
    return false;
  }

  private boolean jj_3R_554() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_368() {
    if (jj_scan_token(DEPEND)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_472()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_466()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_247() {
    if (jj_3R_366()) return true;
    return false;
  }

  private boolean jj_3R_469() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_554()) {
    jj_scanpos = xsp;
    if (jj_3R_555()) {
    jj_scanpos = xsp;
    if (jj_3R_556()) {
    jj_scanpos = xsp;
    if (jj_3R_557()) {
    jj_scanpos = xsp;
    if (jj_3R_558()) {
    jj_scanpos = xsp;
    if (jj_3R_559()) {
    jj_scanpos = xsp;
    if (jj_3R_560()) {
    jj_scanpos = xsp;
    if (jj_3R_561()) {
    jj_scanpos = xsp;
    if (jj_3R_562()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_246() {
    if (jj_3R_365()) return true;
    return false;
  }

  private boolean jj_3R_856() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_245() {
    if (jj_3R_364()) return true;
    return false;
  }

  private boolean jj_3R_244() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3R_661() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_856()) jj_scanpos = xsp;
    if (jj_3R_660()) return true;
    return false;
  }

  private boolean jj_3R_243() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_242() {
    if (jj_3R_362()) return true;
    return false;
  }

  private boolean jj_3R_534() {
    if (jj_3R_660()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_661()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_416() {
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_81()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_372() {
    if (jj_scan_token(SHARED)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_466()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_241() {
    if (jj_3R_361()) return true;
    return false;
  }

  private boolean jj_3R_890() {
    if (jj_scan_token(MERGEABLE)) return true;
    return false;
  }

  private boolean jj_3R_150() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_241()) {
    jj_scanpos = xsp;
    if (jj_3R_242()) {
    jj_scanpos = xsp;
    if (jj_3R_243()) {
    jj_scanpos = xsp;
    if (jj_3R_244()) {
    jj_scanpos = xsp;
    if (jj_3R_245()) {
    jj_scanpos = xsp;
    if (jj_3R_246()) {
    jj_scanpos = xsp;
    if (jj_3R_247()) {
    jj_scanpos = xsp;
    if (jj_3R_248()) {
    jj_scanpos = xsp;
    if (jj_3R_249()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_415() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_328() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_415()) {
    jj_scanpos = xsp;
    if (jj_3R_416()) return true;
    }
    return false;
  }

  private boolean jj_3R_889() {
    if (jj_scan_token(UNTIED)) return true;
    return false;
  }

  private boolean jj_3R_451() {
    if (jj_3R_534()) return true;
    return false;
  }

  private boolean jj_3R_363() {
    if (jj_scan_token(FIRSTPRIVATE)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_466()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_340() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(ORDERED)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_451()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_813() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_888() {
    if (jj_scan_token(FINAL)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_636() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_813()) jj_scanpos = xsp;
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_883() {
    if (jj_3R_915()) return true;
    return false;
  }

  private boolean jj_3R_521() {
    if (jj_3R_150()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_636()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_693() {
    if (jj_scan_token(LEFTPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_883()) jj_scanpos = xsp;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_851() {
    if (jj_scan_token(CAPTURE)) return true;
    return false;
  }

  private boolean jj_3R_357() {
    if (jj_scan_token(PRIVATE)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_466()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_850() {
    if (jj_scan_token(UPDATE)) return true;
    return false;
  }

  private boolean jj_3R_849() {
    if (jj_scan_token(WRITE)) return true;
    return false;
  }

  private boolean jj_3R_848() {
    if (jj_scan_token(READ)) return true;
    return false;
  }

  private boolean jj_3R_168() {
    if (jj_scan_token(INITIALIZER)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_ASS)) return true;
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3R_658() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_848()) {
    jj_scanpos = xsp;
    if (jj_3R_849()) {
    jj_scanpos = xsp;
    if (jj_3R_850()) {
    jj_scanpos = xsp;
    if (jj_3R_851()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_921() {
    if (jj_scan_token(TASK)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3_19() {
    if (jj_3R_79()) return true;
    return false;
  }

  private boolean jj_3R_439() {
    if (jj_3R_521()) return true;
    return false;
  }

  private boolean jj_3R_887() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_921()) jj_scanpos = xsp;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_scan_token(LEFTPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_19()) jj_scanpos = xsp;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_371() {
    if (jj_scan_token(DFLT)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_scan_token(NONE)) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_110() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TARGET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_439()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_852() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3_113() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3_143() {
    if (jj_3R_168()) return true;
    return false;
  }

  private boolean jj_3R_694() {
    if (jj_3R_397()) return true;
    return false;
  }

  private boolean jj_3R_811() {
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3R_659() {
    if (jj_scan_token(SEQCST)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_852()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_731() {
    if (jj_3R_891()) return true;
    return false;
  }

  private boolean jj_3R_593() {
    if (jj_scan_token(LEFTBRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_694()) jj_scanpos = xsp;
    if (jj_scan_token(RIGHTBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_810() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_135() {
    if (jj_scan_token(DFLT)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_scan_token(SHARED)) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_730() {
    if (jj_3R_368()) return true;
    return false;
  }

  private boolean jj_3R_847() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_634() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_810()) {
    jj_scanpos = xsp;
    if (jj_3R_811()) return true;
    }
    return false;
  }

  private boolean jj_3R_729() {
    if (jj_3R_372()) return true;
    return false;
  }

  private boolean jj_3R_728() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3_142() {
    if (jj_3R_72()) return true;
    return false;
  }

  private boolean jj_3R_727() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_657() {
    if (jj_scan_token(SEQCST)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_847()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_726() {
    if (jj_3R_890()) return true;
    return false;
  }

  private boolean jj_3R_592() {
    if (jj_3R_693()) return true;
    return false;
  }

  private boolean jj_3R_725() {
    if (jj_3R_371()) return true;
    return false;
  }

  private boolean jj_3R_352() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(ATOMIC)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_657()) jj_scanpos = xsp;
    if (jj_3R_658()) return true;
    xsp = jj_scanpos;
    if (jj_3R_659()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3_18() {
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_812() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3_92() {
    if (jj_3R_135()) return true;
    return false;
  }

  private boolean jj_3R_591() {
    if (jj_3R_593()) return true;
    return false;
  }

  private boolean jj_3R_375() {
    if (jj_scan_token(NUM_THREADS)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_724() {
    if (jj_3R_889()) return true;
    return false;
  }

  private boolean jj_3R_635() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_812()) jj_scanpos = xsp;
    if (jj_3R_634()) return true;
    return false;
  }

  private boolean jj_3R_496() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_591()) {
    jj_scanpos = xsp;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3R_592()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_723() {
    if (jj_3R_888()) return true;
    return false;
  }

  private boolean jj_3R_722() {
    if (jj_3R_887()) return true;
    return false;
  }

  private boolean jj_3R_520() {
    if (jj_3R_634()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_635()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_611() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_722()) {
    jj_scanpos = xsp;
    if (jj_3R_723()) {
    jj_scanpos = xsp;
    if (jj_3R_724()) {
    jj_scanpos = xsp;
    if (jj_3_92()) {
    jj_scanpos = xsp;
    if (jj_3R_725()) {
    jj_scanpos = xsp;
    if (jj_3R_726()) {
    jj_scanpos = xsp;
    if (jj_3R_727()) {
    jj_scanpos = xsp;
    if (jj_3R_728()) {
    jj_scanpos = xsp;
    if (jj_3R_729()) {
    jj_scanpos = xsp;
    if (jj_3R_730()) {
    jj_scanpos = xsp;
    if (jj_3R_731()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_489() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(DECLARE)) return true;
    return false;
  }

  private boolean jj_3R_417() {
    if (jj_3R_496()) return true;
    return false;
  }

  private boolean jj_3R_329() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_417()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_475() {
    if (jj_scan_token(PARALLEL)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_846() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_438() {
    if (jj_3R_520()) return true;
    return false;
  }

  private boolean jj_3R_374() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_475()) jj_scanpos = xsp;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_155() {
    if (jj_scan_token(SEQCST)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(111)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_656() {
    if (jj_scan_token(SEQCST)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_846()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_109() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(TEAMS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_438()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_732() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_207() {
    if (jj_3R_328()) return true;
    if (jj_3R_329()) return true;
    return false;
  }

  private boolean jj_3R_351() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(ATOMIC)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_656()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_612() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_732()) jj_scanpos = xsp;
    if (jj_3R_611()) return true;
    return false;
  }

  private boolean jj_3R_509() {
    if (jj_3R_611()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_612()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_112() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_206() {
    if (jj_3R_210()) return true;
    return false;
  }

  private boolean jj_3R_270() {
    if (jj_3R_377()) return true;
    return false;
  }

  private boolean jj_3R_166() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(THREADPRIVATE)) return true;
    return false;
  }

  private boolean jj_3R_808() {
    if (jj_3R_643()) return true;
    return false;
  }

  private boolean jj_3R_81() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_206()) jj_scanpos = xsp;
    if (jj_3R_207()) return true;
    return false;
  }

  private boolean jj_3_78() {
    if (jj_3R_137()) return true;
    return false;
  }

  private boolean jj_3_126() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(ATOMIC)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_155()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    return false;
  }

  private boolean jj_3R_807() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3_77() {
    if (jj_3R_136()) return true;
    return false;
  }

  private boolean jj_3R_632() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_807()) {
    jj_scanpos = xsp;
    if (jj_3R_808()) return true;
    }
    return false;
  }

  private boolean jj_3R_269() {
    if (jj_3R_359()) return true;
    return false;
  }

  private boolean jj_3R_232() {
    if (jj_3R_352()) return true;
    return false;
  }

  private boolean jj_3_140() {
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_268() {
    if (jj_3R_376()) return true;
    return false;
  }

  private boolean jj_3R_427() {
    if (jj_3R_509()) return true;
    return false;
  }

  private boolean jj_3R_231() {
    if (jj_3R_351()) return true;
    return false;
  }

  private boolean jj_3R_267() {
    if (jj_3R_372()) return true;
    return false;
  }

  private boolean jj_3R_964() {
    if (jj_scan_token(OP_ASS)) return true;
    if (jj_3R_397()) return true;
    return false;
  }

  private boolean jj_3R_126() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_231()) {
    jj_scanpos = xsp;
    if (jj_3R_232()) return true;
    }
    return false;
  }

  private boolean jj_3_141() {
    if (jj_3R_68()) return true;
    return false;
  }

  private boolean jj_3R_266() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3R_97() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TASK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_427()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_265() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_291() {
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_327() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_964()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_809() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_264() {
    if (jj_3R_371()) return true;
    return false;
  }

  private boolean jj_3R_167() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_291()) {
    jj_scanpos = xsp;
    if (jj_3_141()) return true;
    }
    return false;
  }

  private boolean jj_3R_924() {
    if (jj_scan_token(DFLT)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_313()) return true;
    return false;
  }

  private boolean jj_3_76() {
    if (jj_3R_135()) return true;
    return false;
  }

  private boolean jj_3R_633() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_809()) jj_scanpos = xsp;
    if (jj_3R_632()) return true;
    return false;
  }

  private boolean jj_3_91() {
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3R_263() {
    if (jj_3R_375()) return true;
    return false;
  }

  private boolean jj_3R_262() {
    if (jj_3R_374()) return true;
    return false;
  }

  private boolean jj_3R_125() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TASKGROUP)) return true;
    if (jj_3R_156()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_519() {
    if (jj_3R_632()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_633()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_720() {
    if (jj_3R_595()) return true;
    return false;
  }

  private boolean jj_3_149() {
    if (jj_3R_172()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_313()) return true;
    return false;
  }

  private boolean jj_3R_153() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_262()) {
    jj_scanpos = xsp;
    if (jj_3R_263()) {
    jj_scanpos = xsp;
    if (jj_3_76()) {
    jj_scanpos = xsp;
    if (jj_3R_264()) {
    jj_scanpos = xsp;
    if (jj_3R_265()) {
    jj_scanpos = xsp;
    if (jj_3R_266()) {
    jj_scanpos = xsp;
    if (jj_3R_267()) {
    jj_scanpos = xsp;
    if (jj_3R_268()) {
    jj_scanpos = xsp;
    if (jj_3R_269()) {
    jj_scanpos = xsp;
    if (jj_3_77()) {
    jj_scanpos = xsp;
    if (jj_3_78()) {
    jj_scanpos = xsp;
    if (jj_3R_270()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_903() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_149()) {
    jj_scanpos = xsp;
    if (jj_3R_924()) return true;
    }
    return false;
  }

  private boolean jj_3R_719() {
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3R_945() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_327()) return true;
    return false;
  }

  private boolean jj_3R_609() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_719()) {
    jj_scanpos = xsp;
    if (jj_3R_720()) return true;
    }
    return false;
  }

  private boolean jj_3R_204() {
    if (jj_3R_327()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_945()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_532() {
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_437() {
    if (jj_3R_519()) return true;
    return false;
  }

  private boolean jj_3R_721() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_108() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(TEAMS)) return true;
    if (jj_scan_token(DISTRIBUTE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_437()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_695() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_610() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_721()) jj_scanpos = xsp;
    if (jj_3R_609()) return true;
    return false;
  }

  private boolean jj_3R_904() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_903()) return true;
    return false;
  }

  private boolean jj_3R_494() {
    if (jj_scan_token(ENUM)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_594() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_695()) jj_scanpos = xsp;
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_508() {
    if (jj_3R_609()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_610()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_870() {
    if (jj_3R_903()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_904()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_347() {
    if (jj_3R_153()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_594()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_533() {
    if (jj_scan_token(HINT)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3_111() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_203() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_805() {
    if (jj_3R_641()) return true;
    return false;
  }

  private boolean jj_3R_804() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_77() {
    if (jj_scan_token(ENUM)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_203()) jj_scanpos = xsp;
    if (jj_scan_token(LEFTBRACE)) return true;
    if (jj_3R_204()) return true;
    if (jj_scan_token(RIGHTBRACE)) return true;
    return false;
  }

  private boolean jj_3R_450() {
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_532()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_533()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_426() {
    if (jj_3R_508()) return true;
    return false;
  }

  private boolean jj_3R_630() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_804()) {
    jj_scanpos = xsp;
    if (jj_3R_805()) return true;
    }
    return false;
  }

  private boolean jj_3R_684() {
    if (jj_scan_token(_GENERIC)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_313()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_870()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_227() {
    if (jj_3R_347()) return true;
    return false;
  }

  private boolean jj_3R_124() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(CRITICAL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_450()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_96() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(SIMD)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_426()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_91() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(PARALLEL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_227()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_806() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_414() {
    if (jj_3R_494()) return true;
    return false;
  }

  private boolean jj_3_17() {
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_902() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_631() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_806()) jj_scanpos = xsp;
    if (jj_3R_630()) return true;
    return false;
  }

  private boolean jj_3R_323() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) {
    jj_scanpos = xsp;
    if (jj_3R_414()) return true;
    }
    return false;
  }

  private boolean jj_3R_869() {
    Token xsp;
    if (jj_3R_902()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_902()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_518() {
    if (jj_3R_630()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_631()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_86() {
    if (jj_scan_token(CROSSBAR)) return true;
    if (jj_scan_token(PRAGMA)) return true;
    if (jj_scan_token(UNKNOWN_CPP)) return true;
    return false;
  }

  private boolean jj_3R_868() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_468() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_867() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_866() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_356() {
    if (jj_scan_token(ALIGNED)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_466()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_468()) jj_scanpos = xsp;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_682() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_866()) {
    jj_scanpos = xsp;
    if (jj_3R_867()) {
    jj_scanpos = xsp;
    if (jj_3R_868()) {
    jj_scanpos = xsp;
    if (jj_3R_869()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_123() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(MASTER)) return true;
    if (jj_3R_156()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_881() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_397()) return true;
    return false;
  }

  private boolean jj_3R_154() {
    if (jj_scan_token(CROSSBAR)) return true;
    if (jj_scan_token(PRAGMA)) return true;
    if (jj_scan_token(OMP)) return true;
    return false;
  }

  private boolean jj_3R_436() {
    if (jj_3R_518()) return true;
    return false;
  }

  private boolean jj_3_125() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_465() {
    if (jj_3R_358()) return true;
    return false;
  }

  private boolean jj_3R_982() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_397()) return true;
    return false;
  }

  private boolean jj_3R_107() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(TEAMS)) return true;
    if (jj_scan_token(DISTRIBUTE)) return true;
    if (jj_scan_token(SIMD)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_436()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_464() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_880() {
    if (jj_3R_81()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_982()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_350() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_464()) {
    jj_scanpos = xsp;
    if (jj_3R_465()) return true;
    }
    return false;
  }

  private boolean jj_3R_217() {
    if (jj_3R_341()) return true;
    return false;
  }

  private boolean jj_3R_354() {
    if (jj_scan_token(SIMDLEN)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_314() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_313()) return true;
    return false;
  }

  private boolean jj_3_75() {
    if (jj_3R_134()) return true;
    return false;
  }

  private boolean jj_3R_384() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(DECLARE)) return true;
    if (jj_scan_token(SIMD)) return true;
    return false;
  }

  private boolean jj_3R_175() {
    if (jj_3R_313()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_314()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_74() {
    if (jj_3R_133()) return true;
    return false;
  }

  private boolean jj_3_73() {
    if (jj_3R_132()) return true;
    return false;
  }

  private boolean jj_3_110() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_230() {
    if (jj_3R_350()) return true;
    return false;
  }

  private boolean jj_3R_690() {
    if (jj_3R_881()) return true;
    return false;
  }

  private boolean jj_3_72() {
    if (jj_3R_131()) return true;
    return false;
  }

  private boolean jj_3R_802() {
    if (jj_3R_639()) return true;
    return false;
  }

  private boolean jj_3R_689() {
    if (jj_3R_880()) return true;
    return false;
  }

  private boolean jj_3_71() {
    if (jj_3R_130()) return true;
    return false;
  }

  private boolean jj_3R_122() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(PARALLEL)) return true;
    if (jj_scan_token(SECTIONS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_230()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_423()) return true;
    return false;
  }

  private boolean jj_3R_801() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_589() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_689()) {
    jj_scanpos = xsp;
    if (jj_3R_690()) return true;
    }
    return false;
  }

  private boolean jj_3R_353() {
    if (jj_scan_token(SAFELEN)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3_70() {
    if (jj_3R_129()) return true;
    return false;
  }

  private boolean jj_3R_683() {
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_628() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_801()) {
    jj_scanpos = xsp;
    if (jj_3R_802()) return true;
    }
    return false;
  }

  private boolean jj_3R_290() {
    if (jj_3R_384()) return true;
    return false;
  }

  private boolean jj_3_69() {
    if (jj_3R_128()) return true;
    return false;
  }

  private boolean jj_3_68() {
    if (jj_3R_127()) return true;
    return false;
  }

  private boolean jj_3R_88() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_68()) {
    jj_scanpos = xsp;
    if (jj_3_69()) {
    jj_scanpos = xsp;
    if (jj_3_70()) {
    jj_scanpos = xsp;
    if (jj_3_71()) {
    jj_scanpos = xsp;
    if (jj_3_72()) {
    jj_scanpos = xsp;
    if (jj_3_73()) {
    jj_scanpos = xsp;
    if (jj_3_74()) {
    jj_scanpos = xsp;
    if (jj_3_75()) {
    jj_scanpos = xsp;
    if (jj_3R_217()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_240() {
    if (jj_3R_360()) return true;
    return false;
  }

  private boolean jj_3R_981() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_589()) return true;
    return false;
  }

  private boolean jj_3R_584() {
    if (jj_3R_684()) return true;
    return false;
  }

  private boolean jj_3R_551() {
    if (jj_3R_663()) return true;
    return false;
  }

  private boolean jj_3R_803() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_239() {
    if (jj_3R_359()) return true;
    return false;
  }

  private boolean jj_3R_165() {
    if (jj_3R_290()) return true;
    return false;
  }

  private boolean jj_3R_583() {
    if (jj_3R_683()) return true;
    return false;
  }

  private boolean jj_3R_550() {
    if (jj_3R_360()) return true;
    return false;
  }

  private boolean jj_3R_495() {
    if (jj_3R_589()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_981()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_238() {
    if (jj_3R_358()) return true;
    return false;
  }

  private boolean jj_3R_582() {
    if (jj_3R_682()) return true;
    return false;
  }

  private boolean jj_3R_549() {
    if (jj_3R_662()) return true;
    return false;
  }

  private boolean jj_3_124() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_629() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_803()) jj_scanpos = xsp;
    if (jj_3R_628()) return true;
    return false;
  }

  private boolean jj_3R_237() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_581() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_548() {
    if (jj_3R_355()) return true;
    return false;
  }

  private boolean jj_3R_236() {
    if (jj_3R_356()) return true;
    return false;
  }

  private boolean jj_3R_547() {
    if (jj_3R_358()) return true;
    return false;
  }

  private boolean jj_3R_517() {
    if (jj_3R_628()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_629()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_484() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_581()) {
    jj_scanpos = xsp;
    if (jj_3R_582()) {
    jj_scanpos = xsp;
    if (jj_3R_583()) {
    jj_scanpos = xsp;
    if (jj_3R_584()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_235() {
    if (jj_3R_355()) return true;
    return false;
  }

  private boolean jj_3R_546() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_216() {
    if (jj_3R_340()) return true;
    return false;
  }

  private boolean jj_3R_234() {
    if (jj_3R_354()) return true;
    return false;
  }

  private boolean jj_3_139() {
    if (jj_3R_167()) return true;
    return false;
  }

  private boolean jj_3_67() {
    if (jj_3R_126()) return true;
    return false;
  }

  private boolean jj_3R_233() {
    if (jj_3R_353()) return true;
    return false;
  }

  private boolean jj_3R_463() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_546()) {
    jj_scanpos = xsp;
    if (jj_3R_547()) {
    jj_scanpos = xsp;
    if (jj_3R_548()) {
    jj_scanpos = xsp;
    if (jj_3R_549()) {
    jj_scanpos = xsp;
    if (jj_3R_550()) {
    jj_scanpos = xsp;
    if (jj_3R_551()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_202() {
    if (jj_3R_319()) return true;
    return false;
  }

  private boolean jj_3_16() {
    if (jj_3R_72()) return true;
    return false;
  }

  private boolean jj_3_66() {
    if (jj_3R_125()) return true;
    return false;
  }

  private boolean jj_3R_149() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_233()) {
    jj_scanpos = xsp;
    if (jj_3R_234()) {
    jj_scanpos = xsp;
    if (jj_3R_235()) {
    jj_scanpos = xsp;
    if (jj_3R_236()) {
    jj_scanpos = xsp;
    if (jj_3R_237()) {
    jj_scanpos = xsp;
    if (jj_3R_238()) {
    jj_scanpos = xsp;
    if (jj_3R_239()) {
    jj_scanpos = xsp;
    if (jj_3R_240()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_164() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(DECLARE)) return true;
    if (jj_scan_token(TARGET)) return true;
    return false;
  }

  private boolean jj_3R_76() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) return true;
    }
    return false;
  }

  private boolean jj_3_65() {
    if (jj_3R_124()) return true;
    return false;
  }

  private boolean jj_3R_908() {
    if (jj_scan_token(OP_DEREF)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_64() {
    if (jj_3R_123()) return true;
    return false;
  }

  private boolean jj_3R_435() {
    if (jj_3R_517()) return true;
    return false;
  }

  private boolean jj_3_63() {
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_845() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3_62() {
    if (jj_3R_121()) return true;
    return false;
  }

  private boolean jj_3_15() {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_106() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(TEAMS)) return true;
    if (jj_scan_token(DISTRIBUTE)) return true;
    if (jj_scan_token(PARALLEL)) return true;
    if (jj_scan_token(FOR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_435()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3_61() {
    if (jj_3R_120()) return true;
    return false;
  }

  private boolean jj_3R_718() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_655() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_845()) jj_scanpos = xsp;
    if (jj_3R_463()) return true;
    return false;
  }

  private boolean jj_3R_201() {
    Token xsp;
    if (jj_3_15()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_15()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_907() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_60() {
    if (jj_3R_119()) return true;
    return false;
  }

  private boolean jj_3R_349() {
    if (jj_3R_463()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_655()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_608() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_718()) jj_scanpos = xsp;
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3_59() {
    if (jj_3R_118()) return true;
    return false;
  }

  private boolean jj_3_148() {
    if (jj_3R_175()) return true;
    return false;
  }

  private boolean jj_3R_573() {
    if (jj_scan_token(LINK)) return true;
    return false;
  }

  private boolean jj_3_58() {
    if (jj_3R_117()) return true;
    return false;
  }

  private boolean jj_3R_507() {
    if (jj_3R_149()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_608()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_57() {
    if (jj_3R_116()) return true;
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_3R_201()) return true;
    if (jj_3R_495()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_925() {
    if (jj_3R_175()) return true;
    return false;
  }

  private boolean jj_3_109() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3_56() {
    if (jj_3R_115()) return true;
    return false;
  }

  private boolean jj_3R_906() {
    if (jj_scan_token(LEFTPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_925()) jj_scanpos = xsp;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3_55() {
    if (jj_3R_114()) return true;
    return false;
  }

  private boolean jj_3R_545() {
    if (jj_3R_637()) return true;
    return false;
  }

  private boolean jj_3R_229() {
    if (jj_3R_349()) return true;
    return false;
  }

  private boolean jj_3_54() {
    if (jj_3R_113()) return true;
    return false;
  }

  private boolean jj_3R_544() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_480() {
    if (jj_3R_573()) return true;
    return false;
  }

  private boolean jj_3_53() {
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_479() {
    if (jj_3R_381()) return true;
    return false;
  }

  private boolean jj_3R_425() {
    if (jj_3R_507()) return true;
    return false;
  }

  private boolean jj_3R_462() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_544()) {
    jj_scanpos = xsp;
    if (jj_3R_545()) return true;
    }
    return false;
  }

  private boolean jj_3R_121() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(PARALLEL)) return true;
    if (jj_scan_token(FOR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_229()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_588() {
    if (jj_scan_token(OP_ASS)) return true;
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3_52() {
    if (jj_3R_111()) return true;
    return false;
  }

  private boolean jj_3R_383() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_479()) {
    jj_scanpos = xsp;
    if (jj_3R_480()) return true;
    }
    return false;
  }

  private boolean jj_3R_95() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(SIMD)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_425()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_490() {
    if (jj_3R_81()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_588()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_51() {
    if (jj_3R_110()) return true;
    return false;
  }

  private boolean jj_3R_905() {
    if (jj_scan_token(LEFTBRACKET)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTBRACKET)) return true;
    return false;
  }

  private boolean jj_3_50() {
    if (jj_3R_109()) return true;
    return false;
  }

  private boolean jj_3_49() {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_800() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3_48() {
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3R_843() {
    if (jj_3R_663()) return true;
    return false;
  }

  private boolean jj_3R_627() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_800()) jj_scanpos = xsp;
    if (jj_3R_462()) return true;
    return false;
  }

  private boolean jj_3_47() {
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_842() {
    if (jj_3R_360()) return true;
    return false;
  }

  private boolean jj_3R_910() {
    if (jj_scan_token(OP_DECR)) return true;
    return false;
  }

  private boolean jj_3R_841() {
    if (jj_3R_662()) return true;
    return false;
  }

  private boolean jj_3_46() {
    if (jj_3R_105()) return true;
    return false;
  }

  private boolean jj_3R_348() {
    if (jj_3R_462()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_627()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_123() {
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3R_886() {
    if (jj_scan_token(COPYPRIVATE)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_466()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_840() {
    if (jj_3R_355()) return true;
    return false;
  }

  private boolean jj_3R_289() {
    if (jj_3R_383()) return true;
    return false;
  }

  private boolean jj_3_45() {
    if (jj_3R_104()) return true;
    return false;
  }

  private boolean jj_3_122() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_839() {
    if (jj_3R_358()) return true;
    return false;
  }

  private boolean jj_3_44() {
    if (jj_3R_103()) return true;
    return false;
  }

  private boolean jj_3R_491() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_490()) return true;
    return false;
  }

  private boolean jj_3R_838() {
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3R_909() {
    if (jj_scan_token(OP_INCR)) return true;
    return false;
  }

  private boolean jj_3_43() {
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3R_837() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_396() {
    if (jj_3R_490()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_491()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_42() {
    if (jj_3R_101()) return true;
    return false;
  }

  private boolean jj_3R_717() {
    if (jj_3R_367()) return true;
    return false;
  }

  private boolean jj_3R_653() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_837()) {
    jj_scanpos = xsp;
    if (jj_3R_838()) {
    jj_scanpos = xsp;
    if (jj_3R_839()) {
    jj_scanpos = xsp;
    if (jj_3R_840()) {
    jj_scanpos = xsp;
    if (jj_3R_841()) {
    jj_scanpos = xsp;
    if (jj_3R_842()) {
    jj_scanpos = xsp;
    if (jj_3R_843()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_41() {
    if (jj_3R_100()) return true;
    return false;
  }

  private boolean jj_3R_228() {
    if (jj_3R_348()) return true;
    return false;
  }

  private boolean jj_3R_716() {
    if (jj_3R_886()) return true;
    return false;
  }

  private boolean jj_3R_876() {
    if (jj_3R_910()) return true;
    return false;
  }

  private boolean jj_3R_715() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3_40() {
    if (jj_3R_99()) return true;
    return false;
  }

  private boolean jj_3R_163() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(DECLARE)) return true;
    if (jj_scan_token(TARGET)) return true;
    if (jj_3R_289()) return true;
    return false;
  }

  private boolean jj_3R_875() {
    if (jj_3R_909()) return true;
    return false;
  }

  private boolean jj_3R_714() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3_39() {
    if (jj_3R_98()) return true;
    return false;
  }

  private boolean jj_3R_874() {
    if (jj_3R_908()) return true;
    return false;
  }

  private boolean jj_3R_105() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TEAMS)) return true;
    if (jj_scan_token(DISTRIBUTE)) return true;
    if (jj_scan_token(PARALLEL)) return true;
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(SIMD)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_228()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_606() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_714()) {
    jj_scanpos = xsp;
    if (jj_3R_715()) {
    jj_scanpos = xsp;
    if (jj_3R_716()) {
    jj_scanpos = xsp;
    if (jj_3R_717()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3_14() {
    if (jj_3R_75()) return true;
    return false;
  }

  private boolean jj_3_38() {
    if (jj_3R_97()) return true;
    return false;
  }

  private boolean jj_3R_873() {
    if (jj_3R_907()) return true;
    return false;
  }

  private boolean jj_3R_200() {
    Token xsp;
    if (jj_3_14()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_14()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_872() {
    if (jj_3R_906()) return true;
    return false;
  }

  private boolean jj_3_37() {
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_871() {
    if (jj_3R_905()) return true;
    return false;
  }

  private boolean jj_3R_844() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3_36() {
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_685() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_871()) {
    jj_scanpos = xsp;
    if (jj_3R_872()) {
    jj_scanpos = xsp;
    if (jj_3R_873()) {
    jj_scanpos = xsp;
    if (jj_3R_874()) {
    jj_scanpos = xsp;
    if (jj_3R_875()) {
    jj_scanpos = xsp;
    if (jj_3R_876()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_35() {
    if (jj_3R_94()) return true;
    return false;
  }

  private boolean jj_3R_654() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_844()) jj_scanpos = xsp;
    if (jj_3R_653()) return true;
    return false;
  }

  private boolean jj_3R_162() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(DECLARE)) return true;
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_607() {
    if (jj_3R_606()) return true;
    return false;
  }

  private boolean jj_3R_326() {
    if (jj_scan_token(UNION)) return true;
    return false;
  }

  private boolean jj_3_34() {
    if (jj_3R_93()) return true;
    return false;
  }

  private boolean jj_3R_531() {
    if (jj_3R_653()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_654()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_325() {
    if (jj_scan_token(STRUCT)) return true;
    return false;
  }

  private boolean jj_3_108() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_506() {
    if (jj_3R_606()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_607()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_33() {
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_198() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_325()) {
    jj_scanpos = xsp;
    if (jj_3R_326()) return true;
    }
    return false;
  }

  private boolean jj_3R_798() {
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3_32() {
    if (jj_3R_91()) return true;
    return false;
  }

  private boolean jj_3R_797() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_87() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_32()) {
    jj_scanpos = xsp;
    if (jj_3_33()) {
    jj_scanpos = xsp;
    if (jj_3_34()) {
    jj_scanpos = xsp;
    if (jj_3_35()) {
    jj_scanpos = xsp;
    if (jj_3_36()) {
    jj_scanpos = xsp;
    if (jj_3_37()) {
    jj_scanpos = xsp;
    if (jj_3_38()) {
    jj_scanpos = xsp;
    if (jj_3_39()) {
    jj_scanpos = xsp;
    if (jj_3_40()) {
    jj_scanpos = xsp;
    if (jj_3_41()) {
    jj_scanpos = xsp;
    if (jj_3_42()) {
    jj_scanpos = xsp;
    if (jj_3_43()) {
    jj_scanpos = xsp;
    if (jj_3_44()) {
    jj_scanpos = xsp;
    if (jj_3_45()) {
    jj_scanpos = xsp;
    if (jj_3_46()) {
    jj_scanpos = xsp;
    if (jj_3_47()) {
    jj_scanpos = xsp;
    if (jj_3_48()) {
    jj_scanpos = xsp;
    if (jj_3_49()) {
    jj_scanpos = xsp;
    if (jj_3_50()) {
    jj_scanpos = xsp;
    if (jj_3_51()) {
    jj_scanpos = xsp;
    if (jj_3_52()) {
    jj_scanpos = xsp;
    if (jj_3_53()) {
    jj_scanpos = xsp;
    if (jj_3_54()) {
    jj_scanpos = xsp;
    if (jj_3_55()) {
    jj_scanpos = xsp;
    if (jj_3_56()) {
    jj_scanpos = xsp;
    if (jj_3_57()) {
    jj_scanpos = xsp;
    if (jj_3_58()) {
    jj_scanpos = xsp;
    if (jj_3_59()) {
    jj_scanpos = xsp;
    if (jj_3_60()) {
    jj_scanpos = xsp;
    if (jj_3_61()) {
    jj_scanpos = xsp;
    if (jj_3_62()) {
    jj_scanpos = xsp;
    if (jj_3_63()) {
    jj_scanpos = xsp;
    if (jj_3_64()) {
    jj_scanpos = xsp;
    if (jj_3_65()) {
    jj_scanpos = xsp;
    if (jj_3_66()) {
    jj_scanpos = xsp;
    if (jj_3_67()) {
    jj_scanpos = xsp;
    if (jj_3R_216()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_585() {
    if (jj_3R_685()) return true;
    return false;
  }

  private boolean jj_3R_625() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_797()) {
    jj_scanpos = xsp;
    if (jj_3R_798()) return true;
    }
    return false;
  }

  private boolean jj_3R_485() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_585()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_395() {
    if (jj_3R_489()) return true;
    return false;
  }

  private boolean jj_3R_424() {
    if (jj_3R_506()) return true;
    return false;
  }

  private boolean jj_3R_449() {
    if (jj_3R_531()) return true;
    return false;
  }

  private boolean jj_3_138() {
    if (jj_3R_166()) return true;
    return false;
  }

  private boolean jj_3R_493() {
    if (jj_3R_198()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_94() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(SINGLE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_424()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3_137() {
    if (jj_3R_165()) return true;
    return false;
  }

  private boolean jj_3R_120() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(PARALLEL)) return true;
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(SIMD)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_449()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3_136() {
    if (jj_3R_164()) return true;
    return false;
  }

  private boolean jj_3R_389() {
    if (jj_3R_484()) return true;
    if (jj_3R_485()) return true;
    return false;
  }

  private boolean jj_3R_799() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3_135() {
    if (jj_3R_163()) return true;
    return false;
  }

  private boolean jj_3R_626() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_799()) jj_scanpos = xsp;
    if (jj_3R_625()) return true;
    return false;
  }

  private boolean jj_3_134() {
    if (jj_3R_162()) return true;
    return false;
  }

  private boolean jj_3R_199() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_315() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_134()) {
    jj_scanpos = xsp;
    if (jj_3_135()) {
    jj_scanpos = xsp;
    if (jj_3_136()) {
    jj_scanpos = xsp;
    if (jj_3_137()) {
    jj_scanpos = xsp;
    if (jj_3_138()) {
    jj_scanpos = xsp;
    if (jj_3R_395()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_580() {
    if (jj_scan_token(OP_NOT)) return true;
    return false;
  }

  private boolean jj_3R_516() {
    if (jj_3R_625()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_626()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_74() {
    if (jj_3R_198()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_199()) jj_scanpos = xsp;
    if (jj_scan_token(LEFTBRACE)) return true;
    if (jj_3R_200()) return true;
    if (jj_scan_token(RIGHTBRACE)) return true;
    return false;
  }

  private boolean jj_3R_605() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(SECTION)) return true;
    if (jj_3R_156()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_579() {
    if (jj_scan_token(OP_BITNOT)) return true;
    return false;
  }

  private boolean jj_3R_578() {
    if (jj_scan_token(OP_SUB)) return true;
    return false;
  }

  private boolean jj_3R_577() {
    if (jj_scan_token(OP_ADD)) return true;
    return false;
  }

  private boolean jj_3R_576() {
    if (jj_scan_token(OP_MUL)) return true;
    return false;
  }

  private boolean jj_3R_474() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_575() {
    if (jj_scan_token(OP_BITAND)) return true;
    return false;
  }

  private boolean jj_3R_272() {
    if (jj_scan_token(OMP_NL)) return true;
    return false;
  }

  private boolean jj_3R_483() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_575()) {
    jj_scanpos = xsp;
    if (jj_3R_576()) {
    jj_scanpos = xsp;
    if (jj_3R_577()) {
    jj_scanpos = xsp;
    if (jj_3R_578()) {
    jj_scanpos = xsp;
    if (jj_3R_579()) {
    jj_scanpos = xsp;
    if (jj_3R_580()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_505() {
    if (jj_3R_605()) return true;
    return false;
  }

  private boolean jj_3R_271() {
    if (jj_scan_token(OMP_CR)) return true;
    return false;
  }

  private boolean jj_3R_434() {
    if (jj_3R_516()) return true;
    return false;
  }

  private boolean jj_3R_373() {
    if (jj_scan_token(DISTSCHEDULE)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_473()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_474()) jj_scanpos = xsp;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_341() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(CANCELLATION)) return true;
    if (jj_scan_token(POINT)) return true;
    if (jj_3R_672()) return true;
    if (jj_3R_156()) return true;
    return false;
  }

  private boolean jj_3R_413() {
    if (jj_3R_493()) return true;
    return false;
  }

  private boolean jj_3R_156() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_271()) {
    jj_scanpos = xsp;
    if (jj_3R_272()) return true;
    }
    return false;
  }

  private boolean jj_3_90() {
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_104() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(SIMD)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_434()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3_13() {
    if (jj_3R_74()) return true;
    return false;
  }

  private boolean jj_3R_423() {
    if (jj_scan_token(LEFTBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_90()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_505()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RIGHTBRACE)) return true;
    return false;
  }

  private boolean jj_3R_322() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_13()) {
    jj_scanpos = xsp;
    if (jj_3R_413()) return true;
    }
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_scan_token(CROSSBAR)) return true;
    if (jj_scan_token(UNKNOWN_CPP)) return true;
    return false;
  }

  private boolean jj_3R_865() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_261() {
    if (jj_3R_373()) return true;
    return false;
  }

  private boolean jj_3R_260() {
    if (jj_3R_360()) return true;
    return false;
  }

  private boolean jj_3R_174() {
    if (jj_scan_token(SIZEOF)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_172()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_795() {
    if (jj_3R_377()) return true;
    return false;
  }

  private boolean jj_3R_712() {
    if (jj_3R_367()) return true;
    return false;
  }

  private boolean jj_3R_259() {
    if (jj_3R_358()) return true;
    return false;
  }

  private boolean jj_3R_711() {
    if (jj_3R_359()) return true;
    return false;
  }

  private boolean jj_3_107() {
    if (jj_3R_137()) return true;
    return false;
  }

  private boolean jj_3R_258() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3R_710() {
    if (jj_3R_358()) return true;
    return false;
  }

  private boolean jj_3R_408() {
    if (jj_scan_token(CSIGNED2)) return true;
    return false;
  }

  private boolean jj_3_106() {
    if (jj_3R_136()) return true;
    return false;
  }

  private boolean jj_3R_257() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_667() {
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_709() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3R_407() {
    if (jj_scan_token(CSIGNED)) return true;
    return false;
  }

  private boolean jj_3R_794() {
    if (jj_3R_359()) return true;
    return false;
  }

  private boolean jj_3R_863() {
    if (jj_scan_token(TASKGROUP)) return true;
    return false;
  }

  private boolean jj_3R_152() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_257()) {
    jj_scanpos = xsp;
    if (jj_3R_258()) {
    jj_scanpos = xsp;
    if (jj_3R_259()) {
    jj_scanpos = xsp;
    if (jj_3R_260()) {
    jj_scanpos = xsp;
    if (jj_3R_261()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_708() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_406() {
    if (jj_scan_token(CCONST)) return true;
    return false;
  }

  private boolean jj_3R_793() {
    if (jj_3R_372()) return true;
    return false;
  }

  private boolean jj_3R_543() {
    if (jj_scan_token(RETURN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_667()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_862() {
    if (jj_scan_token(FOR)) return true;
    return false;
  }

  private boolean jj_3R_405() {
    if (jj_scan_token(VOLATILE)) return true;
    return false;
  }

  private boolean jj_3R_792() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3R_603() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_708()) {
    jj_scanpos = xsp;
    if (jj_3R_709()) {
    jj_scanpos = xsp;
    if (jj_3R_710()) {
    jj_scanpos = xsp;
    if (jj_3R_711()) {
    jj_scanpos = xsp;
    if (jj_3R_712()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_861() {
    if (jj_scan_token(SECTIONS)) return true;
    return false;
  }

  private boolean jj_3R_574() {
    if (jj_scan_token(SIZEOF)) return true;
    if (jj_3R_169()) return true;
    return false;
  }

  private boolean jj_3R_404() {
    if (jj_scan_token(CONST)) return true;
    return false;
  }

  private boolean jj_3R_791() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_860() {
    if (jj_scan_token(PARALLEL)) return true;
    return false;
  }

  private boolean jj_3R_403() {
    if (jj_scan_token(RESTRICT)) return true;
    return false;
  }

  private boolean jj_3R_790() {
    if (jj_3R_371()) return true;
    return false;
  }

  private boolean jj_3R_672() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_860()) {
    jj_scanpos = xsp;
    if (jj_3R_861()) {
    jj_scanpos = xsp;
    if (jj_3R_862()) {
    jj_scanpos = xsp;
    if (jj_3R_863()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3_147() {
    if (jj_3R_174()) return true;
    return false;
  }

  private boolean jj_3R_319() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_403()) {
    jj_scanpos = xsp;
    if (jj_3R_404()) {
    jj_scanpos = xsp;
    if (jj_3R_405()) {
    jj_scanpos = xsp;
    if (jj_3R_406()) {
    jj_scanpos = xsp;
    if (jj_3R_407()) {
    jj_scanpos = xsp;
    if (jj_3R_408()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_104() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3_105() {
    if (jj_3R_135()) return true;
    return false;
  }

  private boolean jj_3R_789() {
    if (jj_3R_375()) return true;
    return false;
  }

  private boolean jj_3R_836() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_482() {
    if (jj_3R_574()) return true;
    return false;
  }

  private boolean jj_3R_542() {
    if (jj_scan_token(BREAK)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_788() {
    if (jj_3R_374()) return true;
    return false;
  }

  private boolean jj_3R_481() {
    if (jj_3R_174()) return true;
    return false;
  }

  private boolean jj_3R_713() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_787() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_652() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_836()) jj_scanpos = xsp;
    if (jj_3R_152()) return true;
    return false;
  }

  private boolean jj_3R_387() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_481()) {
    jj_scanpos = xsp;
    if (jj_3R_482()) return true;
    }
    return false;
  }

  private boolean jj_3R_623() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_787()) {
    jj_scanpos = xsp;
    if (jj_3R_788()) {
    jj_scanpos = xsp;
    if (jj_3R_789()) {
    jj_scanpos = xsp;
    if (jj_3_105()) {
    jj_scanpos = xsp;
    if (jj_3R_790()) {
    jj_scanpos = xsp;
    if (jj_3R_791()) {
    jj_scanpos = xsp;
    if (jj_3R_792()) {
    jj_scanpos = xsp;
    if (jj_3R_793()) {
    jj_scanpos = xsp;
    if (jj_3R_794()) {
    jj_scanpos = xsp;
    if (jj_3_106()) {
    jj_scanpos = xsp;
    if (jj_3_107()) {
    jj_scanpos = xsp;
    if (jj_3R_795()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_604() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_713()) jj_scanpos = xsp;
    if (jj_3R_603()) return true;
    return false;
  }

  private boolean jj_3R_530() {
    if (jj_3R_152()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_652()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_864() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_504() {
    if (jj_3R_603()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_604()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_541() {
    if (jj_scan_token(CONTINUE)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_673() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_864()) jj_scanpos = xsp;
    if (jj_3R_865()) return true;
    return false;
  }

  private boolean jj_3R_388() {
    if (jj_3R_483()) return true;
    if (jj_3R_173()) return true;
    return false;
  }

  private boolean jj_3R_197() {
    if (jj_3R_324()) return true;
    return false;
  }

  private boolean jj_3R_196() {
    if (jj_3R_323()) return true;
    return false;
  }

  private boolean jj_3R_134() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(CANCEL)) return true;
    if (jj_3R_672()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_673()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    return false;
  }

  private boolean jj_3R_195() {
    if (jj_3R_322()) return true;
    return false;
  }

  private boolean jj_3R_448() {
    if (jj_3R_530()) return true;
    return false;
  }

  private boolean jj_3R_194() {
    if (jj_scan_token(UNSIGNED)) return true;
    return false;
  }

  private boolean jj_3R_540() {
    if (jj_scan_token(GOTO)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_422() {
    if (jj_3R_504()) return true;
    return false;
  }

  private boolean jj_3R_796() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_193() {
    if (jj_scan_token(SIGNED)) return true;
    return false;
  }

  private boolean jj_3R_119() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(DISTRIBUTE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_448()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_386() {
    if (jj_scan_token(OP_DECR)) return true;
    if (jj_3R_169()) return true;
    return false;
  }

  private boolean jj_3R_192() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  private boolean jj_3R_93() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(SECTIONS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_422()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_423()) return true;
    return false;
  }

  private boolean jj_3R_624() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_796()) jj_scanpos = xsp;
    if (jj_3R_623()) return true;
    return false;
  }

  private boolean jj_3R_191() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  private boolean jj_3R_190() {
    if (jj_scan_token(LONG)) return true;
    return false;
  }

  private boolean jj_3R_515() {
    if (jj_3R_623()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_624()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_189() {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  private boolean jj_3_121() {
    if (jj_3R_152()) return true;
    return false;
  }

  private boolean jj_3R_461() {
    if (jj_3R_543()) return true;
    return false;
  }

  private boolean jj_3R_188() {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }

  private boolean jj_3R_385() {
    if (jj_scan_token(OP_INCR)) return true;
    if (jj_3R_169()) return true;
    return false;
  }

  private boolean jj_3R_460() {
    if (jj_3R_542()) return true;
    return false;
  }

  private boolean jj_3R_187() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  private boolean jj_3R_834() {
    if (jj_3R_463()) return true;
    return false;
  }

  private boolean jj_3R_459() {
    if (jj_3R_541()) return true;
    return false;
  }

  private boolean jj_3R_671() {
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_466()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_186() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  private boolean jj_3R_833() {
    if (jj_3R_152()) return true;
    return false;
  }

  private boolean jj_3R_458() {
    if (jj_3R_540()) return true;
    return false;
  }

  private boolean jj_3R_707() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_ASS)) return true;
    if (jj_3R_885()) return true;
    if (jj_scan_token(OP_ADD)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_650() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_833()) {
    jj_scanpos = xsp;
    if (jj_3R_834()) return true;
    }
    return false;
  }

  private boolean jj_3R_346() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_458()) {
    jj_scanpos = xsp;
    if (jj_3R_459()) {
    jj_scanpos = xsp;
    if (jj_3R_460()) {
    jj_scanpos = xsp;
    if (jj_3R_461()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_133() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(FLUSH)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_671()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    return false;
  }

  private boolean jj_3R_72() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) {
    jj_scanpos = xsp;
    if (jj_3R_188()) {
    jj_scanpos = xsp;
    if (jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) {
    jj_scanpos = xsp;
    if (jj_3R_192()) {
    jj_scanpos = xsp;
    if (jj_3R_193()) {
    jj_scanpos = xsp;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3R_195()) {
    jj_scanpos = xsp;
    if (jj_3R_196()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = (!typedefParsingStack.empty() && ((Boolean)typedefParsingStack.peek()).booleanValue()&& flag == true) || ((typedefParsingStack.empty() || !((Boolean)typedefParsingStack.peek()).booleanValue()) && isType(getToken(1).image));
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_197()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_296() {
    if (jj_3R_389()) return true;
    return false;
  }

  private boolean jj_3R_433() {
    if (jj_3R_515()) return true;
    return false;
  }

  private boolean jj_3R_295() {
    if (jj_3R_388()) return true;
    return false;
  }

  private boolean jj_3R_294() {
    if (jj_3R_387()) return true;
    return false;
  }

  private boolean jj_3R_103() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(PARALLEL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_433()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_293() {
    if (jj_3R_386()) return true;
    return false;
  }

  private boolean jj_3R_292() {
    if (jj_3R_385()) return true;
    return false;
  }

  private boolean jj_3R_835() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_666() {
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_169() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_292()) {
    jj_scanpos = xsp;
    if (jj_3R_293()) {
    jj_scanpos = xsp;
    if (jj_3R_294()) {
    jj_scanpos = xsp;
    if (jj_3R_295()) {
    jj_scanpos = xsp;
    if (jj_3R_296()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_665() {
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_651() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_835()) jj_scanpos = xsp;
    if (jj_3R_650()) return true;
    return false;
  }

  private boolean jj_3R_148() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_ASS)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_SUB)) return true;
    if (jj_3R_884()) return true;
    return false;
  }

  private boolean jj_3R_132() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TASKWAIT)) return true;
    if (jj_3R_156()) return true;
    return false;
  }

  private boolean jj_3R_664() {
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_529() {
    if (jj_3R_650()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_651()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_785() {
    if (jj_3R_663()) return true;
    return false;
  }

  private boolean jj_3R_784() {
    if (jj_3R_360()) return true;
    return false;
  }

  private boolean jj_3R_539() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_664()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_665()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_666()) jj_scanpos = xsp;
    if (jj_scan_token(RIGHTPAREN)) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_783() {
    if (jj_3R_662()) return true;
    return false;
  }

  private boolean jj_3R_782() {
    if (jj_3R_355()) return true;
    return false;
  }

  private boolean jj_3R_393() {
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_172()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    if (jj_3R_173()) return true;
    return false;
  }

  private boolean jj_3R_402() {
    if (jj_scan_token(TYPEDEF)) return true;
    return false;
  }

  private boolean jj_3R_781() {
    if (jj_3R_358()) return true;
    return false;
  }

  private boolean jj_3R_131() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(BARRIER)) return true;
    if (jj_3R_156()) return true;
    return false;
  }

  private boolean jj_3R_401() {
    if (jj_scan_token(EXTERN)) return true;
    return false;
  }

  private boolean jj_3R_780() {
    if (jj_3R_377()) return true;
    return false;
  }

  private boolean jj_3R_400() {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_447() {
    if (jj_3R_529()) return true;
    return false;
  }

  private boolean jj_3R_147() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_ASS)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_ADD)) return true;
    if (jj_3R_884()) return true;
    return false;
  }

  private boolean jj_3_103() {
    if (jj_3R_137()) return true;
    return false;
  }

  private boolean jj_3_146() {
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_172()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    if (jj_3R_173()) return true;
    return false;
  }

  private boolean jj_3R_399() {
    if (jj_scan_token(REGISTER)) return true;
    return false;
  }

  private boolean jj_3R_398() {
    if (jj_scan_token(AUTO)) return true;
    return false;
  }

  private boolean jj_3_102() {
    if (jj_3R_136()) return true;
    return false;
  }

  private boolean jj_3R_312() {
    if (jj_3R_169()) return true;
    return false;
  }

  private boolean jj_3R_779() {
    if (jj_3R_359()) return true;
    return false;
  }

  private boolean jj_3R_118() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(DISTRIBUTE)) return true;
    if (jj_scan_token(PARALLEL)) return true;
    if (jj_scan_token(FOR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_447()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_318() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_398()) {
    jj_scanpos = xsp;
    if (jj_3R_399()) {
    jj_scanpos = xsp;
    if (jj_3R_400()) {
    jj_scanpos = xsp;
    if (jj_3R_401()) {
    jj_scanpos = xsp;
    if (jj_3R_402()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_778() {
    if (jj_3R_372()) return true;
    return false;
  }

  private boolean jj_3R_311() {
    if (jj_3R_393()) return true;
    return false;
  }

  private boolean jj_3R_382() {
    if (jj_scan_token(FROM)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_466()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_777() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3R_173() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_311()) {
    jj_scanpos = xsp;
    if (jj_3R_312()) return true;
    }
    return false;
  }

  private boolean jj_3R_776() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_775() {
    if (jj_3R_371()) return true;
    return false;
  }

  private boolean jj_3R_538() {
    if (jj_scan_token(DO)) return true;
    if (jj_3R_90()) return true;
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_146() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_SUBASS)) return true;
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3_100() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3_101() {
    if (jj_3R_135()) return true;
    return false;
  }

  private boolean jj_3_120() {
    if (jj_3R_152()) return true;
    return false;
  }

  private boolean jj_3R_774() {
    if (jj_3R_375()) return true;
    return false;
  }

  private boolean jj_3R_971() {
    if (jj_scan_token(OP_MOD)) return true;
    if (jj_3R_885()) return true;
    return false;
  }

  private boolean jj_3R_831() {
    if (jj_3R_653()) return true;
    return false;
  }

  private boolean jj_3R_773() {
    if (jj_3R_374()) return true;
    return false;
  }

  private boolean jj_3R_381() {
    if (jj_scan_token(TO)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_466()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_830() {
    if (jj_3R_152()) return true;
    return false;
  }

  private boolean jj_3R_772() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_492() {
    if (jj_scan_token(ALIGNAS)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_397()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_648() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_830()) {
    jj_scanpos = xsp;
    if (jj_3R_831()) return true;
    }
    return false;
  }

  private boolean jj_3R_621() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_772()) {
    jj_scanpos = xsp;
    if (jj_3R_773()) {
    jj_scanpos = xsp;
    if (jj_3R_774()) {
    jj_scanpos = xsp;
    if (jj_3_101()) {
    jj_scanpos = xsp;
    if (jj_3R_775()) {
    jj_scanpos = xsp;
    if (jj_3R_776()) {
    jj_scanpos = xsp;
    if (jj_3R_777()) {
    jj_scanpos = xsp;
    if (jj_3R_778()) {
    jj_scanpos = xsp;
    if (jj_3R_779()) {
    jj_scanpos = xsp;
    if (jj_3_102()) {
    jj_scanpos = xsp;
    if (jj_3_103()) {
    jj_scanpos = xsp;
    if (jj_3R_780()) {
    jj_scanpos = xsp;
    if (jj_3R_781()) {
    jj_scanpos = xsp;
    if (jj_3R_782()) {
    jj_scanpos = xsp;
    if (jj_3R_783()) {
    jj_scanpos = xsp;
    if (jj_3R_784()) {
    jj_scanpos = xsp;
    if (jj_3R_785()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_145() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_ADDASS)) return true;
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_970() {
    if (jj_scan_token(OP_DIV)) return true;
    if (jj_3R_885()) return true;
    return false;
  }

  private boolean jj_3R_537() {
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_832() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_73() {
    if (jj_scan_token(ALIGNAS)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_172()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_144() {
    if (jj_scan_token(OP_DECR)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_478() {
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(UPDATE)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_969() {
    if (jj_scan_token(OP_MUL)) return true;
    if (jj_3R_885()) return true;
    return false;
  }

  private boolean jj_3R_649() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_832()) jj_scanpos = xsp;
    if (jj_3R_648()) return true;
    return false;
  }

  private boolean jj_3R_380() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_478()) jj_scanpos = xsp;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_528() {
    if (jj_3R_648()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_649()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_457() {
    if (jj_3R_539()) return true;
    return false;
  }

  private boolean jj_3_12() {
    if (jj_3R_73()) return true;
    return false;
  }

  private boolean jj_3R_456() {
    if (jj_3R_538()) return true;
    return false;
  }

  private boolean jj_3R_786() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_455() {
    if (jj_3R_537()) return true;
    return false;
  }

  private boolean jj_3R_412() {
    if (jj_3R_492()) return true;
    return false;
  }

  private boolean jj_3R_955() {
    if (jj_3R_971()) return true;
    return false;
  }

  private boolean jj_3R_143() {
    if (jj_scan_token(OP_INCR)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_622() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_786()) jj_scanpos = xsp;
    if (jj_3R_621()) return true;
    return false;
  }

  private boolean jj_3R_345() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_455()) {
    jj_scanpos = xsp;
    if (jj_3R_456()) {
    jj_scanpos = xsp;
    if (jj_3R_457()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_954() {
    if (jj_3R_970()) return true;
    return false;
  }

  private boolean jj_3R_411() {
    if (jj_3R_73()) return true;
    return false;
  }

  private boolean jj_3R_953() {
    if (jj_3R_969()) return true;
    return false;
  }

  private boolean jj_3R_514() {
    if (jj_3R_621()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_622()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_321() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_411()) {
    jj_scanpos = xsp;
    if (jj_3R_412()) return true;
    }
    return false;
  }

  private boolean jj_3R_938() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_953()) {
    jj_scanpos = xsp;
    if (jj_3R_954()) {
    jj_scanpos = xsp;
    if (jj_3R_955()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_446() {
    if (jj_3R_528()) return true;
    return false;
  }

  private boolean jj_3R_288() {
    if (jj_3R_382()) return true;
    return false;
  }

  private boolean jj_3R_142() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_DECR)) return true;
    return false;
  }

  private boolean jj_3R_287() {
    if (jj_3R_381()) return true;
    return false;
  }

  private boolean jj_3R_410() {
    if (jj_scan_token(NORETURN)) return true;
    return false;
  }

  private boolean jj_3R_536() {
    if (jj_scan_token(SWITCH)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_117() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(DISTRIBUTE)) return true;
    if (jj_scan_token(PARALLEL)) return true;
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(SIMD)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_446()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_286() {
    if (jj_3R_368()) return true;
    return false;
  }

  private boolean jj_3R_409() {
    if (jj_scan_token(INLINE)) return true;
    return false;
  }

  private boolean jj_3R_920() {
    if (jj_3R_938()) return true;
    return false;
  }

  private boolean jj_3R_285() {
    if (jj_3R_367()) return true;
    return false;
  }

  private boolean jj_3R_320() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_409()) {
    jj_scanpos = xsp;
    if (jj_3R_410()) return true;
    }
    return false;
  }

  private boolean jj_3R_432() {
    if (jj_3R_514()) return true;
    return false;
  }

  private boolean jj_3R_284() {
    if (jj_3R_362()) return true;
    return false;
  }

  private boolean jj_3R_885() {
    if (jj_3R_173()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_920()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_283() {
    if (jj_3R_380()) return true;
    return false;
  }

  private boolean jj_3R_141() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_INCR)) return true;
    return false;
  }

  private boolean jj_3R_102() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(PARALLEL)) return true;
    if (jj_scan_token(FOR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_432()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_161() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_283()) {
    jj_scanpos = xsp;
    if (jj_3R_284()) {
    jj_scanpos = xsp;
    if (jj_3R_285()) {
    jj_scanpos = xsp;
    if (jj_3R_286()) {
    jj_scanpos = xsp;
    if (jj_3R_287()) {
    jj_scanpos = xsp;
    if (jj_3R_288()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_119() {
    if (jj_3R_152()) return true;
    return false;
  }

  private boolean jj_3R_185() {
    if (jj_3R_321()) return true;
    return false;
  }

  private boolean jj_3R_968() {
    if (jj_scan_token(OP_SUB)) return true;
    if (jj_3R_884()) return true;
    return false;
  }

  private boolean jj_3_31() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_828() {
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3R_184() {
    if (jj_3R_320()) return true;
    return false;
  }

  private boolean jj_3R_602() {
    if (jj_3R_707()) return true;
    return false;
  }

  private boolean jj_3R_183() {
    if (jj_3R_319()) return true;
    return false;
  }

  private boolean jj_3R_827() {
    if (jj_3R_152()) return true;
    return false;
  }

  private boolean jj_3_11() {
    if (jj_3R_72()) return true;
    return false;
  }

  private boolean jj_3_89() {
    if (jj_3R_148()) return true;
    return false;
  }

  private boolean jj_3_133() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(111)) jj_scanpos = xsp;
    if (jj_3R_161()) return true;
    return false;
  }

  private boolean jj_3R_646() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_827()) {
    jj_scanpos = xsp;
    if (jj_3R_828()) return true;
    }
    return false;
  }

  private boolean jj_3R_535() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    if (jj_3R_90()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_31()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_182() {
    if (jj_3R_318()) return true;
    return false;
  }

  private boolean jj_3R_901() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3_88() {
    if (jj_3R_147()) return true;
    return false;
  }

  private boolean jj_3R_770() {
    if (jj_3R_663()) return true;
    return false;
  }

  private boolean jj_3_85() {
    if (jj_3R_144()) return true;
    return false;
  }

  private boolean jj_3R_71() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_182()) {
    jj_scanpos = xsp;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3R_183()) {
    jj_scanpos = xsp;
    if (jj_3R_184()) {
    jj_scanpos = xsp;
    if (jj_3R_185()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_967() {
    if (jj_scan_token(OP_ADD)) return true;
    if (jj_3R_884()) return true;
    return false;
  }

  private boolean jj_3_87() {
    if (jj_3R_146()) return true;
    return false;
  }

  private boolean jj_3R_769() {
    if (jj_3R_360()) return true;
    return false;
  }

  private boolean jj_3_84() {
    if (jj_3R_143()) return true;
    return false;
  }

  private boolean jj_3R_859() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_901()) jj_scanpos = xsp;
    if (jj_3R_161()) return true;
    return false;
  }

  private boolean jj_3R_768() {
    if (jj_3R_662()) return true;
    return false;
  }

  private boolean jj_3_86() {
    if (jj_3R_145()) return true;
    return false;
  }

  private boolean jj_3_83() {
    if (jj_3R_142()) return true;
    return false;
  }

  private boolean jj_3R_767() {
    if (jj_3R_355()) return true;
    return false;
  }

  private boolean jj_3R_670() {
    if (jj_3R_161()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_859()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_601() {
    if (jj_3R_144()) return true;
    return false;
  }

  private boolean jj_3R_829() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_766() {
    if (jj_3R_358()) return true;
    return false;
  }

  private boolean jj_3_82() {
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_600() {
    if (jj_3R_143()) return true;
    return false;
  }

  private boolean jj_3R_952() {
    if (jj_3R_968()) return true;
    return false;
  }

  private boolean jj_3R_765() {
    if (jj_3R_377()) return true;
    return false;
  }

  private boolean jj_3R_951() {
    if (jj_3R_967()) return true;
    return false;
  }

  private boolean jj_3R_647() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_829()) jj_scanpos = xsp;
    if (jj_3R_646()) return true;
    return false;
  }

  private boolean jj_3R_599() {
    if (jj_3R_142()) return true;
    return false;
  }

  private boolean jj_3_10() {
    if (jj_3R_71()) return true;
    return false;
  }

  private boolean jj_3R_454() {
    if (jj_3R_536()) return true;
    return false;
  }

  private boolean jj_3_99() {
    if (jj_3R_137()) return true;
    return false;
  }

  private boolean jj_3R_937() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_951()) {
    jj_scanpos = xsp;
    if (jj_3R_952()) return true;
    }
    return false;
  }

  private boolean jj_3R_598() {
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_69() {
    Token xsp;
    if (jj_3_10()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_10()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_453() {
    if (jj_3R_535()) return true;
    return false;
  }

  private boolean jj_3R_527() {
    if (jj_3R_646()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_647()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_98() {
    if (jj_3R_136()) return true;
    return false;
  }

  private boolean jj_3R_764() {
    if (jj_3R_359()) return true;
    return false;
  }

  private boolean jj_3R_503() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_598()) {
    jj_scanpos = xsp;
    if (jj_3R_599()) {
    jj_scanpos = xsp;
    if (jj_3R_600()) {
    jj_scanpos = xsp;
    if (jj_3R_601()) {
    jj_scanpos = xsp;
    if (jj_3_86()) {
    jj_scanpos = xsp;
    if (jj_3_87()) {
    jj_scanpos = xsp;
    if (jj_3_88()) {
    jj_scanpos = xsp;
    if (jj_3_89()) {
    jj_scanpos = xsp;
    if (jj_3R_602()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_9() {
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_344() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_453()) {
    jj_scanpos = xsp;
    if (jj_3R_454()) return true;
    }
    return false;
  }

  private boolean jj_3R_763() {
    if (jj_3R_372()) return true;
    return false;
  }

  private boolean jj_3R_130() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(UPDATE)) return true;
    if (jj_3R_670()) return true;
    return false;
  }

  private boolean jj_3R_762() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3_30() {
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_919() {
    if (jj_3R_937()) return true;
    return false;
  }

  private boolean jj_3R_761() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_181() {
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_760() {
    if (jj_3R_371()) return true;
    return false;
  }

  private boolean jj_3R_219() {
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_884() {
    if (jj_3R_885()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_919()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_70() {
    Token xsp;
    if (jj_3R_181()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_181()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_96() {
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3_97() {
    if (jj_3R_135()) return true;
    return false;
  }

  private boolean jj_3R_218() {
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_445() {
    if (jj_3R_527()) return true;
    return false;
  }

  private boolean jj_3R_759() {
    if (jj_3R_375()) return true;
    return false;
  }

  private boolean jj_3_95() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_89() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) return true;
    }
    return false;
  }

  private boolean jj_3R_758() {
    if (jj_3R_374()) return true;
    return false;
  }

  private boolean jj_3R_706() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_GE)) return true;
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_116() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(DISTRIBUTE)) return true;
    if (jj_scan_token(SIMD)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_445()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_757() {
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3R_980() {
    if (jj_scan_token(OP_SL)) return true;
    if (jj_3R_926()) return true;
    return false;
  }

  private boolean jj_3R_756() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_477() {
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(EXIT)) return true;
    if (jj_scan_token(DATA)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_317() {
    if (jj_scan_token(STATIC_ASSERT)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_397()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_619() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_756()) {
    jj_scanpos = xsp;
    if (jj_3R_757()) {
    jj_scanpos = xsp;
    if (jj_3R_758()) {
    jj_scanpos = xsp;
    if (jj_3R_759()) {
    jj_scanpos = xsp;
    if (jj_3_97()) {
    jj_scanpos = xsp;
    if (jj_3R_760()) {
    jj_scanpos = xsp;
    if (jj_3R_761()) {
    jj_scanpos = xsp;
    if (jj_3R_762()) {
    jj_scanpos = xsp;
    if (jj_3R_763()) {
    jj_scanpos = xsp;
    if (jj_3R_764()) {
    jj_scanpos = xsp;
    if (jj_3_98()) {
    jj_scanpos = xsp;
    if (jj_3_99()) {
    jj_scanpos = xsp;
    if (jj_3R_765()) {
    jj_scanpos = xsp;
    if (jj_3R_766()) {
    jj_scanpos = xsp;
    if (jj_3R_767()) {
    jj_scanpos = xsp;
    if (jj_3R_768()) {
    jj_scanpos = xsp;
    if (jj_3R_769()) {
    jj_scanpos = xsp;
    if (jj_3R_770()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_29() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_379() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_477()) jj_scanpos = xsp;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_343() {
    if (jj_scan_token(LEFTBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_29()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RIGHTBRACE)) return true;
    return false;
  }

  private boolean jj_3R_140() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_GT)) return true;
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_979() {
    if (jj_scan_token(OP_SR)) return true;
    if (jj_3R_926()) return true;
    return false;
  }

  private boolean jj_3R_370() {
    if (jj_scan_token(THREADLIMIT)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_179() {
    if (jj_3R_317()) return true;
    return false;
  }

  private boolean jj_3R_974() {
    if (jj_3R_980()) return true;
    return false;
  }

  private boolean jj_3R_316() {
    if (jj_3R_396()) return true;
    return false;
  }

  private boolean jj_3R_452() {
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_139() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_LE)) return true;
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_973() {
    if (jj_3R_979()) return true;
    return false;
  }

  private boolean jj_3R_342() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_452()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_957() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_973()) {
    jj_scanpos = xsp;
    if (jj_3R_974()) return true;
    }
    return false;
  }

  private boolean jj_3R_282() {
    if (jj_3R_367()) return true;
    return false;
  }

  private boolean jj_3_8() {
    if (jj_3R_69()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_316()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_771() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_281() {
    if (jj_3R_368()) return true;
    return false;
  }

  private boolean jj_3R_67() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) return true;
    }
    return false;
  }

  private boolean jj_3R_369() {
    if (jj_scan_token(NUMTEAMS)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_280() {
    if (jj_3R_364()) return true;
    return false;
  }

  private boolean jj_3R_620() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_771()) jj_scanpos = xsp;
    if (jj_3R_619()) return true;
    return false;
  }

  private boolean jj_3R_279() {
    if (jj_3R_362()) return true;
    return false;
  }

  private boolean jj_3R_278() {
    if (jj_3R_379()) return true;
    return false;
  }

  private boolean jj_3R_941() {
    if (jj_3R_957()) return true;
    return false;
  }

  private boolean jj_3R_513() {
    if (jj_3R_619()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_620()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_138() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_LT)) return true;
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_339() {
    if (jj_scan_token(DFLT)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_160() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_278()) {
    jj_scanpos = xsp;
    if (jj_3R_279()) {
    jj_scanpos = xsp;
    if (jj_3R_280()) {
    jj_scanpos = xsp;
    if (jj_3R_281()) {
    jj_scanpos = xsp;
    if (jj_3R_282()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_926() {
    if (jj_3R_884()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_941()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3R_256() {
    if (jj_3R_359()) return true;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_70()) return true;
    return false;
  }

  private boolean jj_3R_255() {
    if (jj_3R_372()) return true;
    return false;
  }

  private boolean jj_3R_597() {
    if (jj_3R_706()) return true;
    return false;
  }

  private boolean jj_3R_254() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3R_180() {
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3R_253() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3_81() {
    if (jj_3R_140()) return true;
    return false;
  }

  private boolean jj_3_132() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(111)) jj_scanpos = xsp;
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3R_978() {
    if (jj_scan_token(OP_GE)) return true;
    if (jj_3R_911()) return true;
    return false;
  }

  private boolean jj_3R_431() {
    if (jj_3R_513()) return true;
    return false;
  }

  private boolean jj_3R_68() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_180()) jj_scanpos = xsp;
    if (jj_3R_81()) return true;
    xsp = jj_scanpos;
    if (jj_3_7()) jj_scanpos = xsp;
    if (jj_3R_343()) return true;
    return false;
  }

  private boolean jj_3R_338() {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_397()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_252() {
    if (jj_3R_371()) return true;
    return false;
  }

  private boolean jj_3R_966() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3_80() {
    if (jj_3R_139()) return true;
    return false;
  }

  private boolean jj_3_118() {
    if (jj_3R_135()) return true;
    return false;
  }

  private boolean jj_3_79() {
    if (jj_3R_138()) return true;
    return false;
  }

  private boolean jj_3R_251() {
    if (jj_3R_370()) return true;
    return false;
  }

  private boolean jj_3R_947() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_966()) jj_scanpos = xsp;
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3R_101() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(PARALLEL)) return true;
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(SIMD)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_431()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_502() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_79()) {
    jj_scanpos = xsp;
    if (jj_3_80()) {
    jj_scanpos = xsp;
    if (jj_3_81()) {
    jj_scanpos = xsp;
    if (jj_3R_597()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_250() {
    if (jj_3R_369()) return true;
    return false;
  }

  private boolean jj_3R_858() {
    if (jj_3R_160()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_947()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_977() {
    if (jj_scan_token(OP_LE)) return true;
    if (jj_3R_911()) return true;
    return false;
  }

  private boolean jj_3R_151() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_250()) {
    jj_scanpos = xsp;
    if (jj_3R_251()) {
    jj_scanpos = xsp;
    if (jj_3_118()) {
    jj_scanpos = xsp;
    if (jj_3R_252()) {
    jj_scanpos = xsp;
    if (jj_3R_253()) {
    jj_scanpos = xsp;
    if (jj_3R_254()) {
    jj_scanpos = xsp;
    if (jj_3R_255()) {
    jj_scanpos = xsp;
    if (jj_3R_256()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_178() {
    if (jj_3R_315()) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_68()) return true;
    return false;
  }

  private boolean jj_3R_337() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3_131() {
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3R_177() {
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_65() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_177()) {
    jj_scanpos = xsp;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_178()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_501() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_ASS)) return true;
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_976() {
    if (jj_scan_token(OP_GT)) return true;
    if (jj_3R_911()) return true;
    return false;
  }

  private boolean jj_3R_669() {
    if (jj_3R_858()) return true;
    return false;
  }

  private boolean jj_3R_215() {
    if (jj_3R_339()) return true;
    return false;
  }

  private boolean jj_3R_897() {
    if (jj_scan_token(USEDEVICEPTR)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_466()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_826() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_214() {
    if (jj_3R_338()) return true;
    return false;
  }

  private boolean jj_3R_129() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(EXIT)) return true;
    if (jj_scan_token(DATA)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_669()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_213() {
    if (jj_3R_337()) return true;
    return false;
  }

  private boolean jj_3R_176() {
    if (jj_3R_86()) return true;
    return false;
  }

  private boolean jj_3R_645() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_826()) jj_scanpos = xsp;
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3R_975() {
    if (jj_scan_token(OP_LT)) return true;
    if (jj_3R_911()) return true;
    return false;
  }

  private boolean jj_3R_85() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_213()) {
    jj_scanpos = xsp;
    if (jj_3R_214()) {
    jj_scanpos = xsp;
    if (jj_3R_215()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_66()) return true;
    return false;
  }

  private boolean jj_3R_526() {
    if (jj_3R_151()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_645()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_65()) return true;
    return false;
  }

  private boolean jj_3R_421() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_501()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_3R_502()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_3R_503()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_64() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_176()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_27() {
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_961() {
    if (jj_3R_978()) return true;
    return false;
  }

  private boolean jj_3R_681() {
    if (jj_scan_token(DELETE)) return true;
    return false;
  }

  private boolean jj_3R_226() {
    if (jj_3R_66()) return true;
    return false;
  }

  private boolean jj_3R_896() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(DATA)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_960() {
    if (jj_3R_977()) return true;
    return false;
  }

  private boolean jj_3R_680() {
    if (jj_scan_token(RELEASE)) return true;
    return false;
  }

  private boolean jj_3_28() {
    if (jj_3R_88()) return true;
    return false;
  }

  private boolean jj_3R_959() {
    if (jj_3R_976()) return true;
    return false;
  }

  private boolean jj_3R_679() {
    if (jj_scan_token(ALLOC)) return true;
    return false;
  }

  private boolean jj_3R_958() {
    if (jj_3R_975()) return true;
    return false;
  }

  private boolean jj_3R_225() {
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_444() {
    if (jj_3R_526()) return true;
    return false;
  }

  private boolean jj_3R_678() {
    if (jj_scan_token(TOFROM)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_64()) return true;
    return false;
  }

  private boolean jj_3R_942() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_958()) {
    jj_scanpos = xsp;
    if (jj_3R_959()) {
    jj_scanpos = xsp;
    if (jj_3R_960()) {
    jj_scanpos = xsp;
    if (jj_3R_961()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_677() {
    if (jj_scan_token(FROM)) return true;
    return false;
  }

  private boolean jj_3_26() {
    if (jj_3R_86()) return true;
    return false;
  }

  private boolean jj_3R_115() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TEAMS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_444()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_676() {
    if (jj_scan_token(TO)) return true;
    return false;
  }

  private boolean jj_3R_224() {
    if (jj_3R_346()) return true;
    return false;
  }

  private boolean jj_3R_367() {
    if (jj_scan_token(NOWAIT)) return true;
    return false;
  }

  private boolean jj_3R_223() {
    if (jj_3R_345()) return true;
    return false;
  }

  private boolean jj_3R_564() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_676()) {
    jj_scanpos = xsp;
    if (jj_3R_677()) {
    jj_scanpos = xsp;
    if (jj_3R_678()) {
    jj_scanpos = xsp;
    if (jj_3R_679()) {
    jj_scanpos = xsp;
    if (jj_3R_680()) {
    jj_scanpos = xsp;
    if (jj_3R_681()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_222() {
    if (jj_3R_344()) return true;
    return false;
  }

  private boolean jj_3R_754() {
    if (jj_3R_897()) return true;
    return false;
  }

  private boolean jj_3R_221() {
    if (jj_3R_343()) return true;
    return false;
  }

  private boolean jj_3R_753() {
    if (jj_3R_364()) return true;
    return false;
  }

  private boolean jj_3_117() {
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3R_927() {
    if (jj_3R_942()) return true;
    return false;
  }

  private boolean jj_3R_220() {
    if (jj_3R_342()) return true;
    return false;
  }

  private boolean jj_3R_752() {
    if (jj_3R_362()) return true;
    return false;
  }

  private boolean jj_3R_824() {
    if (jj_3R_152()) return true;
    return false;
  }

  private boolean jj_3R_751() {
    if (jj_3R_896()) return true;
    return false;
  }

  private boolean jj_3_25() {
    if (jj_3R_85()) return true;
    return false;
  }

  private boolean jj_3R_911() {
    if (jj_3R_926()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_927()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_918() {
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_823() {
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3R_617() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_751()) {
    jj_scanpos = xsp;
    if (jj_3R_752()) {
    jj_scanpos = xsp;
    if (jj_3R_753()) {
    jj_scanpos = xsp;
    if (jj_3R_754()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_90() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_25()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) {
    jj_scanpos = xsp;
    if (jj_3R_222()) {
    jj_scanpos = xsp;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) {
    jj_scanpos = xsp;
    if (jj_3_26()) {
    jj_scanpos = xsp;
    if (jj_3R_225()) {
    jj_scanpos = xsp;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3R_226()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_643() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_823()) {
    jj_scanpos = xsp;
    if (jj_3R_824()) return true;
    }
    return false;
  }

  private boolean jj_3R_663() {
    if (jj_scan_token(ORDERED)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_918()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_674() {
    if (jj_scan_token(ALWAYS)) return true;
    return false;
  }

  private boolean jj_3R_963() {
    if (jj_scan_token(OP_NEQ)) return true;
    if (jj_3R_877()) return true;
    return false;
  }

  private boolean jj_3R_755() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_825() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_324() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_618() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_755()) jj_scanpos = xsp;
    if (jj_3R_617()) return true;
    return false;
  }

  private boolean jj_3R_675() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_644() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_825()) jj_scanpos = xsp;
    if (jj_3R_643()) return true;
    return false;
  }

  private boolean jj_3R_962() {
    if (jj_scan_token(OP_EQ)) return true;
    if (jj_3R_877()) return true;
    return false;
  }

  private boolean jj_3R_360() {
    if (jj_scan_token(COLLAPSE)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_512() {
    if (jj_3R_617()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_618()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_525() {
    if (jj_3R_643()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_644()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_930() {
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_563() {
    if (jj_3R_674()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_675()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_929() {
    if (jj_3R_593()) return true;
    return false;
  }

  private boolean jj_3R_944() {
    if (jj_3R_963()) return true;
    return false;
  }

  private boolean jj_3R_471() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_563()) jj_scanpos = xsp;
    if (jj_3R_564()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_913() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_929()) {
    jj_scanpos = xsp;
    if (jj_3R_930()) return true;
    }
    return false;
  }

  private boolean jj_3R_943() {
    if (jj_3R_962()) return true;
    return false;
  }

  private boolean jj_3R_572() {
    if (jj_scan_token(AUTO)) return true;
    return false;
  }

  private boolean jj_3R_364() {
    if (jj_scan_token(MAP)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_471()) jj_scanpos = xsp;
    if (jj_3R_466()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_928() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_943()) {
    jj_scanpos = xsp;
    if (jj_3R_944()) return true;
    }
    return false;
  }

  private boolean jj_3R_571() {
    if (jj_scan_token(RUNTIME)) return true;
    return false;
  }

  private boolean jj_3R_430() {
    if (jj_3R_512()) return true;
    return false;
  }

  private boolean jj_3R_570() {
    if (jj_scan_token(GUIDED)) return true;
    return false;
  }

  private boolean jj_3R_443() {
    if (jj_3R_525()) return true;
    return false;
  }

  private boolean jj_3R_569() {
    if (jj_scan_token(DYNAMIC)) return true;
    return false;
  }

  private boolean jj_3R_879() {
    if (jj_3R_913()) return true;
    return false;
  }

  private boolean jj_3R_100() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(DATA)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_430()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_568() {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_114() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TEAMS)) return true;
    if (jj_scan_token(DISTRIBUTE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_443()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_688() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_879()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_912() {
    if (jj_3R_928()) return true;
    return false;
  }

  private boolean jj_3R_473() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_568()) {
    jj_scanpos = xsp;
    if (jj_3R_569()) {
    jj_scanpos = xsp;
    if (jj_3R_570()) {
    jj_scanpos = xsp;
    if (jj_3R_571()) {
    jj_scanpos = xsp;
    if (jj_3R_572()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_877() {
    if (jj_3R_911()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_912()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_116() {
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3R_84() {
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_212()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_895() {
    if (jj_scan_token(NOGROUP)) return true;
    return false;
  }

  private boolean jj_3R_821() {
    if (jj_3R_646()) return true;
    return false;
  }

  private boolean jj_3R_362() {
    if (jj_scan_token(DEVICE)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_950() {
    if (jj_scan_token(SIMD)) return true;
    return false;
  }

  private boolean jj_3R_878() {
    if (jj_scan_token(OP_BITAND)) return true;
    if (jj_3R_686()) return true;
    return false;
  }

  private boolean jj_3R_820() {
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3R_949() {
    if (jj_scan_token(NONMONOTONIC)) return true;
    return false;
  }

  private boolean jj_3R_641() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_820()) {
    jj_scanpos = xsp;
    if (jj_3R_821()) return true;
    }
    return false;
  }

  private boolean jj_3R_686() {
    if (jj_3R_877()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_878()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_948() {
    if (jj_scan_token(MONOTONIC)) return true;
    return false;
  }

  private boolean jj_3R_499() {
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_894() {
    if (jj_scan_token(NUMTASKS)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_935() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_948()) {
    jj_scanpos = xsp;
    if (jj_3R_949()) {
    jj_scanpos = xsp;
    if (jj_3R_950()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_498() {
    if (jj_3R_593()) return true;
    return false;
  }

  private boolean jj_3_24() {
    if (jj_3R_84()) return true;
    return false;
  }

  private boolean jj_3R_419() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_24()) {
    jj_scanpos = xsp;
    if (jj_3R_498()) {
    jj_scanpos = xsp;
    if (jj_3R_499()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_822() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_476() {
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(ENTER)) return true;
    if (jj_scan_token(DATA)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_687() {
    if (jj_scan_token(OP_BITXOR)) return true;
    if (jj_3R_586()) return true;
    return false;
  }

  private boolean jj_3R_642() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_822()) jj_scanpos = xsp;
    if (jj_3R_641()) return true;
    return false;
  }

  private boolean jj_3R_378() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_476()) jj_scanpos = xsp;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_893() {
    if (jj_scan_token(GRAINSIZE)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_586() {
    if (jj_3R_686()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_687()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_524() {
    if (jj_3R_641()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_642()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_917() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_335() {
    if (jj_3R_419()) return true;
    if (jj_3R_688()) return true;
    return false;
  }

  private boolean jj_3R_936() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_935()) return true;
    return false;
  }

  private boolean jj_3R_211() {
    if (jj_3R_335()) return true;
    return false;
  }

  private boolean jj_3R_587() {
    if (jj_scan_token(OP_BITOR)) return true;
    if (jj_3R_486()) return true;
    return false;
  }

  private boolean jj_3R_916() {
    if (jj_3R_935()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_936()) jj_scanpos = xsp;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_83() {
    if (jj_3R_210()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_211()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_442() {
    if (jj_3R_524()) return true;
    return false;
  }

  private boolean jj_3R_922() {
    if (jj_scan_token(TASKLOOP)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_486() {
    if (jj_3R_586()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_587()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_277() {
    if (jj_3R_367()) return true;
    return false;
  }

  private boolean jj_3R_662() {
    if (jj_scan_token(SCHEDULE)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_916()) jj_scanpos = xsp;
    if (jj_3R_473()) return true;
    xsp = jj_scanpos;
    if (jj_3R_917()) jj_scanpos = xsp;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_892() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_922()) jj_scanpos = xsp;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_113() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TEAMS)) return true;
    if (jj_scan_token(DISTRIBUTE)) return true;
    if (jj_scan_token(SIMD)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_442()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_276() {
    if (jj_3R_368()) return true;
    return false;
  }

  private boolean jj_3R_275() {
    if (jj_3R_364()) return true;
    return false;
  }

  private boolean jj_3R_336() {
    if (jj_3R_335()) return true;
    return false;
  }

  private boolean jj_3R_274() {
    if (jj_3R_362()) return true;
    return false;
  }

  private boolean jj_3_23() {
    if (jj_3R_83()) return true;
    return false;
  }

  private boolean jj_3R_273() {
    if (jj_3R_378()) return true;
    return false;
  }

  private boolean jj_3R_212() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_23()) {
    jj_scanpos = xsp;
    if (jj_3R_336()) return true;
    }
    return false;
  }

  private boolean jj_3R_159() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_273()) {
    jj_scanpos = xsp;
    if (jj_3R_274()) {
    jj_scanpos = xsp;
    if (jj_3R_275()) {
    jj_scanpos = xsp;
    if (jj_3R_276()) {
    jj_scanpos = xsp;
    if (jj_3R_277()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_115() {
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3R_487() {
    if (jj_scan_token(OP_AND)) return true;
    if (jj_3R_390()) return true;
    return false;
  }

  private boolean jj_3R_390() {
    if (jj_3R_486()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_487()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_818() {
    if (jj_3R_650()) return true;
    return false;
  }

  private boolean jj_3R_749() {
    if (jj_3R_895()) return true;
    return false;
  }

  private boolean jj_3R_817() {
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3R_748() {
    if (jj_3R_890()) return true;
    return false;
  }

  private boolean jj_3R_310() {
    if (jj_3R_212()) return true;
    return false;
  }

  private boolean jj_3R_747() {
    if (jj_3R_889()) return true;
    return false;
  }

  private boolean jj_3_130() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(111)) jj_scanpos = xsp;
    if (jj_3R_159()) return true;
    return false;
  }

  private boolean jj_3R_639() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_817()) {
    jj_scanpos = xsp;
    if (jj_3R_818()) return true;
    }
    return false;
  }

  private boolean jj_3R_172() {
    if (jj_3R_201()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_310()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_965() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_746() {
    if (jj_3R_891()) return true;
    return false;
  }

  private boolean jj_3R_745() {
    if (jj_3R_888()) return true;
    return false;
  }

  private boolean jj_3R_467() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_744() {
    if (jj_3R_360()) return true;
    return false;
  }

  private boolean jj_3R_946() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_965()) jj_scanpos = xsp;
    if (jj_3R_159()) return true;
    return false;
  }

  private boolean jj_3R_743() {
    if (jj_3R_894()) return true;
    return false;
  }

  private boolean jj_3R_391() {
    if (jj_scan_token(OP_OR)) return true;
    if (jj_3R_308()) return true;
    return false;
  }

  private boolean jj_3R_355() {
    if (jj_scan_token(LINEAR)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_466()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_467()) jj_scanpos = xsp;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_857() {
    if (jj_3R_159()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_946()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_742() {
    if (jj_3R_893()) return true;
    return false;
  }

  private boolean jj_3R_819() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_308() {
    if (jj_3R_390()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_391()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_741() {
    if (jj_3R_371()) return true;
    return false;
  }

  private boolean jj_3_22() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3_94() {
    if (jj_3R_135()) return true;
    return false;
  }

  private boolean jj_3R_640() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_819()) jj_scanpos = xsp;
    if (jj_3R_639()) return true;
    return false;
  }

  private boolean jj_3_129() {
    if (jj_3R_159()) return true;
    return false;
  }

  private boolean jj_3R_740() {
    if (jj_3R_358()) return true;
    return false;
  }

  private boolean jj_3R_931() {
    if (jj_3R_82()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_22()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_739() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3R_523() {
    if (jj_3R_639()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_640()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_738() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_668() {
    if (jj_3R_857()) return true;
    return false;
  }

  private boolean jj_3R_737() {
    if (jj_3R_372()) return true;
    return false;
  }

  private boolean jj_3R_397() {
    if (jj_3R_171()) return true;
    return false;
  }

  private boolean jj_3R_736() {
    if (jj_3R_892()) return true;
    return false;
  }

  private boolean jj_3R_358() {
    if (jj_scan_token(LASTPRIVATE)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_466()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_615() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_736()) {
    jj_scanpos = xsp;
    if (jj_3R_737()) {
    jj_scanpos = xsp;
    if (jj_3R_738()) {
    jj_scanpos = xsp;
    if (jj_3R_739()) {
    jj_scanpos = xsp;
    if (jj_3R_740()) {
    jj_scanpos = xsp;
    if (jj_3_94()) {
    jj_scanpos = xsp;
    if (jj_3R_741()) {
    jj_scanpos = xsp;
    if (jj_3R_742()) {
    jj_scanpos = xsp;
    if (jj_3R_743()) {
    jj_scanpos = xsp;
    if (jj_3R_744()) {
    jj_scanpos = xsp;
    if (jj_3R_745()) {
    jj_scanpos = xsp;
    if (jj_3R_746()) {
    jj_scanpos = xsp;
    if (jj_3R_747()) {
    jj_scanpos = xsp;
    if (jj_3R_748()) {
    jj_scanpos = xsp;
    if (jj_3R_749()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_128() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TARGET)) return true;
    if (jj_scan_token(ENTER)) return true;
    if (jj_scan_token(DATA)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_668()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_932() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_441() {
    if (jj_3R_523()) return true;
    return false;
  }

  private boolean jj_3R_330() {
    if (jj_scan_token(LEFTBRACE)) return true;
    if (jj_3R_931()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_932()) jj_scanpos = xsp;
    if (jj_scan_token(RIGHTBRACE)) return true;
    return false;
  }

  private boolean jj_3R_309() {
    if (jj_scan_token(QUESTION)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_171()) return true;
    return false;
  }

  private boolean jj_3R_704() {
    if (jj_3R_367()) return true;
    return false;
  }

  private boolean jj_3R_112() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TEAMS)) return true;
    if (jj_scan_token(DISTRIBUTE)) return true;
    if (jj_scan_token(PARALLEL)) return true;
    if (jj_scan_token(FOR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_441()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_171() {
    if (jj_3R_308()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_309()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_703() {
    if (jj_3R_663()) return true;
    return false;
  }

  private boolean jj_3R_702() {
    if (jj_3R_360()) return true;
    return false;
  }

  private boolean jj_3R_127() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TASKYIELD)) return true;
    if (jj_3R_156()) return true;
    return false;
  }

  private boolean jj_3R_701() {
    if (jj_3R_662()) return true;
    return false;
  }

  private boolean jj_3R_209() {
    if (jj_3R_330()) return true;
    return false;
  }

  private boolean jj_3R_700() {
    if (jj_3R_359()) return true;
    return false;
  }

  private boolean jj_3R_750() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_208() {
    if (jj_3R_313()) return true;
    return false;
  }

  private boolean jj_3R_699() {
    if (jj_3R_355()) return true;
    return false;
  }

  private boolean jj_3R_698() {
    if (jj_3R_358()) return true;
    return false;
  }

  private boolean jj_3R_82() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_3R_209()) return true;
    }
    return false;
  }

  private boolean jj_3_114() {
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3R_616() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_750()) jj_scanpos = xsp;
    if (jj_3R_615()) return true;
    return false;
  }

  private boolean jj_3R_697() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3R_307() {
    if (jj_scan_token(OP_ORASS)) return true;
    return false;
  }

  private boolean jj_3R_972() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_SUB)) return true;
    if (jj_3R_397()) return true;
    return false;
  }

  private boolean jj_3R_696() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_306() {
    if (jj_scan_token(OP_XORASS)) return true;
    return false;
  }

  private boolean jj_3R_815() {
    if (jj_3R_648()) return true;
    return false;
  }

  private boolean jj_3R_511() {
    if (jj_3R_615()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_616()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_305() {
    if (jj_scan_token(OP_ANDASS)) return true;
    return false;
  }

  private boolean jj_3R_595() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_696()) {
    jj_scanpos = xsp;
    if (jj_3R_697()) {
    jj_scanpos = xsp;
    if (jj_3R_698()) {
    jj_scanpos = xsp;
    if (jj_3R_699()) {
    jj_scanpos = xsp;
    if (jj_3R_700()) {
    jj_scanpos = xsp;
    if (jj_3R_701()) {
    jj_scanpos = xsp;
    if (jj_3R_702()) {
    jj_scanpos = xsp;
    if (jj_3R_703()) {
    jj_scanpos = xsp;
    if (jj_3R_704()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_814() {
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3R_304() {
    if (jj_scan_token(OP_SRASS)) return true;
    return false;
  }

  private boolean jj_3R_637() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_814()) {
    jj_scanpos = xsp;
    if (jj_3R_815()) return true;
    }
    return false;
  }

  private boolean jj_3R_303() {
    if (jj_scan_token(OP_SLASS)) return true;
    return false;
  }

  private boolean jj_3R_934() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_302() {
    if (jj_scan_token(OP_SUBASS)) return true;
    return false;
  }

  private boolean jj_3R_301() {
    if (jj_scan_token(OP_ADDASS)) return true;
    return false;
  }

  private boolean jj_3R_915() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_934()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_158() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OP_ADD)) return true;
    if (jj_3R_397()) return true;
    return false;
  }

  private boolean jj_3R_300() {
    if (jj_scan_token(OP_MODASS)) return true;
    return false;
  }

  private boolean jj_3R_429() {
    if (jj_3R_511()) return true;
    return false;
  }

  private boolean jj_3R_299() {
    if (jj_scan_token(OP_DIVASS)) return true;
    return false;
  }

  private boolean jj_3R_298() {
    if (jj_scan_token(OP_MULASS)) return true;
    return false;
  }

  private boolean jj_3R_816() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_705() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_99() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TASKLOOP)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_429()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_297() {
    if (jj_scan_token(OP_ASS)) return true;
    return false;
  }

  private boolean jj_3R_638() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_816()) jj_scanpos = xsp;
    if (jj_3R_637()) return true;
    return false;
  }

  private boolean jj_3R_170() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_297()) {
    jj_scanpos = xsp;
    if (jj_3R_298()) {
    jj_scanpos = xsp;
    if (jj_3R_299()) {
    jj_scanpos = xsp;
    if (jj_3R_300()) {
    jj_scanpos = xsp;
    if (jj_3R_301()) {
    jj_scanpos = xsp;
    if (jj_3R_302()) {
    jj_scanpos = xsp;
    if (jj_3R_303()) {
    jj_scanpos = xsp;
    if (jj_3R_304()) {
    jj_scanpos = xsp;
    if (jj_3R_305()) {
    jj_scanpos = xsp;
    if (jj_3R_306()) {
    jj_scanpos = xsp;
    if (jj_3R_307()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_956() {
    if (jj_3R_972()) return true;
    return false;
  }

  private boolean jj_3R_596() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_705()) jj_scanpos = xsp;
    if (jj_3R_595()) return true;
    return false;
  }

  private boolean jj_3R_914() {
    if (jj_3R_212()) return true;
    return false;
  }

  private boolean jj_3R_522() {
    if (jj_3R_637()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_638()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_128() {
    if (jj_3R_158()) return true;
    return false;
  }

  private boolean jj_3R_500() {
    if (jj_3R_595()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_596()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_882() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_914()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_93() {
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3R_939() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_128()) {
    jj_scanpos = xsp;
    if (jj_3R_956()) return true;
    }
    return false;
  }

  private boolean jj_3R_734() {
    if (jj_3R_615()) return true;
    return false;
  }

  private boolean jj_3_21() {
    if (jj_3R_81()) return true;
    return false;
  }

  private boolean jj_3R_733() {
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3R_692() {
    if (jj_3R_882()) return true;
    return false;
  }

  private boolean jj_3R_613() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_733()) {
    jj_scanpos = xsp;
    if (jj_3R_734()) return true;
    }
    return false;
  }

  private boolean jj_3R_691() {
    if (jj_3R_81()) return true;
    return false;
  }

  private boolean jj_3R_440() {
    if (jj_3R_522()) return true;
    return false;
  }

  private boolean jj_3R_420() {
    if (jj_3R_500()) return true;
    return false;
  }

  private boolean jj_3R_940() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_939()) return true;
    return false;
  }

  private boolean jj_3R_590() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_691()) {
    jj_scanpos = xsp;
    if (jj_3R_692()) return true;
    }
    return false;
  }

  private boolean jj_3R_923() {
    if (jj_3R_939()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_940()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_92() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(FOR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_420()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_111() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TEAMS)) return true;
    if (jj_scan_token(DISTRIBUTE)) return true;
    if (jj_scan_token(PARALLEL)) return true;
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(SIMD)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_440()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_488() {
    if (jj_3R_169()) return true;
    if (jj_3R_170()) return true;
    if (jj_3R_313()) return true;
    return false;
  }

  private boolean jj_3R_735() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_3R_69()) return true;
    if (jj_3R_590()) return true;
    return false;
  }

  private boolean jj_3R_614() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_735()) jj_scanpos = xsp;
    if (jj_3R_613()) return true;
    return false;
  }

  private boolean jj_3_144() {
    if (jj_3R_169()) return true;
    if (jj_3R_170()) return true;
    return false;
  }

  private boolean jj_3R_510() {
    if (jj_3R_613()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_614()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_145() {
    if (jj_3R_171()) return true;
    return false;
  }

  private boolean jj_3R_394() {
    if (jj_3R_488()) return true;
    return false;
  }

  private boolean jj_3R_900() {
    if (jj_scan_token(DEPEND)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_scan_token(SINK)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_923()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_377() {
    if (jj_scan_token(PROC_BIND)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_scan_token(SPREAD)) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_313() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_394()) {
    jj_scanpos = xsp;
    if (jj_3_145()) return true;
    }
    return false;
  }

  private boolean jj_3_20() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_80()) return true;
    return false;
  }

  private boolean jj_3R_205() {
    if (jj_3R_80()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_20()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_366() {
    if (jj_scan_token(DEFAULTMAP)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_scan_token(TOFROM)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_scan_token(SCALAR)) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_428() {
    if (jj_3R_510()) return true;
    return false;
  }

  private boolean jj_3R_552() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_313()) return true;
    return false;
  }

  private boolean jj_3R_98() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(TASKLOOP)) return true;
    if (jj_scan_token(SIMD)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_428()) jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    if (jj_3R_421()) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_137() {
    if (jj_scan_token(PROC_BIND)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_scan_token(CLOSE)) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_157() {
    if (jj_scan_token(DEPEND)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_scan_token(SOURCE)) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_392() {
    if (jj_3R_313()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_552()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_933() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(ELLIPSIS)) return true;
    return false;
  }

  private boolean jj_3R_79() {
    if (jj_3R_205()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_933()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_365() {
    if (jj_scan_token(ISDEVICEPTR)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_466()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_899() {
    if (jj_scan_token(SIMD)) return true;
    return false;
  }

  private boolean jj_3R_136() {
    if (jj_scan_token(PROC_BIND)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_scan_token(MASTER)) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_891() {
    if (jj_scan_token(PRIORITY)) return true;
    if (jj_scan_token(LEFTPAREN)) return true;
    if (jj_3R_392()) return true;
    if (jj_scan_token(RIGHTPAREN)) return true;
    return false;
  }

  private boolean jj_3R_553() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_466() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_553()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_497() {
    if (jj_3R_319()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public CParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[291];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static private int[] jj_la1_6;
  static private int[] jj_la1_7;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
      jj_la1_init_5();
      jj_la1_init_6();
      jj_la1_init_7();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x1000000,0x40000000,0xae000000,0x2000000,0x4000000,0x40000000,0x0,0xa8000000,0x0,0x0,0x0,0x0,0x0,0xa8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80d100,0x0,0x0,0x0,0xa8000000,0x0,0xa8000000,0x0,0x0,0x0,0x80d100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1080d100,0x0,0x0,0x80d100,0x1080d100,0x0,0x0,0x80d100,0x80d100,0x80d100,0x10000000,0x80d100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80d100,0x80d100,0x0,0x0,0x0,0x0,0x80d100,0x0,0x8000,0xd100,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x2002840,0x40019,0x1,0x0,0x2002840,0x4d9a5120,0x40018,0x21000,0x0,0x21000,0x0,0x0,0x40018,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40018,0x0,0x40018,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb0018600,0x0,0x400080,0x0,0xb0418680,0x80000200,0x20008000,0x0,0x0,0x0,0x10010400,0x0,0x0,0x0,0x0,0x80000080,0x80000080,0x0,0x80000000,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2002000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000080,0x80000080,0x0,0x80000000,0x80,0x0,0x0,0x80000080,0x80000080,0x0,0x80000080,0x80000080,0x80000080,0x0,0x80000000,0x80,0x0,0x80000000,0x80000000,0x0,0x80000000,0x80000080,0x80000080,0x0,0x80000000,0x80,0x0,0x80000080,0x80000080,0x0,0x80000000,0x80,0x0,0x80000080,0x80000080,0x0,0x80000000,0x80,0x0,0x80000000,0x80000000,0x0,0x0,0x80000080,0x80000080,0x0,0x80000080,0x80000080,0x80000080,0x0,0x80000080,0x80000080,0x80000080,0x0,0x80,0x80000080,0x80000080,0x0,0x80,0x80000080,0x80000080,0x0,0x80,0x80000000,0x80000000,0x0,0x80000000,0x0,0x80000080,0x80000080,0x0,0x80000080,0x80000080,0x80000080,0x0,0x80000080,0x80,0x80,0x0,0x0,0x80,0x80,0x0,0x0,0x80,0x80,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x80000080,0x80000080,0x0,0x80000080,0x80000080,0x80000080,0x0,0x80000080,0x0,0x0,0x0,0x0,0x0,0x80000080,0x80000080,0x0,0x0,0x80000080,0x80000080,0x0,0x0,0x80000080,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x80000000,0x0,0x0,0x0,0x80000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x80000000,0x10000000,0x0,0x0,0x0,0x1cc00002,0x0,0x0,0x10000000,0x0,0x10000000,0x0,0x0,0x10000000,0x0,0x1cc00002,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x1cc00003,0x0,0x0,0x1cc00002,0x1cc00003,0x0,0x1,0x1cc00002,0x1cc00002,0x1cc00002,0x0,0x1cc00002,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0000c0,0x0,0x0,0x8000ff18,0x0,0x80,0x40,0x0,0x0,0x0,0x40020,0x40020,0x3180000,0x3180000,0x30000,0x30000,0xc000000,0xc000000,0x70000000,0x70000000,0x1cc00002,0x1cc00002,0x2,0x1c000000,0xe00000,0xe00000,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x10000,0x10000,0x204,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x8000,0x224,0x20,0x0,0x0,0x8000,0x0,0x4,0xa00,0x800,0x200,0x219,0x0,0x200,0x4,0x0,0x4,0x0,0x8000,0xa04,0x8000,0x2219,0x8000,0xa04,0xa00,0xa00,0xa00,0xa00,0xa00,0x2259,0x10000,0x0,0x219,0x12259,0x0,0x0,0x219,0x219,0x219,0x0,0x219,0x0,0x10000,0x10000,0x0,0x8000,0x8000,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x20,0x8000,0x0,0x8000,0x0,0x0,0x200,0x0,0x0,0x0,0x8000,0x8000,0x0,0x10000,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x20,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x8000,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0x0,0x200,0x10000,0x8000,0x0,0x8000,0x0,0x8000,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x0,0x8000,0x0,0x0,0x8000,0x0,0x0,0x0,0x8000,0x0,0x0,0x8000,0x0,0x0,0x200,0x8000,0x8000,0x0,0x10000,0x8000,0x8000,0x0,0x10000,0x0,0x8000,0x8000,0x0,0x0,0x0,0x7,0x8000,0x8000,0x0,0x80,0x0,0x0,0x2,0x4,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x219,0x219,0x0,0x19,0xb00,0xb00,0x200,0x8000,0x0,0x0,0x8000,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x180,0x0,0x0,0x80000000,0x80000000,0x0,0x0,0x80000000,0x0,0x8000,0x86080000,0x86080000,0x0,0x86080000,0x0,0x0,0x0,0x0,0x0,0x38000000,0x0,0x0,0x0,0x82000000,0x82000000,0x0,0x82000000,0x0,0x2000000,0x2000000,0x2000000,0x80000000,0x80000000,0x0,0x80000000,0x0,0x86080000,0x86080000,0x0,0x86080000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x86080000,0x86080000,0x0,0x0,0x80000000,0x4080000,0x86080000,0x86080000,0x0,0x0,0x80000000,0x4080000,0x82000000,0x82000000,0x0,0x0,0x80000000,0x0,0x82000000,0x82000000,0x0,0x80000000,0x86080000,0x86080000,0x0,0x84080000,0x86080000,0x86080000,0x0,0x84080000,0x82000000,0x82000000,0x0,0x80000000,0x82000000,0x82000000,0x0,0x80000000,0x82000000,0x82000000,0x0,0x80000000,0x2000000,0x2000000,0x0,0x2000000,0x0,0x84080000,0x84080000,0x0,0x84080000,0x84080000,0x84080000,0x0,0x84080000,0x80000000,0x80000000,0x0,0x80000000,0x80000000,0x80000000,0x0,0x0,0x80000000,0x80000000,0x0,0x0,0x80000000,0x80000000,0x80000000,0x0,0x80000000,0x84080000,0x84080000,0x0,0x84080000,0x84080000,0x84080000,0x0,0x84080000,0x0,0x0,0x0,0x0,0x0,0x84080000,0x84080000,0x0,0x4080000,0x84080000,0x84080000,0x0,0x4080000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x18000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_5() {
      jj_la1_5 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000b3,0x2000b3,0x0,0x80,0x33,0x200000,0x0,0x1000107,0x1000107,0x0,0x1000107,0x0,0x0,0xe000000,0x0,0xe000000,0x0,0x0,0x0,0x0,0x7,0x7,0x0,0x7,0x0,0xb,0xb,0xb,0x71000105,0x71000105,0x0,0x71000105,0x0,0x71000107,0x71000107,0x0,0x1000107,0x160013,0x160013,0x0,0x120000,0x40013,0x2000,0x0,0x71160117,0x71160117,0x0,0x160117,0x160117,0x160117,0x0,0x17,0x160100,0x0,0x0,0x0,0x0,0x0,0x71200197,0x71200197,0x0,0x80,0x13,0x1200104,0x1200197,0x1200197,0x0,0x80,0x13,0x1200104,0x200093,0x200093,0x0,0x80,0x13,0x200000,0x71000107,0x71000107,0x0,0x71000105,0x712001b7,0x712001b7,0x0,0x712001b7,0x12001b7,0x12001b7,0x0,0x12001b7,0x71000117,0x71000117,0x0,0x71000117,0x117,0x117,0x0,0x117,0x13,0x13,0x0,0x13,0x3,0x3,0x0,0x3,0x0,0x712001b7,0x712001b7,0x0,0x712001b7,0x12001b7,0x12001b7,0x0,0x12001b7,0x71000117,0x71000117,0x0,0x71000107,0x117,0x117,0x0,0x107,0x13,0x13,0x0,0x0,0x13,0x71000107,0x71000107,0x0,0x71000105,0x712001b7,0x712001b7,0x0,0x712001b7,0x12001b7,0x12001b7,0x0,0x12001b7,0x107,0x107,0x0,0x107,0x0,0x712001b7,0x712001b7,0x0,0x1000104,0x12001b7,0x12001b7,0x0,0x1000104,0x2000b7,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1e00,0x8000000,0x8000000,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe1000000,0xe1000000,0x0,0xe1000000,0x80000,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_6() {
      jj_la1_6 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0xc,0x0,0x0,0xc,0x0,0x70,0x708,0x708,0x0,0x708,0x708,0x708,0x0,0x0,0x708,0x80,0x406000,0x406000,0x0,0x406000,0x4806004,0x4806004,0x0,0x0,0x0,0x0,0x4806004,0x4806004,0x0,0x0,0x0,0x0,0x4806004,0x4806004,0x0,0x0,0x0,0x0,0x4806004,0x4806004,0x0,0x0,0x84806004,0x84806004,0x0,0x80000000,0x84806004,0x84806004,0x0,0x80000000,0x84806004,0x84806004,0x0,0x80000000,0x84806004,0x84806004,0x0,0x80000000,0x84806004,0x84806004,0x0,0x80000000,0x4806004,0x4806004,0x0,0x4806004,0x800,0x80000000,0x80000000,0x0,0x0,0x80000000,0x80000000,0x0,0x0,0x80000000,0x80000000,0x0,0x0,0x80000000,0x80000000,0x0,0x0,0x80000000,0x80000000,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x4,0x0,0x0,0x4,0x0,0x0,0x0,0x6004,0x800,0x0,0x200000,0x3f8000,0x1f8000,0x0,0x6004,0x800,0x0,0x1a004,0x800,0x0,0x0,0x0,0x0,0x0,0x20008000,0x0,0x20008000,0x0,0x3,0x3,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_7() {
      jj_la1_7 = new int[] {0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x1000,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x1000,0x1000,0x1000,0x0,0x0,0x1000,0x1000,0x1000,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x5,0x0,0x5,0x5,0x5,0x0,0x5,0x5,0x5,0x0,0x5,0x5,0x5,0x0,0x5,0x1,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x5,0x5,0x0,0x4,0x5,0x5,0x0,0x4,0x5,0x5,0x0,0x4,0x5,0x5,0x0,0x4,0x1,0x1,0x0,0x1,0x0,0x4,0x4,0x0,0x0,0x4,0x4,0x0,0x0,0x4,0x4,0x0,0x0,0x4,0x4,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x10,0x0,0x10,0x0,0x10,0x0,0x20,0x20,0x0,0x20,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x1000,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[149];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public CParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public CParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 291; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 291; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public CParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new CParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 291; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 291; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public CParser(CParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 291; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(CParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 291; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[239];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 291; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
          if ((jj_la1_6[i] & (1<<j)) != 0) {
            la1tokens[192+j] = true;
          }
          if ((jj_la1_7[i] & (1<<j)) != 0) {
            la1tokens[224+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 239; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 149; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
            case 45: jj_3_46(); break;
            case 46: jj_3_47(); break;
            case 47: jj_3_48(); break;
            case 48: jj_3_49(); break;
            case 49: jj_3_50(); break;
            case 50: jj_3_51(); break;
            case 51: jj_3_52(); break;
            case 52: jj_3_53(); break;
            case 53: jj_3_54(); break;
            case 54: jj_3_55(); break;
            case 55: jj_3_56(); break;
            case 56: jj_3_57(); break;
            case 57: jj_3_58(); break;
            case 58: jj_3_59(); break;
            case 59: jj_3_60(); break;
            case 60: jj_3_61(); break;
            case 61: jj_3_62(); break;
            case 62: jj_3_63(); break;
            case 63: jj_3_64(); break;
            case 64: jj_3_65(); break;
            case 65: jj_3_66(); break;
            case 66: jj_3_67(); break;
            case 67: jj_3_68(); break;
            case 68: jj_3_69(); break;
            case 69: jj_3_70(); break;
            case 70: jj_3_71(); break;
            case 71: jj_3_72(); break;
            case 72: jj_3_73(); break;
            case 73: jj_3_74(); break;
            case 74: jj_3_75(); break;
            case 75: jj_3_76(); break;
            case 76: jj_3_77(); break;
            case 77: jj_3_78(); break;
            case 78: jj_3_79(); break;
            case 79: jj_3_80(); break;
            case 80: jj_3_81(); break;
            case 81: jj_3_82(); break;
            case 82: jj_3_83(); break;
            case 83: jj_3_84(); break;
            case 84: jj_3_85(); break;
            case 85: jj_3_86(); break;
            case 86: jj_3_87(); break;
            case 87: jj_3_88(); break;
            case 88: jj_3_89(); break;
            case 89: jj_3_90(); break;
            case 90: jj_3_91(); break;
            case 91: jj_3_92(); break;
            case 92: jj_3_93(); break;
            case 93: jj_3_94(); break;
            case 94: jj_3_95(); break;
            case 95: jj_3_96(); break;
            case 96: jj_3_97(); break;
            case 97: jj_3_98(); break;
            case 98: jj_3_99(); break;
            case 99: jj_3_100(); break;
            case 100: jj_3_101(); break;
            case 101: jj_3_102(); break;
            case 102: jj_3_103(); break;
            case 103: jj_3_104(); break;
            case 104: jj_3_105(); break;
            case 105: jj_3_106(); break;
            case 106: jj_3_107(); break;
            case 107: jj_3_108(); break;
            case 108: jj_3_109(); break;
            case 109: jj_3_110(); break;
            case 110: jj_3_111(); break;
            case 111: jj_3_112(); break;
            case 112: jj_3_113(); break;
            case 113: jj_3_114(); break;
            case 114: jj_3_115(); break;
            case 115: jj_3_116(); break;
            case 116: jj_3_117(); break;
            case 117: jj_3_118(); break;
            case 118: jj_3_119(); break;
            case 119: jj_3_120(); break;
            case 120: jj_3_121(); break;
            case 121: jj_3_122(); break;
            case 122: jj_3_123(); break;
            case 123: jj_3_124(); break;
            case 124: jj_3_125(); break;
            case 125: jj_3_126(); break;
            case 126: jj_3_127(); break;
            case 127: jj_3_128(); break;
            case 128: jj_3_129(); break;
            case 129: jj_3_130(); break;
            case 130: jj_3_131(); break;
            case 131: jj_3_132(); break;
            case 132: jj_3_133(); break;
            case 133: jj_3_134(); break;
            case 134: jj_3_135(); break;
            case 135: jj_3_136(); break;
            case 136: jj_3_137(); break;
            case 137: jj_3_138(); break;
            case 138: jj_3_139(); break;
            case 139: jj_3_140(); break;
            case 140: jj_3_141(); break;
            case 141: jj_3_142(); break;
            case 142: jj_3_143(); break;
            case 143: jj_3_144(); break;
            case 144: jj_3_145(); break;
            case 145: jj_3_146(); break;
            case 146: jj_3_147(); break;
            case 147: jj_3_148(); break;
            case 148: jj_3_149(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}

class JTBToolkit {
   static NodeToken makeNodeToken(Token t) {
      return new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);
   }
}
