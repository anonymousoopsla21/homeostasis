/*

  C grammar defintion for use with JavaCC
  Contributed by Doug South (dsouth@squirrel.com.au) 21/3/97

  This parser assumes that the C source file has been preprocessed : all
  #includes have been included and all macros have been expanded. I accomplish
  this with "gcc -P -E <source file> > <output file>".

  There is a problem with compiler specific types, such as __signed, __const,
  __inline__, etc. These types can be added as typedef types before the parser
  is run on a file. See main() for an example. I have also found a strange little
  compiler specific "type" if you can call it that. It is __attribute__, but it
  does not seem to be used as a type. I found that just deleting the __attribute__
  and the following "offensive" code works.

  I have not in anyway extensively tested this grammar, in fact it is barely tested,
  but I imagine it is better to have a starting point for a C grammar other than from
  scratch. It has not been optimized in anyway, my main aim was to get a parser that
  works. Lookahead may not be optimum at choice points and may even be insufficient at
  times. I choose to err on the side of not optimum if I made a choice at all.

  If you use this grammar, I would appreciate hearing from you. I will try to maintain
  this grammar to the best of my ability, but at this point in time, this is only a side
  hobby (unless someone wants to pay me for doing JavaCC work!). In that regards, I am
  interested in hearing bugs and comments.

  TODO:

    Insert the appropriate code to enable C source trees from this grammar.

  */

PARSER_BEGIN(CParser)

public class CParser {
    // Hastable for storing typedef types
    public static Hashtable types = new Hashtable();

    // Stack for determining when the parser
    // is parsing a typdef definition.
    public static Stack typedefParsingStack = new Stack();

    // Returns true if the given string is
    // a typedef type.
    public static boolean isType(String type) {
  		if (types.get(type) != null) {
   	    	return true;
        }
   		return false;
    }

    // Add a typedef type to those already defined
    public static void addType(String type) {
   	  types.put(type, Boolean.TRUE);
    }

    // Prints out all the types used in parsing the c source
    public static void printTypes() {
        Enumeration enum1 = types.keys();
        while (enum1.hasMoreElements()) {
            System.out.println(enum1.nextElement());
        }
    }
}

PARSER_END(CParser)

TOKEN_MGR_DECLS :
{
	int attributeMatchingParens;
}

SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  "\f"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

<DEFAULT,AfterCrossbar,Pragma,Omp> TOKEN : {
 <INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? | <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])?>
|  <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
|  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
|  <#OCTAL_LITERAL: "0" (["0"-"7"])*>
|  <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]>
|  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
|  <CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'">
|  <STRING_LITERAL: "\"" (~["\"","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\"">
}

<DEFAULT> MORE : {
	"__attribute__" { attributeMatchingParens = 0; } : AfterAttrib
}

<AfterAttrib> MORE : {
	"(" { attributeMatchingParens++; }
|	")" { attributeMatchingParens--; if (attributeMatchingParens == 1) SwitchTo(AtAttribEnd); }
|	<~[]>
}

<AtAttribEnd> MORE : {
	"(" { attributeMatchingParens++; } : AfterAttrib
|	<~[")"]>
}

<AtAttribEnd> SPECIAL_TOKEN : {
	<__ATTRIBUTE: ")"> { attributeMatchingParens--; } : DEFAULT
}

/*
<DEFAULT> SPECIAL_TOKEN : {
 	"__const" 
}
*/

<DEFAULT,Omp> TOKEN : {
	<RESTRICT: "__restrict"> |
	<CONTINUE: "continue"> |
	<VOLATILE: "volatile"> |
	<REGISTER: "register"> |
	<UNSIGNED: "unsigned"> |
	<TYPEDEF: "typedef"> |
	<DFLT: "default"> |
	<DOUBLE: "double"> |
	<SIZEOF: "sizeof"> |
	<SWITCH: "switch"> |
	<RETURN: "return"> |
	<EXTERN: "extern"> |
	<STRUCT: "struct"> |
	<STATIC: "static"> |
	<SIGNED: "signed"> |
	<WHILE: "while"> |
	<BREAK: "break"> |
	<UNION: "union"> |
	<CONST: "const"> |
	<CCONST: "__const"> |
	<FLOAT: "float"> |
	<SHORT: "short"> |
	<ELSE: "else"> |
	<CASE: "case"> |
	<LONG: "long"> |
	<ENUM: "enum"> |
	<AUTO: "auto"> |
	<VOID: "void"> |
	<CHAR: "char"> |
	<GOTO: "goto"> |
	<FOR: "for"> |
	<INT: "int"> |
	<IF: "if"> |
	<DO: "do">
}

<DEFAULT,AfterCrossbar,Pragma,Omp>
TOKEN : {
  <ELLIPSIS: "...">
| <OP_SLASS: "<<=">
| <OP_SRASS: ">>=">
| <OP_EQ: "==">
| <OP_AND: "&&">
| <OP_OR: "||">
| <OP_MULASS: "*=">
| <OP_DIVASS: "/=">
| <OP_MODASS: "%=">
| <OP_ADDASS: "+=">
| <OP_SUBASS: "-=">
| <OP_ANDASS: "&=">
| <OP_XORASS: "^=">
| <OP_ORASS: "|=">
| <OP_SL: "<<">
| <OP_SR: ">>">
| <OP_NEQ: "!=">
| <OP_GE: ">=">
| <OP_LE: "<=">
| <OP_DEREF: "->">
| <OP_INCR: "++">
| <OP_DECR: "--">
| <OP_GT: ">">
| <OP_LT: "<">
| <OP_ADD: "+">
| <OP_SUB: "-">
| <OP_MUL: "*">
| <OP_DIV: "/">
| <OP_MOD: "%">
| <OP_ASS: "=">
| <OP_BITAND: "&">
| <OP_BITOR: "|">
| <OP_BITXOR: "^">
| <OP_NOT: "!">
| <OP_BITNOT: "~">
| <COLON: ":">
| <SEMICOLON: ";">
| <QUESTION: "?">
| <DOT: ".">
| <LEFTPAREN: "(">
| <RIGHTPAREN: ")">
| <LEFTBRACKET: "[">
| <RIGHTBRACKET: "]">
| <LEFTBRACE: "{">
| <RIGHTBRACE: "}">
| <COMMA: ",">
}

TOKEN : {
  <CROSSBAR: "#"> : AfterCrossbar
}

<AfterCrossbar,Cpp> TOKEN : {
  <UNKNOWN_CPP: ( "\r" | "\n" )+> : DEFAULT
}

<AfterCrossbar> TOKEN : {
  <PRAGMA: "pragma"> : Pragma
}

<AfterCrossbar> MORE : {
  "include" : Cpp
| "import" : Cpp
| "define" : Cpp
| "ifndef" : Cpp
| "ident" : Cpp
| "undef" : Cpp
| "ifdef" : Cpp
| "endif" : Cpp
| "line" : Cpp
}

<Cpp> SKIP : {
  <"\\" ( ( "\r" ["\n"] ) | "\n" )>
}

<Cpp> MORE : {
  <~[]>
}

<Pragma,Omp> SKIP : {
   " "
|  "\t"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

<Pragma> SKIP : {
   "\n" : DEFAULT
|  "\r" : DEFAULT
}

<Omp> TOKEN : {
   <OMP_NL: "\n"> : DEFAULT
|  <OMP_CR: "\r"> : DEFAULT
}

<AfterCrossbar> SKIP : {
   " "
|  "\t"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

<Pragma> TOKEN : {
  <OMP: "omp"> : Omp
}

<Pragma> MORE : {
  <~[]> : Cpp
}

<Omp> TOKEN : {
  <PARALLEL: "parallel"> 
| <SECTIONS: "sections"> 
| <SECTION: "section"> 
| <SINGLE: "single"> 
| <ORDERED: "ordered"> 
| <MASTER: "master"> 
| <CRITICAL: "critical"> 
| <ATOMIC: "atomic"> 
| <BARRIER: "barrier">
| <FLUSH: "flush">
| <NOWAIT: "nowait">
| <SCHEDULE: "schedule">
| <DYNAMIC: "dynamic">
| <GUIDED: "guided">
| <RUNTIME: "runtime">
| <NONE: "none">
| <REDUCTION: "reduction"> 
| <PRIVATE: "private"> 
| <FIRSTPRIVATE: "firstprivate"> 
| <LASTPRIVATE: "lastprivate"> 
| <COPYPRIVATE: "copyprivate"> 
| <SHARED: "shared"> 
| <COPYIN: "copyin"> 
| <THREADPRIVATE: "threadprivate"> 
| <NUM_THREADS: "num_threads"> 
| <COLLAPSE: "collapse"> 
| <READ: "read">
| <WRITE: "write">
| <UPDATE: "update">
| <CAPTURE: "capture">
| <TASK: "task">
| <TASKWAIT: "taskwait">
| <DECLARE: "declare">
| <TASKYIELD: "taskyield">
| <UNTIED: "untied">
| <MERGEABLE: "mergeable">
| <INITIALIZER: "initializer">
| <FINAL: "final">
}

<DEFAULT,AfterCrossbar,Omp>
TOKEN : {
   <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
|  <#LETTER: ["$","A"-"Z","_","a"-"z"]>
|  <#DIGIT: ["0"-"9"]>
}

// C with OpenMP Grammar

void TranslationUnit() : {}
{
	(ElementsOfTranslation())+
}

void ElementsOfTranslation() : {}
{
	LOOKAHEAD(3) ExternalDeclaration()
	| LOOKAHEAD(3) UnknownCpp() 
	| UnknownPragma()
}

void ExternalDeclaration() : {}
{
	LOOKAHEAD (FunctionDefinition()) FunctionDefinition() 
	| LOOKAHEAD (Declaration()) Declaration() 
	| LOOKAHEAD (DeclareReductionDirective()) DeclareReductionDirective()
	| ThreadPrivateDirective()
}

void FunctionDefinition() : {}
{
	[LOOKAHEAD(DeclarationSpecifiers()) DeclarationSpecifiers()] Declarator() [ DeclarationList() ]
	CompoundStatement()
}

void Declaration() : {}
{
	DeclarationSpecifiers() [ InitDeclaratorList() ] ";"
}

void DeclarationList() : {}
{
	( LOOKAHEAD(Declaration()) Declaration() )+
}

void DeclarationSpecifiers() : {}
{
	(LOOKAHEAD (ADeclarationSpecifier()) ADeclarationSpecifier())+
}

void ADeclarationSpecifier() : {}
{
	StorageClassSpecifier() 
	| TypeSpecifier() 
	| TypeQualifier() 

}

void StorageClassSpecifier() : {}
{
	<AUTO> | <REGISTER> | <STATIC> | <EXTERN> | <TYPEDEF>
}

void TypeSpecifier() : {}
{
	<VOID> | <CHAR> | <SHORT> | <INT> | <LONG> | <FLOAT> | <DOUBLE> | <SIGNED> |
	<UNSIGNED> | StructOrUnionSpecifier() | EnumSpecifier() | LOOKAHEAD(TypedefName())TypedefName()
}

void TypeQualifier() : {}
{
	<RESTRICT> | <CONST> | <VOLATILE> | <CCONST>
}

void StructOrUnionSpecifier() : {}
{

	LOOKAHEAD(StructOrUnionSpecifierWithList()) StructOrUnionSpecifierWithList() 
	| StructOrUnionSpecifierWithId()

}

void StructOrUnionSpecifierWithList() : {}
{
		StructOrUnion() [ <IDENTIFIER> ] "{" StructDeclarationList() "}"
	
} 

void StructOrUnionSpecifierWithId() : {}
{
		StructOrUnion() <IDENTIFIER>

}

void StructOrUnion() : {}
{
	<STRUCT> | <UNION>
}

void StructDeclarationList() : {}
{
	(StructDeclaration())+
}

void InitDeclaratorList() : {}
{
	InitDeclarator() ("," InitDeclarator())*
}

void InitDeclarator() : {}
{
	Declarator() [ "=" Initializer() ]
}

void StructDeclaration() : {}
{
	SpecifierQualifierList() StructDeclaratorList() ";"
}

void SpecifierQualifierList() : {}
{
	  (LOOKAHEAD (ASpecifierQualifierList()) ASpecifierQualifierList())+
}

void ASpecifierQualifierList() : {}
{
	  TypeSpecifier() 
	  | TypeQualifier() 
}

void StructDeclaratorList() : {}
{
	StructDeclarator() ( "," StructDeclarator() )*
}

void StructDeclarator() : {}
{
	StructDeclaratorWithDeclarator() | ":" ConstantExpression()
}

void StructDeclaratorWithDeclarator() : {}
{
	Declarator() [ ":" ConstantExpression() ]
}

void EnumSpecifier() : {}
{
	LOOKAHEAD(EnumSpecifierWithList()) EnumSpecifierWithList() | EnumSpecifierWithId()
}

void EnumSpecifierWithList(): {}
{
	<ENUM> [ <IDENTIFIER> ] "{" EnumeratorList() "}"}

void EnumSpecifierWithId(): {}
{
	<ENUM> <IDENTIFIER>
}

void EnumeratorList() : {}
{
	Enumerator() ("," Enumerator())*
}

void Enumerator() : {}
{
	<IDENTIFIER> [ "=" ConstantExpression() ]
}

void Declarator() : {}
{
	[ Pointer() ] DirectDeclarator()
}

void DirectDeclarator() : {}
{
	DirectIdentifierOrDeclarator() DeclaratorValueList() 
}

void DeclaratorValueList() : {}
{
	(ADeclaratorValue())*
}

void ADeclaratorValue() : {}
{
	LOOKAHEAD(ConstantExpressionComplete()) ConstantExpressionComplete() 
	| LOOKAHEAD(ParameterTypeListComplete()) ParameterTypeListNonOptionalComplete() 
	| IdentifierListComplete()
}

void ConstantExpressionComplete () : {}
{
	"[" [ ConstantExpression() ] "]"
}

void ParameterTypeListNonOptionalComplete() : {}
{
	"(" ParameterTypeList() ")"
}

void ParameterTypeListComplete() : {}
{
	"(" [ ParameterTypeList() ] ")"
}

void IdentifierListComplete() : {}
{
	"(" [ IdentifierList() ] ")"
}

void DirectIdentifierOrDeclarator() : {}
{
	<IDENTIFIER>
	| "(" Declarator() ")"
}

void Pointer() : {}
{
	"*" [ TypeQualifierList() ] [ Pointer() ]
}

void TypeQualifierList() : {}
{
	(TypeQualifier())+
}

void ParameterTypeList() : {}
{
	ParameterList() [ "," "..." ]
}

void ParameterList() : {}
{
	ParameterDeclaration() (LOOKAHEAD(2) "," ParameterDeclaration())*
}

void ParameterDeclaration() : {}
{
	LOOKAHEAD(ParameterDeclarationWithDeclarator()) ParameterDeclarationWithDeclarator() | ParameterDeclarationWithAbstractDeclarator() 
}

void ParameterDeclarationWithDeclarator() : {}
{
	DeclarationSpecifiers() Declarator()
}

void ParameterDeclarationWithAbstractDeclarator() : {}
{
	DeclarationSpecifiers() [ AbstractDeclarator() ]
}

void IdentifierList() : {}
{
	<IDENTIFIER> ("," <IDENTIFIER>)*
}

void Initializer() : {}
{
	AssignmentExpression() | "{" InitializerList() [","] "}"
}

void InitializerList() : {}
{
	Initializer() (LOOKAHEAD(2) "," Initializer())*
}

void TypeName() : {}
{
	SpecifierQualifierList() [ AbstractDeclarator() ]

}

void AbstractDeclarator() : {}
{
	LOOKAHEAD(AbstractDeclaratorWithPointer())AbstractDeclaratorWithPointer() | DirectAbstractDeclarator() 
}

void AbstractDeclaratorWithPointer() : {}
{
	Pointer() [ DirectAbstractDeclarator() ] 
}

void DirectAbstractDeclarator() : {}
{
	AbstractConstantParameterOption() ConstantParameterList()

	////
	}

void AbstractConstantParameterOption() : {}
{
	LOOKAHEAD(AbstractDeclaratorComplete()) AbstractDeclaratorComplete() | ConstantExpressionComplete() | ParameterTypeListComplete() 
}

void AbstractDeclaratorComplete() : {}
{
	"(" AbstractDeclarator() ")" 
}

void ConstantParameterList() : {}
{	
	(AConstantParameter())*
}

void AConstantParameter() : {}
{
	ConstantExpressionComplete()
	| ParameterTypeListComplete()
}

void TypedefName() : {}
{
	<IDENTIFIER>
}

void Statement() : {}
{
	( LOOKAHEAD(2) LabeledStatement() |
	  ExpressionStatement() |
	  CompoundStatement() |
	  SelectionStatement() |
	  IterationStatement() |
	  JumpStatement() |
	  LOOKAHEAD(4) UnknownPragma() |
	  LOOKAHEAD(4) OmpConstruct() |
	  LOOKAHEAD(2) OmpDirective() |
	  UnknownCpp() )
}

void UnknownCpp() : {}
{
	"#" <UNKNOWN_CPP> 
}

void OmpEol() : {}
{
    <OMP_CR> | <OMP_NL>
}

void OmpConstruct() : {}
{
	LOOKAHEAD(ParallelConstruct()) ParallelConstruct()
	| LOOKAHEAD(ForConstruct())ForConstruct()
	| LOOKAHEAD(SectionsConstruct())SectionsConstruct()
	| LOOKAHEAD(SingleConstruct())SingleConstruct()
	| LOOKAHEAD(ParallelForConstruct()) ParallelForConstruct()
	| LOOKAHEAD(ParallelSectionsConstruct()) ParallelSectionsConstruct()
	| LOOKAHEAD(TaskConstruct()) TaskConstruct()
	| LOOKAHEAD(MasterConstruct())MasterConstruct()
	| LOOKAHEAD(CriticalConstruct())CriticalConstruct()
	| LOOKAHEAD(AtomicConstruct()) AtomicConstruct()
	| OrderedConstruct()
	
}

void OmpDirective() : {}
{
	LOOKAHEAD(BarrierDirective()) BarrierDirective()
	| LOOKAHEAD(TaskwaitDirective()) TaskwaitDirective()
	| LOOKAHEAD(TaskyieldDirective()) TaskyieldDirective()
	| FlushDirective()	
}

void ParallelConstruct() : {}
{
	OmpPragma() ParallelDirective() Statement()
}

void OmpPragma() : {}
{
	<CROSSBAR> <PRAGMA> <OMP>
}

void UnknownPragma() : {}
{	
	<CROSSBAR> <PRAGMA> <UNKNOWN_CPP>
}

void ParallelDirective() : {}
{
	<PARALLEL> UniqueParallelOrDataClauseList() OmpEol()
}

void UniqueParallelOrDataClauseList() : {}
{
	(AUniqueParallelOrDataClause())*
}

void AUniqueParallelOrDataClause() : {}
{ 
	UniqueParallelClause()
	| DataClause() 
}


void UniqueParallelClause() : {}
{
	IfClause()
	| NumThreadsClause()
}

void IfClause() : {}
{
	<IF> "(" Expression() ")"
}

void NumThreadsClause() : {}
{
	<NUM_THREADS> "(" Expression() ")"
}

void DataClause() : {}
{
	OmpPrivateClause()
	| OmpFirstPrivateClause()
	| OmpLastPrivateClause()
	| OmpSharedClause()
	| OmpCopyinClause()
	| LOOKAHEAD(OmpDfltSharedClause()) OmpDfltSharedClause()
	| OmpDfltNoneClause()
	| OmpReductionClause()
}

void OmpPrivateClause() : {}
{
	<PRIVATE> "(" VariableList() ")"
}

void OmpFirstPrivateClause() : {}
{
	<FIRSTPRIVATE> "(" VariableList() ")"
}

void OmpLastPrivateClause() : {}
{
	<LASTPRIVATE> "(" VariableList() ")"
}

void OmpSharedClause() : {}
{
	<SHARED> "(" VariableList() ")"
}

void OmpCopyinClause() : {}
{
	<COPYIN> "(" VariableList() ")"
}

void OmpDfltSharedClause() : {}
{
	<DFLT> "(" <SHARED> ")"
}

void OmpDfltNoneClause() : {}
{
	<DFLT> "(" <NONE> ")"
}

void OmpReductionClause() : {}
{
	<REDUCTION> "(" ReductionOp() ":" VariableList() ")"
}
void ForConstruct() : {}
{
	OmpPragma() ForDirective() OmpForHeader() Statement()
}

void ForDirective() : {}
{
	<FOR> UniqueForOrDataOrNowaitClauseList() OmpEol()
}

void UniqueForOrDataOrNowaitClauseList() : {}
{
	(AUniqueForOrDataOrNowaitClause())*
}

void AUniqueForOrDataOrNowaitClause() : {}
{
	UniqueForClause()
	| DataClause()
	| NowaitClause() 
}

void NowaitClause() : {}
{
	<NOWAIT>
}

void UniqueForClause() : {}
{
 	<ORDERED>
	| UniqueForClauseSchedule()
	| UniqueForCollapse()
}

void UniqueForCollapse() : {}
{
	<COLLAPSE> "(" Expression() ")"	
}

void UniqueForClauseSchedule(): {}
{
	<SCHEDULE> "(" ScheduleKind() [ "," Expression() ] ")"
}

void ScheduleKind() : {}
{
	<STATIC> 
	| <DYNAMIC> 
	| <GUIDED> 
	| <RUNTIME>
//	| <AUTOOMP>
}

void OmpForHeader() : {}
{
	<FOR> "(" OmpForInitExpression() ";" OmpForCondition() ";" OmpForReinitExpression() ")"
}

void OmpForInitExpression() : {}
{
	<IDENTIFIER> "=" Expression()
}

void OmpForCondition() : {}
{
	LOOKAHEAD(OmpForLTCondition()) OmpForLTCondition()
	| LOOKAHEAD(OmpForLECondition()) OmpForLECondition()
	| LOOKAHEAD(OmpForGTCondition()) OmpForGTCondition()
	| OmpForGECondition()
}

void OmpForLTCondition() : {}
{
	<IDENTIFIER> "<" Expression()
}

void OmpForLECondition() : {}
{
	<IDENTIFIER> "<=" Expression()
}

void OmpForGTCondition() : {}
{
	<IDENTIFIER> ">" Expression()
}

void OmpForGECondition() : {}
{
	<IDENTIFIER> ">=" Expression()
}

void OmpForReinitExpression() : {}
{
	  LOOKAHEAD(PostIncrementId()) PostIncrementId()
	| LOOKAHEAD(PostDecrementId()) PostDecrementId()
	| LOOKAHEAD(PreIncrementId()) PreIncrementId()
	| LOOKAHEAD(PreDecrementId()) PreDecrementId()
 	| LOOKAHEAD(ShortAssignPlus()) ShortAssignPlus()	
 	| LOOKAHEAD(ShortAssignMinus()) ShortAssignMinus()
	| LOOKAHEAD(OmpForAdditive()) OmpForAdditive()
	| LOOKAHEAD(OmpForSubtractive()) OmpForSubtractive()
	| OmpForMultiplicative()
}	


void PostIncrementId() : {}
{
	<IDENTIFIER> "++"
}

void PostDecrementId() : {}
{
	<IDENTIFIER> "--"
}

void PreIncrementId() : {}
{
	"++" <IDENTIFIER>
}

void PreDecrementId() : {}
{
	"--" <IDENTIFIER>
}

void ShortAssignPlus() : {}
{
	<IDENTIFIER> "+=" Expression() 
}

void ShortAssignMinus() : {}
{
	<IDENTIFIER> "-=" Expression() 
}

void OmpForAdditive() : {}
{
	<IDENTIFIER> "=" <IDENTIFIER> "+" AdditiveExpression() 
}

void OmpForSubtractive() : {}
{
	<IDENTIFIER> "=" <IDENTIFIER> "-" AdditiveExpression() 
}

void OmpForMultiplicative() : {}
{
	<IDENTIFIER> "=" MultiplicativeExpression() "+" <IDENTIFIER>
}

void SectionsConstruct() : {} 
{
	OmpPragma() <SECTIONS> NowaitDataClauseList() OmpEol() SectionsScope()
}

void NowaitDataClauseList() : {}
{
	(ANowaitDataClause())*
}

void ANowaitDataClause() : {}
{
	NowaitClause()
	| DataClause() 
}

void SectionsScope() : {}
{
	"{" [ LOOKAHEAD(2) Statement() ] (ASection())* "}"
}

void ASection() : {}
{
	OmpPragma() <SECTION> OmpEol() Statement() 
}

void SingleConstruct() : {}
{
	OmpPragma() <SINGLE> SingleClauseList() OmpEol() Statement()
}

void SingleClauseList() : {}
{
	(ASingleClause())*
}

void ASingleClause() : {}
{
	NowaitClause()
	| DataClause()
	| OmpCopyPrivateClause()
}

void OmpCopyPrivateClause() : {}
{
	<COPYPRIVATE> "(" VariableList()  ")"
}

void TaskConstruct() : {}
{
	OmpPragma() <TASK> (TaskClauseList())* OmpEol() Statement()
}

void TaskClauseList() : {}
{
	DataClause()
	| UniqueTaskClause()
}

void UniqueTaskClause() : {}
{
	IfClause()
	| FinalClause() 
	| UntiedClause()
	| MergeableClause()
}

void FinalClause() : {}
{
	<FINAL> "(" Expression() ")" 
}	

void UntiedClause() : {}
{
	<UNTIED>
}

void MergeableClause() : {}
{
	<MERGEABLE>
}

void ParallelForConstruct() : {}
{
	OmpPragma() <PARALLEL> <FOR> UniqueParallelOrUniqueForOrDataClauseList() OmpEol() OmpForHeader() Statement()
}

void UniqueParallelOrUniqueForOrDataClauseList() : {}
{
	(AUniqueParallelOrUniqueForOrDataClause())*
}

void AUniqueParallelOrUniqueForOrDataClause() : {}
{
	UniqueParallelClause()
	| UniqueForClause()
	| DataClause() 
}

void ParallelSectionsConstruct() : {}
{
	OmpPragma() <PARALLEL> <SECTIONS> UniqueParallelOrDataClauseList() OmpEol() SectionsScope()
}

void MasterConstruct() : {}
{
	OmpPragma() <MASTER> OmpEol() Statement()
}

void CriticalConstruct() : {}
{
	OmpPragma() <CRITICAL> (RegionPhrase())? OmpEol() Statement()
}

void RegionPhrase() : {}
{
	"(" <IDENTIFIER> ")" 
}

void AtomicConstruct() : {}
{
	OmpPragma() <ATOMIC> OmpEol() (AtomicClause())? Statement()
}

void AtomicClause() : {}
{
	<READ>
	| <WRITE>
	| <UPDATE>
	| <CAPTURE>
}

void FlushDirective() : {}
{
	OmpPragma() <FLUSH> (FlushVars())? OmpEol()
}

void FlushVars() : {}
{
	"(" VariableList() ")"
}

void OrderedConstruct() : {}
{
	OmpPragma() <ORDERED> OmpEol() Statement()
}

void BarrierDirective() : {}
{
	OmpPragma() <BARRIER> OmpEol()
}

void TaskwaitDirective() : {}
{
	OmpPragma() <TASKWAIT> OmpEol() 
}

void TaskyieldDirective() : {}
{
	OmpPragma() <TASKYIELD> OmpEol() 
}

void ThreadPrivateDirective() : {}
{
	OmpPragma() <THREADPRIVATE> "(" VariableList() ")" OmpEol()
}

void DeclareReductionDirective() : {}
{
	OmpPragma() <DECLARE> <REDUCTION> "(" ReductionOp() ":" ReductionTypeList() ":" Expression()")" (InitializerClause())? OmpEol()
}

void ReductionTypeList() : {}
{
	(TypeSpecifier())*
}

void InitializerClause() : {}
{
	LOOKAHEAD(AssignInitializerClause()) AssignInitializerClause()
	| ArgumentInitializerClause()
}

void AssignInitializerClause() : {}
{
	<INITIALIZER> "(" <IDENTIFIER> "=" Initializer() ")"
}

void ArgumentInitializerClause() : {}
{
	<INITIALIZER> "(" <IDENTIFIER> "("ArgumentExpressionList() ")" ")"
}

void ReductionOp() : {}
{
	 <IDENTIFIER> |  "+" | "*" | "-" | "&" | "^" | "|" | "||" | "&&"
}

void VariableList() : {}
{
	<IDENTIFIER> ( "," <IDENTIFIER> )*
}

void LabeledStatement() : {}
{
	SimpleLabeledStatement()
	| CaseLabeledStatement()
	| DefaultLabeledStatement()
}

void SimpleLabeledStatement() : {}
{
	<IDENTIFIER> ":" Statement()
}

void CaseLabeledStatement() : {}
{
	<CASE> ConstantExpression() ":" Statement()
}

void DefaultLabeledStatement() : {}
{
	<DFLT> ":" Statement()
}

void ExpressionStatement() : {}
{
	(Expression())? ";"
}

void CompoundStatement() : {}
{
	"{" [ LOOKAHEAD(DeclarationList()) DeclarationList() ]
	            [ StatementList() ]
	"}"
}

void StatementList() : {}
{
	(Statement())+
}

void SelectionStatement() : {}
{
	IfStatement()
	| SwitchStatement()
}

void IfStatement() : {}
{
	<IF> "(" Expression() ")" Statement() [ LOOKAHEAD(2) <ELSE> Statement() ] 
}

void SwitchStatement() : {}
{
	<SWITCH> "(" Expression() ")" Statement() 
}


void IterationStatement() : {}
{
	WhileStatement()
	| DoStatement()
	| ForStatement()
}

void WhileStatement() : {}
{
	<WHILE> "(" Expression() ")" Statement() 
}

void DoStatement() : {}
{
	<DO> Statement() <WHILE> "(" Expression() ")" ";" 
}

void ForStatement() : {}
{
	<FOR> "(" [ Expression() ] ";" [ Expression() ] ";" [ Expression() ] ")" Statement()
}

void JumpStatement() : {}
{
	GotoStatement()
	| ContinueStatement()
	| BreakStatement()
	| ReturnStatement()
}

void GotoStatement() : {}
{
	<GOTO> <IDENTIFIER> ";"
}

void ContinueStatement() : {}
{
	<CONTINUE> ";"
}

void BreakStatement() : {}
{
	<BREAK> ";"
}

void ReturnStatement() : {}
{
	<RETURN> [ Expression() ] ";"
}

void Expression() : {}
{
	AssignmentExpression() ( "," AssignmentExpression() )*
}

void AssignmentExpression() : {}
{
	  LOOKAHEAD(NonConditionalExpression()) NonConditionalExpression()
	  | ConditionalExpression()
}

void NonConditionalExpression() : {}
{
	  UnaryExpression() AssignmentOperator() AssignmentExpression()
}

void AssignmentOperator() : {}
{
	"=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | "&=" | "^=" | "|="
}

void ConditionalExpression() : {}
{
	LogicalORExpression() [ "?" Expression() ":" ConditionalExpression() ]
}

void ConstantExpression() : {}
{
	ConditionalExpression()
}

void LogicalORExpression() : {}
{
	LogicalANDExpression() [ "||" LogicalORExpression() ]
}

void LogicalANDExpression() : {}
{
	InclusiveORExpression() [ "&&" LogicalANDExpression() ]
}

void InclusiveORExpression() : {}
{
	ExclusiveORExpression() [ "|" InclusiveORExpression() ]
}

void ExclusiveORExpression() : {}
{
	ANDExpression() [ "^" ExclusiveORExpression() ]
}

void ANDExpression() : {}
{
	EqualityExpression() [ "&" ANDExpression() ]
}

void EqualityExpression() : {}
{
	LOOKAHEAD(EqualExpression()) EqualExpression()
	| NonEqualExpression()
}

void EqualExpression() : {}
{
	RelationalExpression() [ "==" EqualityExpression() ]
}

void NonEqualExpression() : {}
{
	RelationalExpression() [ "!=" EqualityExpression() ]
}


void RelationalExpression() : {}
{
	LOOKAHEAD(RelationalLTExpression()) RelationalLTExpression()
	| LOOKAHEAD(RelationalGTExpression()) RelationalGTExpression()
	| LOOKAHEAD(RelationalLEExpression()) RelationalLEExpression()
	| RelationalGEExpression()
}

void RelationalLTExpression() : {}
{
	ShiftExpression() [ "<" RelationalExpression() ]
}

void RelationalGTExpression() : {}
{
	ShiftExpression() [ ">" RelationalExpression() ]
}

void RelationalLEExpression() : {}
{
	ShiftExpression() [ "<=" RelationalExpression() ]
}

void RelationalGEExpression() : {}
{
	ShiftExpression() [ ">=" RelationalExpression() ]
}

void ShiftExpression() : {}
{	
	LOOKAHEAD(ShiftLeftExpression()) ShiftLeftExpression()
	| ShiftRightExpression()
}

void ShiftLeftExpression() : {}
{	
	AdditiveExpression() [ ">>" ShiftExpression() ]
}

void ShiftRightExpression() : {}
{	
	AdditiveExpression() [ "<<" ShiftExpression() ]
}

void AdditiveExpression() : {}
{
	LOOKAHEAD(AdditivePlusExpression()) AdditivePlusExpression()
	| AdditiveMinusExpression()
}

void AdditivePlusExpression() : {}
{
	MultiplicativeExpression() [ "+" AdditiveExpression() ]
}

void AdditiveMinusExpression() : {}
{
	MultiplicativeExpression() [ "-" AdditiveExpression() ]
}

void MultiplicativeExpression() : {}
{
	LOOKAHEAD(MultiplicativeMultiExpression()) MultiplicativeMultiExpression()
	| LOOKAHEAD(MultiplicativeDivExpression()) MultiplicativeDivExpression()
	| MultiplicativeModExpression()
}

void MultiplicativeMultiExpression() : {}
{
	CastExpression() [ "*" MultiplicativeExpression() ]
}

void MultiplicativeDivExpression() : {}
{
	CastExpression() [ "/" MultiplicativeExpression() ]
}

void MultiplicativeModExpression() : {}
{
	CastExpression() [ "%" MultiplicativeExpression() ]
}

void CastExpression() : {}
{
	LOOKAHEAD(CastExpressionTyped()) CastExpressionTyped()
	| UnaryExpression()
}
	
void CastExpressionTyped() : {}
{
	"(" TypeName() ")" CastExpression() 
}

void UnaryExpression() : {}
{
	 LOOKAHEAD(3) PostfixExpression()
	 | UnaryExpressionPreIncrement()
	 | UnaryExpressionPreDecrement()
	 | UnarySizeofExpression() 
}

void UnaryExpressionPreIncrement() : {}
{
	  "++" UnaryExpression()
}

void UnaryExpressionPreDecrement() : {}
{
	  "--" UnaryExpression() 
}

void UnaryCastExpression() : {}
{
	  UnaryOperator() CastExpression() 
}

void UnarySizeofExpression() : {}
{
	LOOKAHEAD(SizeofUnaryExpression()) SizeofUnaryExpression()
	| SizeofTypeName() 	  
}

void SizeofUnaryExpression() : {}
{
	<SIZEOF> UnaryExpression()
}

void SizeofTypeName() : {}
{
	<SIZEOF> "(" TypeName() ")"
}

void UnaryOperator() : {}
{
	 "&" | "*" | "+" | "-" | "~" | "!" 
}

void PostfixExpression() : {}
{
	PrimaryExpression() PostfixOperationsList()
}

void PostfixOperationsList() : {}
{
	(APostfixOperationsList())*
}

void APostfixOperationsList() : {}
{
	BracketExpression()
	| ParenthesesArgumentExpressionList()
	| DotOperation()
	| DereferenceOperation()
	| PlusPlus() 
	| MinusMinus()
}

void PlusPlus() : {}
{
 	"++"
}

void MinusMinus() : {}
{
	"--"
}

void BracketExpression() : {} 
{
	"[" Expression() "]" 
}

void ParenthesesArgumentExpressionList() :{} 
{
	"(" [ LOOKAHEAD(ArgumentExpressionList() ) ArgumentExpressionList() ] ")" 
}

void DotOperation() : {} 
{
	"." <IDENTIFIER> 
}
 
void DereferenceOperation() : {} 
{
	<OP_DEREF> <IDENTIFIER> 
}

void PrimaryExpression() : {}
{
	<IDENTIFIER> 
	| Constant()
	| ParenthesesExpression() 
}

void ParenthesesExpression() : {}
{
	"(" Expression() ")"
}

void ArgumentExpressionList() : {}
{
	AssignmentExpression() ( "," AssignmentExpression() )*
}

void Constant() : {}
{
 <INTEGER_LITERAL> | <FLOATING_POINT_LITERAL> | <CHARACTER_LITERAL> | ( <STRING_LITERAL> )+
}

